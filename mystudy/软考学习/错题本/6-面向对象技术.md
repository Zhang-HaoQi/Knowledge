# 基础

## 面向对象分析/设计/程序设计

采用面向对象技术进行软件开发时，需要进行面向对象分析（OOA）、面向对象设计（OOD）、面向对象实现和面向对象测试几个阶段。

分析阶段的目的是为了获得对应用问题的理解，确定系统的功能、性能要求，在此阶段主要关注系统的行为，明确系统需要提供什么服务。

在设计阶段，采用面向对象技术将OOA所创建的分析模型转化为设计模型，其目标是定义系统构造蓝图。

在实现阶段（面向对象程序设计），系统实现人员选用一种面向对象程序设计语言，采用对象、类及其相关概念进行程序设计，即实现系统。             

### 面向对象分析（OOA）

着重分析问题域和系统责任，与测试无关。

1. 认定对象（确定实体）
2. 组织实体（对象抽象成类，建立类结构）
3. 对象间的相互作用
4. 基于对象的操作

![image-20211028171331378](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028171331378.png)

面向对象分析主要回答软件系统需要解决什么问题，在面向对象分析阶段，并不考虑系统实现以及系统的测试问题，强调建立独立与系统实现的系统分析模型，其关注点仍然侧重于问题域。             

### 面向对象设计

将面向对象分析创建的分析 模型转化为设计模型，目的定义系统构造蓝图。

在面向对象分析模型的基础上，包含对OOA对应的5个活动。

1. 识别类及对象
2. 定义属性
3. 定义服务
4. 识别关系
5. 识别包

![image-20211028151211036](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151211036.png)

1. 实体类主要负责数据和业务逻辑；
2. 边界类负责和用户进行交互，即用户界面；
3. 控制类则负责实体类和界面类的交互。             

## 业务用例和参与者

![image-20211028212324740](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028212324740.png)

在采用面向对象方法进行业务建模时，**业务用例和参与者一起描述组织或企业所支持的业务过程**。

业务流程被定义为多个不同的业务用例，其中每个业务用例都代表业务中某个特定的工作流程。

业务用例确定了执行业务时将要发生的事情，描述了一系列动作的执行，以及产生对特定业务主角具有价值的结果。

业务对象模型从业务角色内部的观点定义了业务用例。

该模型确定了业务人员及其处理和使用的对象之间应该具有的静态和动态关系，注重业务中承担的角色及其当前职责，**既描述业务结构，又描述这些结构元素如何完成业务用例。**       

## 动静态绑定

编译：静态

运行：动态

![image-20211015155525571](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015155525571.png)

 　　在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。

 　　动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以，父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送

## 面向对象方法

1. 面向对象开发方法有Booch方法、Coad方法和OMT方法。Jackson方法是一种面向数据结构的开发方法。        

## 语言特点

1. XML （可扩展标记语言）是标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 
2. Python是一种面向对象、解释型计算机程序设计语言。

3. Prolog是逻辑型程序设计语言。

4. C++为面向对象的编译型语言，而非解释型语言。        

5. php适合做动态网页处理     

   ![image-20211028115655551](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028115655551.png)

## 对象特性

![image-20211028120108818](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028120108818.png)

在面向对象技术中，对象是基本的运行时的实体，它既包括数据（属性），也包括作用于数据的操作（行为）。

一个对象把属性和行为封装为一个整体，与其他对象之间有清晰的边界，有良好定义的行为和可扩展性。对象位置和数量，由使用其的对象或系统确定。             

# UML各图示例

## 组件图

![image-20211028202827472](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028202827472.png)

2符号形象叫棒棒糖，表示提供的接口；1符号形象叫插座，表示要求提供的接口。有这两个符号，这是一个组件图（构件图），系统构件和构件之间，类或接口之间的关系图。

![image-20211028204103297](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028204103297.png)



![image-20211028214929700](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028214929700.png)

UML语言是标准的建模语言，通过图形化的方式展现系统的模型。本题是UML中的组件图，其表示的含义是组件AccountManagement需要调用CreditCardServices组件和Logger 组件分别实现的Identity Verifier 接口和TransactionLogger 接口。             



## 用例图

对需求进行建模时，使用该图特别合适。

用例图（Use Case Diagram）展现了**一组用例、参与者（Actor）以及它们之间的关系**。这个视图主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务。用例图用于对一个系统的需求进行建模，包括说明这个系统应该做什么（从系统外部的一个视点出发）， 而不考虑系统应该怎样做。

1. 题干有关于项目的相关描述，扣掉图中的某些用例，让考生猜。
2. 根据题目的意思，分析两个用例意见的关系，包含，扩展，泛化

![image-20211017152005184](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152005184.png)

**用例图说明参与者及其扮演的角色，可以是人、硬件或者其他系统可以扮演的角色，而非个人用户。**             

确定系统边界，识别出主要用例，建模用实例图

![image-20211028202412020](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028202412020.png)

用例图（use case diagram）展现了一组用例、参与者（Actor）以及它们之间的关系。用例图通常包括用例、参与者，以及用例之间的扩展关系（<<extend>>）和包含关系（<<include>>），参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系。如下图所示。  用例图用于对系统的静态用例视图进行建模，主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务。             

![image-20211028202528810](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028202528810.png)

## 类图与对象图

类图（Class Diagram）展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中，最常见的就是类图，它给出系统的静态设计视图。

对象图（Object Diagram）展现了某一时刻一组对象以及它们之间的关系。 

![image-20211017152401604](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152401604.png)

**多重度**

![image-20211017152423572](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152423572.png)

2..*  至少对应两个

**关系**

![image-20211018091732945](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211018091732945.png)

![image-20211028153215115](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028153215115.png)

注意：对象图的对象名会有：标识，并且对象图的关联关系一般不会出现多重度。

根据图示B依赖于A，也就是说，A发生变化会影响B，但是反过来，当B的一个实例被删除，不会影响A的实例。           

![image-20211028203614583](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028203614583.png)

UML中提供了类图，它以图形化的方式描述系统中对象及其关联关系。类图专注于系统的静态视图，它对于系统的领域内容建模特别重要。在该图中还包括多重性、关联关系、泛化/特化关系以及聚合关系。其中，关联关系是双向关系，即关联的对象双方彼此都能与对方通信。本题中人（Person）和动物（Animal）之间的关联关系，表示人可以将多只动物养为宠物（Pet），这时动物的角色是pet，重数为0..*。             

![image-20211028205725004](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028205725004.png)

 本题叙述中，一名医生（Doctor）可以治疗多位病人（Patient），—位病人可以由多名医生治疗，这样，医生类和病人类之间的关联关系的两端多童度均为多（*）。另外，一名医生可能多次治疗同一位病人，那么，要记录哪名医生治疗哪位病人时，霈要存储治疗（Treatment）的日期和时间。这一治疗日期和时间属性放在医生类和病人类都不合适，所以这一属性应该放在关联关系上，构成关联类治疗（Treatment），并且一名医生可以多次治疗同位病人，所以医生和病人组合并不唯一（non-unique）。             

![image-20211028205943363](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028205943363.png)

 使用类图情况的方式通常有以下三种。 

①对系统的词汇进行建模。决定哪些抽象是考虑中的系统的一部分，哪些抽象处于系统边界之外，并详细描述这些抽象和它们的职责。 ②对简单协作进行建模。协作是一些共同工作的类、接口和其他元素的群体，提供一些合作行为强于所有这些因素的行为之和，要有相互协作的一组类来实现这些协作的语义。

 ③对逻辑数据库模式建模。将模式看作是数据库的概念设计的蓝图，类图对这些数据库模式进行建模，有时也称为领域类图。

 **对象快照采用对象图进行建模。**             

## 顺序图（序列图）

表现处理事务时的时间顺序。

系统领域的建模。

UML序列图（Sequence Diagram）以二维图的形式显示对象之间交互的图，纵轴自上而下表示时间，横轴表示要交互的对象，主要体现对象间消息传递的时间顺序，强调参与交互的对象及其间消息交互的时序。序列图中包括的建模元素主要有：活动者（Actor）、对象（Object）、生命线（Lifeline）、控制焦点（Focus of control）和消息（Message）等。其中对象名标有下划线；生命线表示为虚线，沿竖线向下延伸；消息在序列图中标记为箭头；控制焦点由薄矩形表示。 消息是从一个对象的生命线到了一个对象生命线的箭头，用从上而下的时间顺序来安排。

![image-20211028170117177](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028170117177.png)

![image-20211017152709095](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152709095.png)

![image-20211028165953004](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028165953004.png)

本题图中evaluation为返回消息，其他为同步消息。al和a2均为Account对象，所以Account应该实现了xfer（）、minus（）和plus（）方法，Person应该实现check（）方法。             

## 活动图

活动图(activity diagram)是一种特殊的状态图，它展现了在系统内从一个治动到另一个活动的流程，专注于系统的动态视图，它对于系统的功能建模特别重要，并强调对象间的控制流程。如下图所示：

![image-20211028205044262](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028205044262.png)

活动图一般包括活动状态和动作状态、转换和对象。活动图有开始、结束和一系列动作，可以表示分支、合并、分岔和汇合。分支描述基于布尔表达式的可选择路径，可有一个入流和2个或多个出流，在每个出流上放置一个布尔表达式条件(监护表达式)，每个出流的条件不应该重叠，但需要覆盖所有可能性。合并描述当两条控制路径重新合并，不需要监护条件，只有一个出流。分岔描述把一个控制流分成两个或多个并发控制流，可以有一个进入转移和两个或多个离去转移，每个离去的转移表示一个独立的控制流，这些流可以并行的进行。汇合表示两个或多个并发控制流的同步，可以有两个或多个进入转移和一个离去转移，意味着每个进入流都等待，直到所有进入流都达到这个汇合处。             

和程序流程图相近，能表示整个执行流程和状态。

考试时，通常会抠掉某一部分，让你填完整。

**活动图形式一：**

![image-20211028122828859](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028122828859.png)

**活动图形式二：**

![image-20211017153141299](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017153141299.png)

![image-20211028151524564](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151524564.png)

该活动图能同时运行的最大线程数为2，从粗线分支位置开始，分为2个并行线程。

![image-20211028171432016](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028171432016.png)

采用UML对系统进行建模时，首先确定系统边界，识别出主要用例，建模用例图。然后对用例图中的复杂用例采用活动图进一步进行建模，以对用例中执行过程中对象如何通过消息相互交互进行建模。系统的领域模型采用类图进行建模，交互关系采用顺序图、交互概览图等进行建模。             

## 状态图

状态图（state diagram）展现了一个状态机，用于描述一个对象在其生存期间的动态行为，表现为4个对象所经历的状态序列，它由状态、转换、事件和活动组成。

状态图关注系统的动态视图，它对于接口、类和协作的行为建模尤为重要强调对象行为的事件顺序。状态图通常包括简单状态和组合状态、转换（事件和动作）。 可以用状态图对系统的动态方面建模。这些动态方面可以包括出现在系统体系结构的任何视图中的任何一种对象的按事件排序的行为，这些对象包括类（各主动类）、接口、构件和节点。 当对象处于某个状态时，这个状态被称为激活状态（active state）。任何从激活状态出发的转换所标识的事件被检测到发生时，进行转换，而从当前状态出发的事件如果没有标注所检测到的事件名称，就忽略该事件，不激发任何转换，当前状态仍然是激活状态。

表现状态的变迁，属于动态图。以状态为节点

考试：给你状态，涉及多种状态之间的变迁，让你填充状态或状态的条件。

![image-20211017155409107](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017155409107.png)

  ![image-20211028151054131](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151054131.png)

事件触发一个没有特定监护条件的迁移，对象不一定离开当前状态。

![image-20211028172842839](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028172842839.png)

解析：

转换包括：事件触发器，监护条件，动作。

迁移包括：事件触发器，监护条件，状态。

![image-20211028201559539](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028201559539.png)

UML2.0中状态图主要用于描述对象、子系统、系统的生命周期。通过状态图可以了解到一个对象所能到达的所有状态以及对象收到的事件（消息、超时、错误、条件满足等）对对象状态的影响等。针对具有可标记的状态和复杂的行为的对象构建状态图。状态可能有嵌套的子状态，且子状态可以是一个状态图。 本题图示状态图中，ON是一个超状态，它有3个子状态:Idle、Rewinding和Playing， 这三个子状态之间在相关事件发生时状态之间进行迁移。             

## 通信图

顺序图的另一种表达方式，通信图不强调时间顺序。

包含：顶点（aOrder：Order等），链（消息1.1,1.2等），监护条件（带中括号，如[for each orderitem]等）

通信图（communication diagram）强调收发消息的对象的结构组织，强调参加交互的对象的组织，在早期的版本中也被称作协作图。如下图所示，**参与交互的对象作为图的顶点**，**连接这些对象的链表示为图的弧**，**用对象发送和接收的消息来修饰这些链。**通信图**有路径，消息有序号，如图中的1、2、2.1**等。

![image-20211017155702173](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017155702173.png)

![image-20211028173421190](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028173421190.png)

本题叙述中，给出一个通信图的实例，图中参与交互的对象作为图的顶点，包括![image-20211028195543716](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028195543716.png)等，对象之间的连线表示链，并用消息来进行修饰，如图中![image-20211028195600610](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028195600610.png)等，其中序号1表示第一条消息，2表示第二条消息，1.1表示嵌套在消息1中的第一条消息，1.2表示嵌套在消息1中的第二条消息，2.1表示嵌套在消息2中的第一条消息，2.2表示嵌套在消息2中的第二条消息，依此类推。在一条消息中，可以有监护条件，如题图中消息1.2:[interested]:view_book（) 中的[interested]。             

## 部署图

部署图描述了一个运行时的硬件结点，以及在这些结点上运行的软件组件的静态视图。 

![image-20211028165424580](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211028165424580.png)

![image-20211015150134575](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015150134575.png)

![image-20211027104058298](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027104058298.png)

部署图显示了系统的硬件，安装在硬件上的软件，以及用于连接异构的机器之间的中间件。因此它是在实施阶段被使用。

消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。

![image-20211028165642773](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028165642773.png)

UML2.0中提供的部署图展现了运行处理节点以及其中组件的配置，描述代码的物理模块，用于描述系统在不同计算机系统的物理分布。部署图给出了体系结构的静态实施视图。它与组件图相关，通常一个节点包含一个或多个组件，其依赖关系类似于包图。             

![image-20211028211450985](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028211450985.png)

## 各类图特点汇总

类图（Class Diagram）展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中，最常见的就是类图，它给出系统的静态设计视图。

对象图（Object Diagram）展现了某一时刻一组对象以及它们之间的关系。 

用例图（Use Case Diagram）展现了一组用例、参与者（Actor）以及它们之间的关系。这个视图主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务。用例图用于对一个系统的需求进行建模，包括说明这个系统应该做什么（从系统外部的一个视点出发）， 而不考虑系统应该怎样做。

组件图（component diagram）展现了一组组件之间的组织和依赖，专注于系统的静态实现视图，与类图相关，通常把组件映射为一个或多个类、接口或协作。

部署图（deployment diagram）是用来对面向对象系统的物理方面建模的方法，展现了运行处理节点以及其中构件的配置。部署图给出了体系结构的静态实施视图。它与构件图相关，通常一个节点包含一个或多个构件。

状态图（state diagram）展现了一个状态机，用于描述一个对象在其生存期间的动态行为，表现为4个对象所经历的状态序列，它由状态、转换、事件和活动组成。

**交互图表现为序列图、通信图、交互概览图和时序图，每种针对不同的目的，能适用于不同的情况。交互图展现了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。顺序图是强调消息的时间次序的交互图。 本题图示为序列图。序列图展示了1个用例和多个对象的行为。**

序列图是强调消息时间顺序的交互图；

通信图是强调接收和发送消息的对象的结构组织的交互图；交互概览图强调控制流的交互图。

时序图（Timing Diagram）关注沿着线性时间轴、生命线内部和生命线之间的条件改变。

活动图：是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程，专注于系统的动态视图，它对于系统的功能建模特别重要，并强调对象间的控制流程。一般包括活动状态和动作状态、转换和对象。

 				 				顺序图（sequence diagram，序列图）。顺序图是一种交互图（interaction diagram），

# 对象之间的关系

UML是面向对象软件的标准化建模语言，由三个要素构成：UML的基本构造块、支配这些构造块如何放置在一起的规则和运用与整个语言的一些公共机制。

UML的词汇表包含三种构造块：事物、关系和图。事物是对模型中最具有代表性的成分的抽象；关系把事物结合在一起；图聚集了相关的事物。其中关系包括4种：依赖、关联、泛化和实现。  

## UML中的关系

1. 泛化：一个类与它的一个或多个细化类之间的关系，表达一般与特殊的关系
2. 实现：
3. 依赖：两个事物间的语义关系，其中一个事物（独立事物）发生变化会影响另一个事物（依赖事物）的语义
4. 关联：是一种结构关系，它描述了一组链，链是对象之间的连接
5. 聚合
6. 组合：组合是一种聚合关系，其中整体负责其部分的创建和销毁，如果整体不存在了，部分也将不存在。
7. 聚集：聚集是一种特殊类型的关联，其中一个较大的整体类包含一个或多个较小的部分类；相反地，一个较小的部分类是一个较大的整体类的一部分。 

![image-20211028215345216](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028215345216.png)

UML类图中类与类之间的关系有五种：依赖、关联、聚合、组合与继承。依赖是几种关系中最弱的一种关系，通常，使用类库就是其中的一种关系。聚合与组合都表示了整体和部分的关系。组合的程度比聚合高，当整体对象消失时，部分对象也随之消失，则属于组合关系，当整体对象消失而部分对象依然可以存在并继续被使用时，则属于聚合关系。

### 关联

![image-20211028170850009](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028170850009.png)

在UML中，关系把事物结合在一起，包括依赖、关联、泛化和实现四种。关联是一种结构关系，描述了一组链，即对象之间的连接；聚集是一种特殊类型的关联，描述了整体和部分之间的结构关系。在关联上可以标注重复度（multiplicity）和角色（role）。两个类之间可以有多个关联，但这些关联需要由不同角色进行标识。             

## 领域模型

定义领域模型是面向对象分析的关键步骤之一。领域模型是从按对象分类的角度来创建对象领域的描述，包括**定义概念、属性和重要的关联，**其结果用一组显示领域概念和对象的图形一一类图来组织，图中还包括多重性、关联关系、泛化/特化关系以及聚合关系等。             

## 动态与静态图

![image-20211027094144992](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027094144992.png)





​               

# 软件项目活动图

![image-20211028115750566](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028115750566.png)

用时最长的路径即关键路径。

2---5---7---8为关键路径，2587这些都是关键路径上的点。

# 软件开发

## 封装

封装是一种信息隐藏技术，其目的是使对象（组件）的使用者和生产者分离，也就是使其他开发人员无需了解所要使用的软件组件内部的工作机制，只需知道如何使用组件，即组件提供的功能及其接口。             

![image-20211028151338854](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151338854.png)

## 多态

![image-20211027082548446](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027082548446.png)

在面向对象技术中，不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。

 多态分为两种：通用的多态和特定的多态。两者的区别是前者对工作的类型不加限制，允许对不同类型的值执行相同的代码；后者只对有限数量的类型有效，而且对不同类型的值可能要执行不同的代码。

多态有参数多态、包含多态、过载多态和强制多态四类。

通用多态：参数多态和包含多态。    特定多态：过载多态和强制多态

1. 参数多态:采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。(类似模板类吧!)
2. 包含多态:同样的操作可用于一个类型及其子类型。（注意是子类型，不是子类。）包含多态一般需要进行运行时的类型检查。
3. 过载多态：同一个名（操作符﹑函数名）在不同的上下文中有不同的类型。
   1. 俗的讲法，就是c++中的函数重载。在此处中“overload”译为“过载”，其实就是所谓的“重载”，也许“overload”就应翻译为“过载，重载”吧，那“override”就只能是“覆盖”了。
4. 强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。
   1. 举个例子，比如，int+double，编译系统一般会把int转换为double，然后执行double+double运算，这个int-》double的转换，就实现了强制多态，即可是隐式的，也可显式转换。

![image-20211028152320843](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028152320843.png)

多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次。**一个对象发送通用消息请求服务时，它无需知道所调用方法的特定子类实现，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定**，以实现在这些低层次上生成的对传给用消息以不同的响应。             

## 多重继承

![image-20211028153018120](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028153018120.png)

多重继承是编程语言中的概念，多重继承指的是一个类可以继承另外一个类，而另外一个类又可以继承别的类，比如A类继承B类，而A类又可以继承C类，这就是多重继承。多重继承可能造成混淆的情况，出现二义性的成员。            

## 接口

![image-20211028201208234](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028201208234.png)

 				在采用UML进行面向对象系统建模时，会用UML中构造型（stereotype）名称为«interface»来表示接口这一概念，声明对象类所需要的服务，而服务具体如何执行，有实现它的具体类完成。             

# 设计模式

![image-20211015105024037](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015105024037.png)

![image-20211015105047868](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015105047868.png)



![image-20211015145447625](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015145447625.png)

适配器模式将一个接口转换成为客户想要的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。

桥接模式·将抽象部分与实现部分分离，使得它们两部分可以独立地变化。

组合模式组合多个对象形成树型结构以表示整体—部分的结构层次。

装饰器模式动态地给一个对象增加其他职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。

状态模式为类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。状态A做什么事情，状态B做什么事情。

![image-20211015145740138](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015145740138.png)



命令模式的特点为：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。本题描述为命令模式。

 职责链模式（Chain of Responsibility）：通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。

 观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

 策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化。

责任链（Chain of Responsibility）模式将多个对象的请求连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止，避免请求的发送者和接收者之间的耦合关系。

![image-20211027103655903](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027103655903.png)

观察者（Observer）模式定义对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 在上述观察者模式的类图中，Subject （目标）知道其观察者，可以有任意多个观察者观察同一个目标，提供注册和删除观察者对象的接口。Observer （观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。ConcreteSubject （具体目标）将有关状态存入各ConcreteObserver对象，当它的状态发生改变时，向它的各个观察者发出通知。ConcreteObserver （具体观察者）维护一个指向ConcreteSubject对象的引用，存储有关状态，实现Observer的更新接口以使自身状态与目标的状态保持一致。    

## 桥接模式

![image-20211028200414282](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028200414282.png)

第一空，根据题干描述，该设计模式将抽象部分与其实现部分分离，使它们都可以独立的变化，指的是桥接模式。

第二空，根据桥接模式的结构，实现类接口,定义实现类的接口，这个接口不一定要与抽象类的接口完全一致，事实上这两个接口可以完全不同，**一般的讲实现类接口仅仅给出基本操作，而抽象类接口则会给出很多更复杂的操作。**本题仅仅给出基本操作的是Drawing。

第三空

![image-20211028203150567](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028203150567.png)

想表示对象的部分-整体层次结构描述的是组合模式，想使用一个已经存在的类，而它的接口不符合要求描述的是适配器模式，在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责描述的是装饰模式，不希望在抽象和它的实现部分之间有一个固定判定关系描述的是桥接模式。

第四空，桥接模式是结构型对象模式。             

## 中介模式

![image-20211028204212150](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028204212150.png)

中介者（Mediator）用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

观察者（Observer）模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 以上四种设计模式都是行为设计模式。

## 状态模式

![image-20211028210714364](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028210714364.png)

## 观察者模式

![image-20211028210837844](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028210837844.png)

观察者（Observer）模式为行为设计模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。在题图所示的观察者模式的结构图中：

①Subject （目标）知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口； 

②Observer （观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口； 

③ConcreteSubject （具体目标）将有关状态存入各ConcreteObserver对象；当它的状态发生改变时，向其各个观察者发出通知； ④ConcreteObserver （具体观察者）维护一个指向ConcreteSubject对象的引用；存储有关状态，这些状态应与目标的状态保持一致；实现Observer的更新接口，以使自身状态与目标的状态保持一致。 该模式的特点适用于以下情况： ①当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用； ②当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时； ③当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。

![image-20211028215520865](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028215520865.png)



## 访问者模式

![image-20211028211648971](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028211648971.png)

一个对象结构包含很多类对象（Item），而系统要求这些对象实施一些依赖于某具体类（Checkout）的操作时，可以使用访问者模式。             

## 组合模式

![image-20211028213123584](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028213123584.png)

组合（Composite）模式描述了如何将对象组合成树形结构以构造一个层次结构来表示“部分-整体”，使得客户对单个对象和组合对象的使用具有一致性，这一结构由两种类型的对象所对应的类构成，使得可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。上**图中的Composite 定义有子部件的那些部件的行为；组合部件的对象由Client通过Component提供的接口操作。装饰器（Decorator）模式则描述动态地给一个对象添加一些额外的职责。**             

## 状态模式

![image-20211028220039217](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028220039217.png)

![image-20211028220341865](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028220341865.png)

状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的（stateful）对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。             
