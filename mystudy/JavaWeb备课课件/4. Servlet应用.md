# Servlet应用

# 1. ServletRequest

## 1. 介绍

**request和response对象是由服务器创建的**，我们来使用他们。

request是来获取请求消息，response设置响应消息。

```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/html");

        // Hello
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h1>" + message + "</h1>");
        out.println("</body></html>");
    }
```

**解析**

![image-20211216135811805](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216135811805.png)

### Request体系

![image-20211216140020719](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216140020719.png)

### **获取请求消息数据**

#### **获取请求行**

GET  /servlet /demo1？name=zhangsan  HTTP/1.1

1. 获取请求方式: GET

   String getMethod()

2. 获取虚拟目录: /servlet 

   String getContextPath()

3. 获取Servlet路径: /demo1

   String getServletPath( )

4. 获取get方式请求参数: name= zhangsan

   String getQueryString()

5. 获取请求URI : /servlet / demo1

   string getRequestURI():

6. 获取url : http://localhost/servlet / demo1

  	StringBuffer getRequestURL()
  	
  	URL:统一资源定位符: http://localhost/day14/demo1 中华人民共和国	url+文件路径
  	URI :统一资源标识符: /day14/demo1              共和国            文件路径

7. 获取协议及版本: HTTP/1.1

  	String getProtocol()

8. 获取客户机的IP地址：

   	String getRemoteAddr()

#### 获取请求头

1. String getHeader(String name ) :通过请求头的名称获取请求头的值

   1. ```java
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          //1、获取user-agent的头数据
          //告诉服务器我的浏览器版本
          String userHeader = request.getHeader("user-agent");
          System.out.println(userHeader);
          //判断浏览器版本
          if (userHeader.contains("Chrome")) {
              System.out.println("谷歌");
          } else {
              System.out.println("火狐");
          }
          System.out.println(".....................");
       //2、获取referer的头数据
          String refer = request.getHeader("referer");
          System.out.println(refer); 
           //当直接在浏览器输入时，此时为空   问题：为什么我把链接复制到文档里面打开也是null。。
           //当我通过页面访问时，就可以获取访问地址  http://localhost:8888/servlet/Login.html 
      }
      
      ```

2. Enumeration<string> getHeaderNames() ;获取所有的请求头名称

   1. ```java
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          //获取所有请求头
       Enumeration<String> headerNames= request.getHeaderNames();
          System.out.println("...................");
          System.out.println(headerNames);  //  org.apache.tomcat.util.http.NamesEnumerator@275fd6f4
          while(headerNames.hasMoreElements()){
              String name = headerNames.nextElement();
              //获取头的数据
              String value =request.getHeader(name);
              System.out.println(value);
          }
      }
      ```

##### 获取超链接的所有头信息

```jsp
	<a href="/servlet/demo3">访问服务器</a>
```

![image-20211216141609662](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216141609662.png)

##### 防盗链操作

首先我们部署两个项目，一个项目是存放另一个项目的超链接，一个项目是进行消息反馈。

即一个自制电影网站，一个优酷网站。通过自制网站访问优酷内容，和优酷自身访问优酷内容。比较其差别。

**项目一（优酷）：**

```java
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String referer =  request.getHeader("referer");
    System.out.println(referer);
    if(referer.contains("8808")){
        System.out.println("看电影没门");
        response.setContentType("text/html;charset=utf-8");
        response.getWriter().write("盗我的视频，没有门");
    }else
    {
        System.out.println("请看电影");
        response.setContentType("text/html;charset=utf-8");
        response.getWriter().write("请看电影哈");
    }
}

// 访问链接：
<a href="/servlet/demo3">高清电影</a>
```

refer:http://localhost:8800/servlet/

**项目二（自建小网站）**：

访问链接：访问的是项目一

```java
<a href="http://localhost:8800/servlet/ServletDemoOne">高清视频</a>
```

refer:http://localhost:8808

#### 获取请求体

请求体:只有POST请求方式,才有请求体,在请求体中封装了POST请求的请求参数
 步骤：

1. 获取流对象
   1. BufferedReader getReader()     字符输入流，**可操作字符串类型的数据**
   2. ServletInputStream getInputstream() 字节输入流，可操作所有类型的数据，图片，文档等
      1. 相关内容在文件上传中
2. 再从流对象中获取数据

```java
@WebServlet("/ServletDemoTwo")
public class ServletDemoTwo extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          //获取请求消息体，即请求参数
        //1.获取字符流
        BufferedReader bf =request.getReader();
        System.out.println(bf.readLine());
        //2.获取数据
        String line= null;
        //line=参数，如果为空，这说明没有数据了
        while ((line=bf.readLine())!=null){
            System.out.println(line);
        }
    }

```

发送请求：

```jsp
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="/request/ServletDemoTwo" method="post">
    <input type="username" name="value" placeholder="用户名">
    <br>
    <input type="username" name="password" placeholder="密码">
    <br>
    <input type="submit" value="提交">
</form>
</body>
</html>
```

![image-20211216153233616](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216153233616.png)

### 其他功能

#### 1. 获取请求参数通用方式

1. String getParameter(String name) :根据参数名称获取参数值 username=zh&password=12

**html代码**

```html
<form action="/request/ServletDemoThree" method="post">
    <input type="username" name="username" placeholder="用户名">
    <br>
    <input type="username" name="password" placeholder="密码">
    <br>
    <input type="submit" value="提交">
</form>
<form action="/request/ServletDemoThree" method="get">
    <input type="username" name="username" placeholder="用户名">
    <br>
    <input type="username" name="password" placeholder="密码">
    <br>
    <input type="submit" value="提交">
</form>
```

**servlet代码**

```java
public class ServletDemoThree extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       String parameter= request.getParameter("username");
        System.out.println("post");
        System.out.println(parameter);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      //  String parameter= request.getParameter("username");
      //  System.out.println("get");
     //   System.out.println(parameter);
        
        因为方法都是通用的，所有post和get里面的方法基本一样，我们就可以实现代码复用
        this.doPost(request,response);就ok了
    }
}

```

**运行结果：**

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image002.gif)

2. String[ ] getParametervalues(String name ) ;根据参数名称获取参数值的数组hobby=xx&hobby=game

3. Enumeration<String> getParameterNames( ):获取所有让求的参数名称

4. Map<String, String[]> getParameterMap( ) :获取所有参数的map集合

Servlet代码

```java
public class ServletDemoThree extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //一、根据参数名称获取参数值
       String parameter= request.getParameter("username");
       // System.out.println(parameter); //1427421650
        //二、根据参数值名称获取参数值数组  针对于复选框
        String[] hobbies = request.getParameterValues("hobby");
        for (String hobby:hobbies) {
          //  System.out.println(hobby);//篮球，足球，橄榄球
        }
        //三、获取所有参数名称
        Enumeration<String> parameterNames = request.getParameterNames();
        while (parameterNames.hasMoreElements()){
            String name= parameterNames.nextElement();
            //System.out.println(name); //username password hobby
        }
        //四、获取所有参数名称及其参数值，以键值对的方式保存
        Map<String, String[]> parameterMap = request.getParameterMap();
        //遍历方法1
        for(String key:parameterMap.keySet()) {
            System.out.println(key);
            for (int a=0;a<parameterMap.get(key).length;a++){
                System.out.println(parameterMap.get(key)[a]);
            }
            System.out.println(".......................");
        }
        //遍历方法2
        Map<String, String[]> parameterMap1= request.getParameterMap();
        Set<String> keyset = parameterMap1.keySet();
        for (String name: keyset) {
            //获取键和值
            String [] values = parameterMap.get(name);
            System.out.println(name);
            for (String value:values) {
                System.out.println(value);
            }
            System.out.println("...............................");

        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       this.doPost(request,response);
    }
}
```

**HTML代码**

```java
<form action="/request/ServletDemoThree" method="get">
    <input type="username" name="username" placeholder="用户名">
    <br>
    <input type="username" name="password" placeholder="密码">
    <input type="checkbox" name="hobby" value="篮球">篮球
    <input type="checkbox" name="hobby" value="足球">足球
    <input type="checkbox" name="hobby" value="橄榄球">橄榄球
    <br>
    <input type="submit" value="提交">
</form>
```

#### 2. 请求转发:

我们在写代码时，不可能将代码都写在一个类里面，所以当服务器访问Servlet接口时，通常是一个接口将信息分担给另一个接口，这样便于维护

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image004.gif)

**步骤：**

1. 通过request对象获取请求转发器对象：RequestDispatcher  getRequestDispatcher(String path)

2. 使用RequestDispatcher对象来进行转发: forward(ServletRequest request, ServletResponse response)

**特点:**

1. 浏览器地址栏路径不发生变化

2. 只能转发到当前服务器内部资源中。

3. 转发是一次请求

发送请求到**ServletDemoFive**，之后转发到**ServletDemoSix** 

**ServletDemoFive**

```java
public class ServletDemoFive extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("55555");
        //方法一
        RequestDispatcher requestDispatcher = request.getRequestDispatcher("/ServletDemoSix");
        requestDispatcher.forward(request,response);
        //方法二
        request.getRequestDispatcher("ServletDemoSix").forward(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       this.doPost(request,response);
    }
}
```

**ServletDemoSix** 

```java
public class ServletDemoSix extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("66666");

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       this.doPost(request,response);
    }
}
```

**结果：**

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image006.gif)    ![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image008.gif)

#### 3. 共享数据

**域对象:**一个有作用范围的对象，可以在范围内共享数据

**request域:** 代表一次请求的范围，**一般用于请求转发的多个资源中共享数据**

**方法:**

1. void setAttribute(String name , object obj) :存储数据

2. object getAttitude(String name) :通过键获取值

3. void removeAttribute(String name) :通过键移除键值对

**存储数据到request域中**

```java
@WebServlet("/ServletDemoFive")
public class ServletDemoFive extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //存储数据到request域中
        request.setAttribute("msg","helloworld");
        //方法二
        request.getRequestDispatcher("ServletDemoSix").forward(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       this.doPost(request,response);
    }
}
```

**在其他类中获取数据**

```java
@WebServlet("/ServletDemoSix")
public class ServletDemoSix extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Object msg = request.getAttribute("msg");
        System.out.println(msg);   //helloworld
        System.out.println("66666");

    }
```

结果：

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image010.gif)

#### 4.获取ServletContext

1. ServletContext  getServletContext()

#### 中文乱码问题

1. 发送get请求时，不会发生乱码问题。因为Tomcat8已解决这种问题。

2. 当发送post请求时，如果请求内容为中文，会出现乱码问题。

   解决措施：请求参数前声明一下编码格式

```java
public class ServletDemoFour extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       //获取参数
        request.setCharacterEncoding("utf-8");
        String usename = request.getParameter("username");
    }
```

**乱码问题：**

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image002.gif)

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image004.gif)

 

## 2. 如何同时运行两个项目，部署两个服务器

### 1、创建两个项目 request 和request2

a)   ![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image006.gif)

### 2、进行request的服务器配置

a)   

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image008.gif)

b)   

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image010.gif)

### 3、进行request2的服务器配置

a)   在创建一个服务器

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image012.gif)

b)  进行新服务器配置

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image014.gif)

c)   ；将项目添加到服务器

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image016.gif)

### 4、使用：

根据需要启动服务器

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image018.gif)

### 5、服务器设置介绍

![image-20211216155314491](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216155314491.png)

## 3. 案例：用户登陆

### 项目所在位置

E:\Java文件\login

### 案例需求:

1. 编写login. html登录页面username & password两个输入框

2. 使用Druid数据库连接池技术，操作mysql, day14数据库中user表（这里使用的是C3P0链接池）

3. 使用JdbcTemplate技术封装JDBC（使用返回的数据直接封装）

4. 登录成功跳转到SuccessServlet展示:登录成功!用户名，欢迎您

5. 登录失败跳转到FailServlet展示:登录失败，用户名或密码错误

### 逻辑图示：

![image-20211216155747452](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216155747452.png)

### 报错：

 Could not initialize class cn.itcast.Util.JDBCUtils

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image024.gif)

解决：

jar包放在lib文件夹里面，而我却放在了libs里面

### 核心代码

请求代码:

```java
 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.设置编码
        response.setContentType("text/html;charset=utf-8");
        //2.获取请求参数   并封装成对象
//        String username = request.getParameter("username");
//        String password = request.getParameter("password");
//        User loginUser = new User(1, username, password);
        //A使用BeanUtils 获取对象
        //A.1获取参数的map集合
        Map<String, String[]> parameterMap = request.getParameterMap();
        //A.2创建一个User对象
        User loginUser = new User();
        //A.3使用BeanUtils封装
        try {
            BeanUtils.populate(loginUser,parameterMap);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        //访问数据库并获取对象
        UserDao dao = new UserDao();
        User user = dao.login(loginUser);
        //判断是否是我们的用户
        if (user== null) {
            System.out.println("您不是我们的用户");
            request.getRequestDispatcher("ServletTwo").forward(request,response);
        } else {
            //请求成功
            System.out.println("亲爱的用户XXX，您好");
            //建立共享资源，因为之后的页面要显示用户的名字
            request.setAttribute("username",user.getUsername());
            request.getRequestDispatcher("ServletThree").forward(request,response);

        }
```

响应代码：ServletThree

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

  response.setContentType("text/html;charset=utf-8");

  Object uername = request.getAttribute("username");

  response.getWriter().write("亲爱的用户"+uername+"欢迎您");

}
```

### 参数传递优化（BeanUtils）

**问题：**

进行参数的共享时，我们是将每个参数对象先保存起来，再进行共享。那么问题来了，我们按照之前的共享的方式，一次只能保存一个数据，假如我有多个数据要传递呢？

**之前的方式**

```java
    //2.获取请求参数  并封装成对象    
	String username = request.getParameter("username");
  	String password = request.getParameter("password");
	User loginUser = new User(1, username, password);
```

**使用BeanUtils工具类**

1. 简化数据封装

   1. 引入BeanUtils下载网站：http://commons.apache.org/proper/commons-beanutils/

   2. 导入jar包

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image026.gif)

**注意：**commons-logging这个jar包一定要导入，作用：

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image028.gif)

简单使用：

```java
//A.1获取参数的map集合
Map<String, String[]> parameterMap = request.getParameterMap();
//A.2创建一个User对象
User loginUser = new User();
//A.3使用BeanUtils封装
try {
    BeanUtils.populate(loginUser,parameterMap);
} catch (IllegalAccessException e) {
    e.printStackTrace();
} catch (InvocationTargetException e) {
    e.printStackTrace();
}
//访问数据库并获取对象
UserDao dao = new UserDao();
User user = dao.login(loginUser);
//判断是否是我们的用户
if (user== null) {
    System.out.println("您不是我们的用户");
    request.getRequestDispatcher("ServletTwo").forward(request,response);
} else {
    //请求成功
    System.out.println("亲爱的用户XXX，您好");
    //建立共享资源，因为之后的页面要显示用户的名字
    request.setAttribute("username",user.getUsername());
    request.getRequestDispatcher("ServletThree").forward(request,response);

}

```

### BeanUtils.工具类

简化数据封装用于封装JavaBean的

1. **JavaBean :标准的Java类**
   1. 要求:
      1. 类必须被public修饰
      2. 必须提供空参的构造器
      3. 成员变量必须使用private修饰
      4. 提供公共setter和getter方法
   2. 功能:封装数据

2. **概念:**

1. 成员变量:
   1. 属性: setter和getter方法截取后的产物
      1.  例如: getUsername() --> Username--> username
      2. 假如我有一个成员变量交name，但是他的set/get方法为getHisName，那么截取后的产物为hisName。hisName为属性，name为成员变量。但是大多数情况下，属性的成员变量的名称是一样的

3. **方法:**

1. setProperty( )。操作的是属性，而不是成员变量

```java
设置对象

1.成员变量gender  setSex/getSex

BeanUtils.setProperty(user,"gender","male");

System.out.println(user);   //  User{id=0, username='null', password='null', gender='null'}

BeanUtils.setProperty(user,"sex","male");

System.out.println(user);   //  User{id=0, username='null', password='null', gender='male'}

 

根据结果我们可以看出，成员变量gender，但他的set/get方法是sex。此时属性和成员变量不一样。

而setProperty( )操作的是属性，所以运行出来的结果不一样
```

2. getProperty( )

 ```java
 //获取对象
  try {
 
    String genders = BeanUtils.getProperty(user, "sex");
 
    System.out.println(genders); male
 
  } catch (NoSuchMethodException e) {
 
    e.printStackTrace();
 
  }
 ```

3. populate(object obj，Map map) :将map集合的键值对信息,封装到对应的JavaBean对象中

 ```java
 //A.1获取参数的map集合
 Map<String, String[]> parameterMap = request.getParameterMap();
 //A.2创建一个User对象
 User loginUser = new User();
 //A.3使用BeanUtils封装
 try {
     BeanUtils.populate(loginUser,parameterMap);
 } catch (IllegalAccessException e) {
     e.printStackTrace();
 } catch (InvocationTargetException e) {
     e.printStackTrace();
 }
 ```

# 2. ServletResponse

## 1. 介绍

### Response体系

![image-20211216212434351](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216212434351.png)

### 设置响应消息

**设置响应行**

格式 HTTP/1.1  200 OK

设置状态码：set

**设置响应头**

 setHeader(String name, String value)

**设置响应体**

使用步骤:

1. 获取输出流

   1. 字符输出流: PrintWriter getWriter()

   2. 字节输出流: Servletoutputstream getoutputStream()

2. 使用输出流，将数据输出到客户端浏览器

## 2. 案例

### 1. 重定向

#### **a.   资源跳转的方式**

![image-20211216212632173](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216212632173.png)

#### **b.  两种方式实现，推荐选择第二种。**

```java
 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("demo111111111111");
        //方式1：设置重定向
        //1.1设置状态码
        response.setStatus(302);
        //1.2设置响应头location
//response.setHeader("location","/Response/servletDemo2");
        //方式2：设置重定向（简单）
      response.sendRedirect("/Response/servletDemo2");
        }

```

#### **c.   重定向和转发的区别**

面试经常考这两个的区别（forword和redirect的区别）

**重定向：**

1. 页面跳转，地址栏发生变化

2. 重定向可以访问其他站点（服务器），比如访问百度

3. 重定向是两次请求，不能使用request域来共享数据

```java
request.setAttribute("msg","helloworld");//设置共享资源
response.sendRedirect("https://www.baidu.com/");//访问百度

Object msg = request.getAttribute("msg");  //获取共享资源   
System.out.println(msg);     //  null    获取不到
```

**转发：**

1. 页面跳转，地址栏不发生改变

2. 转发只能访问当前服务器下的资源

3. 转发是一次请求，可以使用request域来共享资源

#### d.  路径写法

路径分类：

1. **相对路径 ：**当前资源和目录资源之间相对的位置关系。   ./  开头

   ./当前目录 ../上一级目录

2. **绝对路径：**通过绝对路径，可以确定唯一资源。       以  /  开头
   1. 如：http://localhost:8888/Response/servletDemo2    /Response/servletDemo2 ，前面的http可以省略
   2. **判断定义的路径给谁用的，判断请求将来从哪里发出（虚拟目录什么时候使用）**
      1. **客户端浏览器使用，需要添加虚拟目录**（项目所在文件夹的名称）
         1. 如网页上的超链接，点击访问服务器，是客户端浏览器使用，需要添加虚拟目录
         2. <a>，<form>,重定向
      2. **服务器使用，不需要添加虚拟目录**
         1. 转发操作，是浏览器内部访问的
         2. 注意：重定向是服务器将状态码和路径传递给客户端，客户端再通过路径访问服务器，是客户端浏览器使用，需要添加虚拟目录

```java
//重定向：需要虚拟目录
response.sendRedirect("/Response/servletDemo2");

//转发：不需要虚拟目录
request.getRequestDispatcher("/selectDemo2").forward(request,response);
```

#### e. 动态路径获取

问题：我们通过上述代码可以看出，填写的虚拟目录的路径是固定的/Response，那么问题来了，以后假如我写非常多的接口，突然我把虚拟目录的路径改了，那么我就得把所有的虚拟目录的路径改了，这样就太麻烦了。所以我们在实际的编程中，都是通过动态获取虚拟目录的方式

动态获取虚拟目录

```java
动态获取虚拟目录
String contextPath = request.getContextPath();
response.sendRedirect(contextPath+"/servletDemo2");
```

### 2. 服务器输出字符数据到浏览器

步骤:

1. 获取字符输出流

2. 输出数据

```java
//获取字符输出流

PrintWriter writer = response.getWriter();

//输出数据

writer.write("helloworld");

//输出html格式数据

writer.write("<h1>helloworld<h1>");

//输出中文数据

writer.write("你好，我的世界");//中文乱码
```

3. 中文乱码问题

![image-20211216213515298](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216213515298.png)

1. 浏览器默认的字符编码根据操作系统的语言环境有关，win10的为GBK（中文简体）或gb312
2. 如果服务器的字符是new出来的，也是GBK，如果是获取的，字符编码是Tomcat定义的ISO-8859-1
3. 解决：获取流对象之前，设置编码格式  response.setContentType（“text/html;charset=utf-8”）

```java
方式1设置编码格式

 //1.1获取流对象之前，把流的默认编码“ISO-8859-1”设置为：utf-8
 response.setCharacterEncoding("utf-8");
 //1.2告诉浏览器，服务器发送的数据的编码，建议浏览器使用此编码
 response.setHeader("content-type","text/html;charset=utf-8");

 

 

方式2 设置编码格式（推荐）

 response.setContentType("text/html;charset=utf-8");
```

### 3. 服务器输出字节数据

步骤:

1. 获取字节输出流

2. 输出数据

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //方式2 设置编码格式
    response.setContentType("text/html;charset=utf-8");
    ServletOutputStream outputStream = response.getOutputStream();
    outputStream.write("hello".getBytes());
}
```

### 4. 验证码响应

Servlet代码

```java
@WebServlet("/checkCodeServlet")
public class checkCodeServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
     //1.创建一个对象，在内存中存图片（验证码图片对象）
        int width =100;
        int height= 50;
        BufferedImage image  =new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);//宽，高，格式
     //2.美化图片
        //2.1化背景颜色
        Graphics graphics = image.getGraphics();//画笔对象
        graphics.setColor(Color.pink);//设置画笔颜色
        graphics.fillRect(0,0,width,height);//填充一个蓝色的矩形  填充的位置和大小
        //2.2画边框
        graphics.setColor(Color.BLUE);//设置颜色
        graphics.drawRect(0,0,width-1,height-1);//画边框
        //2.3写验证码
         String str ="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";  //验证码包含的所有字符数字
        Random random = new Random();//画验证码验证符
        for (int i = 1; i < 5; i++) {
            int s = random.nextInt(str.length());//随机获取字符串的角标，长度在字符串长度的范围内
            char c = str.charAt(s);//获取随机的字符
            graphics.drawString(c+"",i*20,25);//字符串的内容和位置
        }
        //2.4画干扰线
        graphics.setColor(Color.black);
        for (int i = 0; i < 10; i++) {
            int x1 = random.nextInt(100);
            int x2 = random.nextInt(100);
            int y1 = random.nextInt(50);
            int y2 = random.nextInt(50);
            graphics.drawLine(x1,y1,x2,y2);
        }

        //3.将图片输入到页面展示
        ImageIO.write(image,"jpg",response.getOutputStream());//输出对象，后缀名，输出流输出
            }
```

HTML代码

```java
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        window.onload = function () {
            //点击图片切换
            //获取图片
            let elementById = document.getElementById("img");
          //更改图片，其实就是更改图片的路径，因为我们的图片是随机生成的，所以只需要图片重新加载一次即可。
            elementById.onclick=function () {
                // elementById.src="/Response/checkCodeServlet";
                //这时你会发现点击图片没有变化，这是因为之前浏览器已经访问过这个路径了，此时路径的内容已经存储在了浏览器的内存中，所以访问的还是之前的图片
               // 解决措施：假意传参.   如果参数传入相同的值，那么就会造成只能切换一次。跟上面一个道理。所以要传一个随机的值
               //  elementById.src="/Response/checkCodeServlet?1";

                //因为随机数有时候也可能相同，所以遇到这种情况，我们可以通过把时间戳当做参数来解决。
               let date = new Date().getTime();
                elementById.src="/Response/checkCodeServlet?"+date;
                alert(data)
            }
            //点击文字切换
            let elementById1 = document.getElementById("change");
            elementById1.onclick=function () {
               let date = new Date().getTime();
                elementById.src="/Response/checkCodeServlet?"+date;
            }
        }
    </script>
</head>
<body>
<!--图片的点击切换-->
<img id="img" src="/Response/checkCodeServlet">
<a id="change">看不清，换一张</a>
</body>
</html>

```

# 3. ServletContext

## 1. 介绍

**概念:**

代表整个web应用，可以和程序的容器(服务器)来通信

## 2. **获取方式**

1.通过request对象获取

request . getServletContext();

2.通过HttpServlet获取

this .getServletContext();

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    javax.servlet.ServletContext servletContext = request.getServletContext();
    javax.servlet.ServletContext servletContext1 = this.getServletContext();
    System.out.println(servletContext==servletContext1);  //true
    System.out.println(servletContext);                   //org.apache.catalina.core.ApplicationContextFacade@628e8f44

}

```

## 3. 功能

### 1.   获取MIME类型

1. MIME类型:在互联网通信过程中定义的一种文件数据类型

   格式:大类型/小类型  如：text/html  image/jpeg ;

2. 获取: string getMimeType(String file)

```java
//获取文件类型

javax.servlet.ServletContext servletContext = request.getServletContext();

String file = "a.jpg";

String mimeType = servletContext.getMimeType(file);

System.out.println(mimeType);//image/jpeg
```

### 2.   域对象:共享数据

a.   setAttribute(String name , object value)

b.   getAttribute(String name)

c.   removeAttribute(String name )

**ServletContext3设置共享数据**

```java
@WebServlet("/ServletContext3")
public class ServletContext3 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        javax.servlet.ServletContext servletContext1 = request.getServletContext();
      servletContext1.setAttribute("meg","helloworld");//helloworld
    }
```

**ServletContext2获得共享数据**

```java
@WebServlet("/ServletContext2")
public class ServletContext2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        javax.servlet.ServletContext servletContext1 = request.getServletContext();
        Object meg = servletContext1.getAttribute("meg");
        System.out.println(meg);//helloworld
    }
```

**注意：**

1. ServletContext对象范围：所有用户请求的数据。。 张三请求的数据，张四也可以看到

2. 该对象在服务器中贮存的时间特别长，从开始到销毁，所以用的时候需要非常谨慎。  

### 3.   获取文件的真实路径

1. 获取文件（服务器）的真实路径  String  getRealPath(**“”**);

2. 文件在不同路径下的获取方法

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    javax.servlet.ServletContext servletContext1 = request.getServletContext();
    //查看斜杠表示的目录
    String realPath1 = servletContext1.getRealPath("/");  
    System.out.println(realPath1);
    //E:\Java文件\Response\out\artifacts\Response_war_exploded\
    //获取ConfigurationA
    String realPathA = servletContext1.getRealPath("/WEB-INF/classes/ConfigurationA"); src目录下
    System.out.println(realPathA);
    // E:\Java文件\Response\out\artifacts\Response_war_exploded\WEB-INF\classes\ConfigurationA
    //获取ConfigurationB
    String realPathB = servletContext1.getRealPath("/WEB-INF/ConfigurationB");   WEB-INF目录下
    System.out.println(realPathB);
    //    E:\Java文件\Response\out\artifacts\Response_war_exploded\WEB-INF\ConfigurationB
    //获取ConfigurationC
    String realPathC= servletContext1.getRealPath("/ConfigurationC");        Web目录下
    System.out.println(realPathC);
    //   E:\Java文件\Response\out\artifacts\Response_war_exploded\ConfigurationC
}
```



![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image002.gif)![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image004.gif)

## 4. 案例

### 文件下载

在浏览器中超链接的图片可以直接查看，但是视频需要下载获取.

#### 需求:

1. 页面显示超链接

2. 点击超链接后弹出下载提示框

3. 完成图片文件下载

#### 分析:

1. 超链接指向的资源如果能够被浏览器解析,则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求（图片可以直接被浏览器解析，但是视频是不可以的）

2. 任何资源都必须弹出下载提示框

3. 使用响应头设置资源的打开方式: content-disposition: attachment ;filename=xxx

#### 步骤:

1. 定义页面，编辑超链接href属性,指向Servlet，传递资源名称filename

2. 定义Servlet

   1. 获取文件名称

   2. 使用字节输入流加载文件进内存

   3. 指定response的响应头: content- disposition: attachment; filename=xxx

      ![image-20211216215325140](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215325140.png)

   4. 将数据写出到response输出流

#### 代码展示

链接代码：

```html
<!--在浏览器中超链接的图片可以直接查看，但是视频需要下载获取-->
<a href="/Response/img/台球.jpg">图片下载</a>
<a href="/img/movie.avi">视频下载</a>
<br>
<a href="/Response/downLoad1?filename=ball.jpg">图片下载</a>
<a href="/Response/downLoad1?filename=movie.avi">视频下载</a>

```

接口:

接口中，在获取文件名之前，先解析文件名。

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //1.获取请求参数，文件名称
    String fileName =request.getParameter("filename");
    System.out.println(fileName); //photo
    
    //2.使用字节流，加载文件进内存
    //2.1找到文件所在的服务器路径
    ServletContext servletContext = request.getServletContext();
    String realPath = servletContext.getRealPath("/img/" + fileName);//图片的真是路径
    //2.2使用字节流关联
    FileInputStream fis = new FileInputStream(realPath);
    //自己理解为，通过此步骤，可以获取从浏览器把文件保存到本地的权限


    //3.设置response响应头
    //3.1设置响应头的数据类型：content-type  //因为我们也不知道文件的类型，所以需要设置。
    String mimeType = servletContext.getMimeType(fileName);
    response.setHeader("content-type",mimeType);
    //3.1.1解决中文文件名问题
    //获取user-agent请求头
    String agent = request.getHeader("user-agent");
    String fileName1 = DownLoadeUtilis.getFileName(agent, fileName);

    //3.2设置响应头的打开方式
    response.setHeader("content-disposition","attachment;filename="+fileName);//filename设置的为下载提示框的名字
    
    //4.将输入流的数据写出到输出流中
    ServletOutputStream sos = response.getOutputStream();
    byte[] buff = new byte[1024*8];
    int len = 0;
    while ((len=fis.read(buff))!=-1){
        sos.write(buff,0,len);
    }
    fis.close();//输入流关闭
}
```

文件夹：

![image-20211216215504979](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215504979.png)

#### 中文文件名称无法显示问题

```html
<a href="/Response/downLoad1?filename=球员.jpg">中文名称图片下载</a>
```

![image-20211216215541385](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215541385.png)

**解决思路**

1. 获取客户端使用的浏览器版本信息

2. 根据不同的浏览器版本信息，设置filename的编码 式不同

![image-20211216215627980](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215627980.png)

 

```java
在获取文件名之前，先解析文件名

//3.1.1解决中文文件名问题

//获取user-agent请求头

String agent = request.getHeader("user-agent");

String fileName1 = DownLoadeUtilis.getFileName(agent, fileName);

//3.2设置响应头的打开方式

response.setHeader("content-disposition","attachment;filename="+fileName1);//filename设置的为下载提示框的名字
```

封装的代码

```java
public class DownLoadeUtilis {
    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException {
        if (agent.contains("MSIE")) {
// IE浏览器
            filename = URLEncoder.encode(filename, "utf-8");
            filename = filename.replace("+", "");
        } else if (agent.contains("Firefox")) {
//火狐浏览器
            BASE64Encoder base64Encoder = new BASE64Encoder();
            filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?=";
        } else {
// 其它浏览器
            filename = URLEncoder.encode(filename, "utf-8");

        }
        return filename;

    }
}
```

# 4. 会话技术

https://www.cnblogs.com/myseries/p/11588267.html

 https://blog.csdn.net/dlovejava/article/details/80863855

 

 

 

 

 



 

 
