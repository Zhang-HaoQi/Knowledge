# Redis进阶

## 基础

### 1. Redis是什么，优缺点

Redis是一个存储KV类型数据的内存数据库，整个数据库加载在内存中操作，定期通过异步操作将数据flush到磁盘上保存。

Redis是纯内存操作，性能好，每秒可以处理超过10万次读写操作，目前性能最快的kv数据库。

优点：

1. 读写性能极高， Redis能读的速度是110000次/s，写的速度是81000次/s。

2. 支持数据持久化，支持AOF和RDB两种持久化方式。

3. 支持事务， Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。

4. 数据结构丰富，除了支持string类型的value外，还支持hash、set、zset、list等数据结构。

5. 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

6. 支持发布订阅， 通知， key 过期等特性。

缺点：

1. 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。

2. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。

### 2. Redis为什么快

1. 基于内存存储：数据操作都基于内存，没有IO开销，数据都已KV形式保存，查找和操作数据的复杂度是O（1）

2. 单线程实现：

   Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。

   Redis 6 引入多线程IO，但多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。

3. 非阻塞IO

   Redis使用多路复用IO技术，将epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

4. 优化的数据结构

   Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。

5. 底层模型不同

   Redis实现了自己的虚拟内存机制（VM），因为一般的系统调用系统函数的话，会浪费一定的时间与移动和请求。

   > Redis的VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。
   >
   > 通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。
   >
   > 
   >
   > Redis提高数据库容量的办法有两种：一种是可以将数据分割到多个RedisServer上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。需要特别注意的是**Redis**并没有使用**OS**提供的**Swap**，而是自己实现。

### 3. Redis相比Memcached优势

1. 数据类型：redis提供了字符串，list，set，map，zset等数据结构，memcached所有值都是简单字符串
2. 持久化：redis支持AOF和RDB持久化存储，memcache不支持
3. 集群模式：Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
4. 性能：redis速度比memcached快
5. 网络IO：redis单线程实现多路复用的IO模型，memcached使用多线程实现非阻塞IO
6. 支持服务端操作：redis可以在服务端直接进行操作，而memcached必须先通过客户端获取，再Set回去。

### 4.为什么使用Redis做缓存

 数据库的并发能力和读写速度是有限的，使用Redis可以大大降低数据库压力，并且操作Redis直接操作缓存中的数据，比操作磁盘中的数据快很多。

### 5. 为什么用Redis而不用本地做缓存。

Java提供的本地缓存轻量，快速，但是随着JVM的销毁而结束，在多实例下，缓存会产生不一致性。

redis是分布式缓存，多实例可以共用一份缓存，缓存具有一致性。

1. Redis是分布式缓存，多个实例可以共享一份缓存数据，本地缓存不能共享。
2. Redis提供了持久化，本地缓存程序重启即消失。
3. Redis可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；
4. Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；
5. Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；
6. Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；

### 6. Redis使用场景

1. 缓存
2. 排行榜，使用zset数据类型
3. 计数器，使用incr命令
4. 分布式会话，存储token或session信息
5. 分布式锁，应用高并发下可能产生不一致的问题。如：全局ID，减库存，秒杀等。
6. 朋友圈点赞，关注等
7. 消息系统 ，使用list或者stream可以实现队列功能

### 7. Redis数据结构

**基本数据类型**:string,hash,set,list,sortset

**其他数据结构：**

1、Bitmap：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1。签到，统计，布隆过滤器。

2、Hyperloglog。HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。场景：统计网页的UV（不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。

要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。

3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。

## 持久化

持久化原理查看：[mystudy/Redis/深度历险.md · Zhang-HaoQi/Knowledge - 码云 - 开源中国 (gitee.com)](https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/Redis/深度历险.md#2-持久化)

### 1. Redis持久化

将Redis内存数据写入磁盘，防止Redis意外宕机数据丢失和做Redis集群，数据备份。

**RDB**

指定间隔将内存快照写入磁盘，恢复时直接将快照文件数据读入内存。

优点：数据大规模恢复快

缺点：隔断时间备份，备份期间如果Redis宕机，会丢失最后一次快照后的所有修改。

**AOF**

追加写命令的形式备份数据，Redis重启时会读取该文件重新构建数据。

AOF使用追加写的方式，文件会越来越大，AOF有重写机制，当AOF文件的大小超过所设定的阈值时， Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.。

优点：支持3种同步时机，每次发生数据修改持久化；每秒同步；从不同步。可以根据程序要求选择合适的同步时机

缺点：aof文件大小远大于rdb，aof的运行效率不如rdb

**混合持久化**

两次RDB之间，使用AOF，减少RDB次数和AOF文件大小。

优点：即使用了RDB快速恢复的特性，又发挥AOF记录数据不丢失。

缺点：兼容性差，redis4.0之后版本才支持。日志可读性较差。

### 2. 如何选择合适的持久化方式

1. 数据不敏感，容易重新补回：关闭持久化
2. 数据比较重要，但可以容忍一段时间的数据丢失，如缓存，可以只是用RDB
3. 如果做内存数据库，要使用持久化，RDB和AOF都开启，RDB做数据备份，AOF保证数据不丢失。

## 问题：

1. redis的单线程和多线程
