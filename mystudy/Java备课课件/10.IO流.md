# IO流

## 相关资源

[java IO流详解 - 时光孤岛 - 博客园 (cnblogs.com)](https://www.cnblogs.com/QQ846300233/p/6046388.html)

## 1. File

File类是java.io包下代表与平台无关的文件和目录,如果希望在程序中操作文件和目录，都可以通过File类来完成。

值得指出的是，不管是文件还是目录都是使用File来操作的，File能新建、删除、重命名文件和目录，**File不能访问文件内容本身**。如果需要访问文件内容本身，则需要使用输入/输出流。

**注意：**

Windows 的路径分隔符使用反斜线（\)，而 Java程序中的反斜线表示转义字符，所以如果需要在 Windows的路径下包括反斜线，则应该使用两条反斜线，如F:\ \ abc \ \ test.txt,或者直接使用斜线(/ )也可以，Java程序支持将斜线当成平台无关的路径分隔符。

### 访问文件和目录

**File类可以使用文件路径字符串来创建File实例，该文件路径字符串既可以是绝对路径，也可以是相对路径。**

在默认情况下,系统总是依据用户的工作路径来解释相对路径，通常也就是运行Java虚拟机时所在的路径。

一旦创建了File对象后，就可以调用File对象的方法来访问，File类提供了很多方法来操作文件和目录，下面列出一些比较常用的方法。
**1．访问文件名相关的方法**

1. String getName():返回此File对象所表示的文件名或路径名(如果是路径，则返回最后一级子路径名)。
2. String getPath():返回此File对象所对应的路径名。
3. **File getAbsoluteFile():返回此File对象的绝对路径。**
4. String getAbsolutePath():返回此 File对象所对应的绝对路径名。
5. **String getParent():返回此File对象所对应目录(最后一级子目录）的父目录名。**

5. boolean renameTo(File newName):重命名此File对象所对应的文件或目录，如果重命名成功，则返回true;否则返回false。

**2．文件检测相关的方法**

1. boolean exists():判断File对象所对应的文件或目录是否存在。
2. boolean canWrite():判断File对象所对应的文件和目录是否可写。
3. boolean canRead(:判断File对象所对应的文件和目录是否可读。
4. **boolean isFile():判断File对象所对应的是否是文件，而不是目录。**
5. **boolean isDirectory():判断File对象所对应的是否是目录，而不是文件。**
6. boolean isAbsolute():**判断File对象所对应的文件或目录是否是绝对路径。**该方法消除了不同平台的差异，可以直接判断File对象是否为绝对路径。在 UNIX/Linux/BSD等系统上，如果路径名开头是一条斜线（/)，则表明该File对象对应一个绝对路径;在Windows等系统上，如果路径开头是盘符，则说明它是一个绝对路径。

**获取常规文件信息**

1. long lastModified():返回文件的最后修改时间。
2. long length():返回文件内容的长度。

**文件操作相关的方法**

1. **boolean createNewFile():当此File对象所对应的文件不存在时，该方法将新建一个该File对象所指定的新文件，如果创建成功则返回 true;否则返回false。**
2. **boolean delete():删除File对象所对应的文件或路径。**
3. **static File createTempFile(String prefix, String suffix):**在默认的临时文件目录中创建一个临时的空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。**这是一个静态方法，可以直接通过File类来调用。prefix参数必须至少是3字节长。建议前缀使用一个短的、有意义的字符串，比如"hjb”或"mail"。suffix 参数可以为 null，在这种情况下，将使用默认的后缀“.tmp”。
4. **static File createTempFile(String prefix, String suffix, File directory):在directory 所指定的目录中创建一个临时的空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File类来调用。**(虚拟机退出后，删除文件)
5. **void deleteOnExit():注册一个删除钩子，指定当Java虚拟机退出时，删除 File对象所对应的文件和目录。**

**目录操作相关的方法**

1. **boolean mkdir():试图创建一个File对象所对应的目录，**如果创建成功，则返回true;否则返回false。调用该方法时File对象必须对应一个路径，而不是一个文件。
2. **String[] list():列出 File对象的所有子文件名和路径名，**返回String 数组。
3. File[ ] listFiles():列出 File对象的所有子文件和路径，返回File数组。
4. static File[ ] listRoots():列出系统所有的根路径。这是一个静态方法，可以直接通过File类来调用。

#### **相对路径和绝对路径**

```java
public class FileTest
{
	public static void main(String[] args)
		throws IOException
	{
		// 以当前路径来创建一个File对象
		File file = new File(".");
		// 直接获取文件名，输出一点
		System.out.println(file.getName());
		// 获取相对路径的父路径可能出错，下面代码输出null
		System.out.println(file.getParent());
		// 获取绝对路径
		System.out.println(file.getAbsoluteFile());
		// 获取上一级路径
	System.out.println(file.getAbsoluteFile().getParent());
	}
}
```

![image-20211201202957077](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201202957077.png)

****

#### **创建文件**

**注意：**

1. 同一个File对象，不能即创建文件夹，又创建文件

```java
	    // 以当前路径来创建一个File对象
        File file = new File(".");
        System.out.println(file.createNewFile());//false

		// 在当前路径下创建一个临时文件
        File tmpFile = File.createTempFile("tempFile", ".txt", file);  //file 表示在这个文件夹下
        // 指定当JVM退出时删除该文件
        tmpFile.deleteOnExit();

		//创建一个文件
        File newFile = new File(System.currentTimeMillis() + ""); //文件名称：当前时间戳
        newFile.createNewFile();    //// 以指定newFile对象来创建一个文件
        System.out.println("newFile对象是否存在：" + newFile.exists());

		//创建文件夹
        File newFile = new File(System.currentTimeMillis() + "");
		newFile.createNewFile();  
        System.out.println("newFile对象是否存在：" + newFile.exists()); true
        System.out.println(newFile.mkdir()); false   // 因为newFile已创建文件。同一个文件对象不能即创建文件，又创建文件夹
```

newFile创建的文件

![image-20211201202932233](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201202932233.png)

newFile创建的文件夹

![image-20211201204055315](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201204055510.png)

#### 查看文件列表

```java
 		File file = new File(".");
        String[] fileList = file.list();
        System.out.println("====当前路径下所有文件和路径如下====");
        for (String fileName : fileList)
        {
            System.out.println(fileName);
        }
```

![image-20211201204513142](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201204513142.png)

#### 获取所有磁盘的根路径

```java
 		File[] roots = File.listRoots();
        System.out.println("====系统所有根路径如下====");
        for (File root : roots)
        {
            System.out.println(root);
        }
```

![image-20211201204604477](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201204604477.png)

#### 文件过滤器

在File类的 list()方法中可以接收一个FilenameFilter参数,通过该参数**可以只列出符合条件的文件。**
FilenameFilter接口里包含了一个accept(File dir, String name)方法，该方法将依次对指定File 的所有子目录或者文件进行迭代，如果该方法返回true，则 list()方法会列出该子目录或者文件。

```java
@FunctionalInterface
public interface FilenameFilter {
    /**
     * Tests if a specified file should be included in a file list.
     *
     * @param   dir    the directory in which the file was found.
     * @param   name   the name of the file.
     * @return  <code>true</code> if and only if the name should be
     * included in the file list; <code>false</code> otherwise.
     */
    boolean accept(File dir, String name);
}
```

**实战：**

```java
        // 以当前路径来创建一个File对象
        File file = new File(".");
        //过滤掉后缀名是Java的文件和所有文件夹
        String[] list = file.list((dir, name) -> name.endsWith(".java") || new File(name).isDirectory());
        Arrays.stream(list).forEach(System.out::println);
```

![image-20211201205558842](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201205558842.png)

### 小结

1.  Windows 的路径分隔符使用反斜线( \ )，而Java程序中的反斜线表示转义字符，所以如果需要在Windows的路径下包括反斜线，则应该使用两条反斜线，如 F:\ \abc\ \test.txt,或者直接使用斜线(/)也可以，Java程序支持将斜线当成平台无关的路径分隔符.
2. 同一个File对象，不能即创建文件夹，又创建文件
3. 可以使用文件过滤器，来过滤不需要的文件

## 2. IO流

Java中把不同的**输入/输出源**（键盘、文件、网络连接等）抽象表述为“流”( stream)，**通过流的方式允许Java 程序使用相同的方式来访问不同的输入/输出源**。**stream是从起源（source）到接收（sink)的有序数据。**
Java把所有传统的流类型（类或抽象类）都放在java.io包中，用以实现输入/输出功能。

![image-20211201235527861](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201235527861.png)

### 流的分类

1. 输入输出流
   1. 输入流:只能从中读取数据，而不能向其写入数据。   从硬盘到内存
      1. InputStream和Reader作为基类
   2. 输出流:只能向其写入数据，而不能从中读取数据。  从内存到硬盘
      1. OutputStream和Writer作为基类
2. 字符流和字节流
   1. 字符流：
      1. Reader和Writer作为基类
   2. 字节流：
      1. InputStream和OutputStream作为基类
   3. 字节流和字符流的用法几乎完全一样,区别：字节流和字符流所操作的数据单元不同，字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。
3. 节点流和处理流
   1. 按照流的角色可以分为以上两种
   2. **节点流：**
      1. 可以从/向一个特定的IO设备（如磁盘、网络）读/写数据的流，称为节点流，节点流也被称为低级流
         1. ![image-20211201210932548](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201210932548.png)
         2. 程序直接连接数据源，和实际的输入输出节点链接。
   3. **处理流：**
      1. **使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。**
         1. ![image-20211201211058851](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201211058851.png)
         2. 使用处理流的一个明显好处是，只要使用相同的处理流，**程序就可以采用完全相同的输入/输出代码来访问不同的数据源**，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应地发生变化。
      2. Java使用处理流来包装节点流是一种典型的装饰器设计模式，**通过使用处理流来包装不同的节点流**，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。因此处理流也被称为包装流。

### 流的概念模型

**Java把所有设备里的有序数据抽象成流模型，简化了输入/输出处理。**

**Java 的IO流共涉及40 多个类，这些类都是从4个抽象基类派生的。**

**InputStream/Reader:所有输入流的基类，前者是字节输入流，后者是字符输入流。**

**OutputStream/Writer:所有输出流的基类，前者是字节输出流，后者是字符输出流。**

InputStream和 Reader，把输入设备抽象成一个“水管”，这个水管里的每个“水滴”依次排列

**输入流：**

![image-20211201211607940](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201211607940.png)

字节流和字符流的处理方式其实非常相似，只是它们处理的输入/输出单位不同。

输入流使用隐式的记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或 Reader里取出一个或多个“水滴”后，记录指针自动向后移动，InputStream和 Reader里都提供一些方法来控制记录指针的移动。

**输出流**

![image-20211201211723399](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201211723399.png)

OutputStream和 Writer同样把输出设备抽象成一个“水管”，这个水管里没有任何水滴
当执行输出时，程序相当于依次把“水滴”放入到输出流的水管中，输出流同样采用隐式的记录指针来标识当前水滴即将放入的位置，每当程序向OutputStream或Writer里输出一个或多个水滴后,记录指针自动向后移动。

Java的**处理流**模型则体现了Java输入/输出流设计的灵活性。处理流的功能主要体现在以下两个方面

1. 性能的提高:主要以增加缓冲的方式来提高输入/输出的效率。
2. 操作的便捷:处理流可能提供了一系列便捷的方法来**一次输入/输出大批量的内容，而不是输入/输出一个或多个“水滴”。**

**处理流**

![image-20211201212011061](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201212011061.png)

通过使用处理流，Java程序无须理会输入/输出节点是磁盘、网络还是其他的输入/输出设备，程序只要将这些节点流包装成处理流，就可以使用相同的输入/输出代码来读写不同的输入/输出设备的数据。

## 3. 字节流和字符流

字节流和字符流的用法几乎完全一样,区别：字节流和字符流所操作的数据单元不同，字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。

### Input和Reader

**InputStream的方法。**

1. int read():从输入流中读取单个字节(相当于从水管中取出一滴水)，返回所读取的字节数据（字节数据可直接转换为int类型)。
2. int read(byte[ ] b):从输入流中最多读取 b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数。
3. int read(byte[] b, int off, int len):从输入流中最多读取len个字节的数据，并将其存储在数组 b中，放入数组b中时，并不是从数组起点开始，而是从 off位置开始，返回实际读取的字节数。在 Reader里包含如下三个方法。

**Reader的方法。**

1. int read():从输入流中读取单个字符(相当于从水管中取出一滴水)，返回所读取的字符数据（字符数据可直接转换为int类型)。
2. int read(char[]cbuf):从输入流中最多读取cbuf.length个字符的数据,并将其存储在字符数组cbuf中，返回实际读取的字符数。
3. int read(char[] cbuf, int off, int len):从输入流中最多读取len个字符的数据，并将其存储在字符数组 cbuf中，放入数组cbuf中时，并不是从数组起点开始，而是从 off位置开始，返回实际读取的字符数。

**移动指针的方法**

1. void mark(int readAheadLimit):在记录指针当前位置记录一个标记(mark)。
2. boolean markSupported():判断此输入流是否支持mark()操作，即是否支持记录标记。void 
3. reset():将此流的记录指针重新定位到上一次记录标记(mark)的位置。
4. long skip(long n):记录指针向前移动n个字节/字符。

当read方法返回-1时，到了输入流的结束点。

![image-20211201212634383](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211201212634383.png)

InputStream和 Reader都是抽象类，本身不能创建实例，它们分别有一个用于读取文件的输入流: FileInputStream和 FileReader，它们都是节点流——会直接和指定文件关联。

**Input读取当前文件**

```java
public class FileInputStreamTest
{
    public static void main(String[] args) throws IOException
    {
        // 创建字节输入流
        InputStream fis = new FileInputStream(
                "src/lession_IO/FileInputStreamTest.java");

        // 创建一个长度为1024的“竹筒”
        byte[] bbuf = new byte[1024];
        // 用于保存实际读取的字节数
        int hasRead = 0;
        // 使用循环来重复“取水”过程
        while ((hasRead = fis.read(bbuf)) > 0 )
        {
            // 取出“竹筒”中水滴（字节），将字节数组转换成字符串输入！
            System.out.print(new String(bbuf , 0 , hasRead ));
        }
        // 关闭文件输入流，放在finally块里更安全
        fis.close();
    }
}

```

注意：

1. idea和eclipse的当前路径指的是当先项目的工程目录，并不是当前文件所在的目录。
2. 如果使用黑窗口运行，路径直接是“FileInputStreamTest.java”
3. 使用了流之后要fis.close()来关闭该文件输入流，与JDBC编程一样，程序里打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。Java 7改写了所有的IO资源类，它们都实现了AutoCloseable接口，都可通过自动关闭资源的try语句来关闭这些IO流。

**Reader读取当前文件**

```java
public class FileReaderTest {
    public static void main(String[] args) {
        try (
                // 创建字符输入流
                Reader fr = new FileReader("src/lession_IO/FileReaderTest.java")) {
            // 创建一个长度为32的“竹筒”
            char[] cbuf = new char[32];
            // 用于保存实际读取的字符数
            int hasRead = 0;
            // 使用循环来重复“取水”过程
            while ((hasRead = fr.read(cbuf)) > 0) {
                // 取出“竹筒”中水滴（字符），将字符数组转换成字符串输入！
                System.out.print(new String(cbuf, 0, hasRead));
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
}

```

### Output和Writer

**Output的方法**

1. void write(int c):将指定的字节/字符输出到输出流中，其中c既可以代表字节，也可以代表字
   符。
2. void write(byte[]/char[] buf):将字节数组/字符数组中的数据输出到指定输出流中。
3. void write(byte[]/char[] buf, int off, int len):将字节数组/字符数组中从off位置开始，长度为len
   的字节/字符输出到输出流中。

**因为字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组，即以String 对象作为参数。Writer里还包含如下两个方法。**

**Writer的方法**

1. void write(int c):将指定的字节/字符输出到输出流中，其中c既可以代表字节，也可以代表字
   符。
2. void write(byte[]/char[] buf):将字节数组/字符数组中的数据输出到指定输出流中。
3. void write(byte[]/char[] buf, int off, int len):将字节数组/字符数组中从off位置开始，长度为len
   的字节/字符输出到输出流中。

4. void write(String str):将str字符串里包含的字符输出到指定输出流中。
5. void write(String str, int off, int len):将str字符串里从 off位置开始，长度为len的字符输出到指定输出流中。

注意：写的时候可以以字符串往流中写，但是读的时候不能以字符串的形式读。

**文件复制**

使用InputStream读，读之后使用OutputStream写

```java
public class FileOutputStreamTest
{
    public static void main(String[] args)
    {
        try(
                // 创建字节输入流
                FileInputStream fis = new FileInputStream(
                        "src/lession_IO/FileOutputStreamTest.java");
                // 创建字节输出流
                FileOutputStream fos = new FileOutputStream("src/FileOutputStreamTest.txt"))
        {
            byte[] bbuf = new byte[32];
            int hasRead = 0;
            // 循环从输入流中取出数据
            while ((hasRead = fis.read(bbuf)) > 0 )
            {
                // 每读取一次，即写入文件输出流，读了多少，就写多少。
                fos.write(bbuf , 0 , hasRead);
            }
        }
        catch (IOException ioe)
        {
            ioe.printStackTrace();
        }
    }
}

```

![image-20211201215622978](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201215622978.png)

**使用Writer输出字符串**

```java
public class FileWriterTest
{
	public static void main(String[] args)
	{
		try(
			FileWriter fw = new FileWriter("src/锦瑟.txt"))
		{
			fw.write("锦瑟 - 李商隐\r\n");
			fw.write("锦瑟无端五十弦，一弦一柱思华年。\r\n");
			fw.write("庄生晓梦迷蝴蝶，望帝春心托杜鹃。\r\n");
			fw.write("沧海月明珠有泪，蓝田日暖玉生烟。\r\n");
			fw.write("此情可待成追忆，只是当时已惘然。\r\n");
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}
```

![image-20211201215920977](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201215920977.png)

注意：

1. 字符串内容的最后是\rln，这是Windows平台的换行符，通过这种方式就可以让输出内容换行;如果是UNIX/Linux/BSD等平台，则使用n就作为换行符。

## 输入输出流体系

### 处理流

使用字节流和字符流时，处理文件特别繁琐，可以使用处理流进行简化。

处理流可以隐藏底层设备上节点流的差异，并对外提供更加方便的输入/输出方法，让程序员只需关心高级流的操作。

使用处理流时的典型思路是，**使用处理流来包装节点流**，程序通过处理流来执行输入/输出功能，让节点流与底层的IO设备、文件交互。

实际识别处理流非常简单，只要**流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流**;**而所有节点流都是直接以物理IO节点作为构造器参数的。**

**优点：**

1. 处理流进行输入/输出更简单
2. 处理流执行效率更高

**使用处理流来包装OutStream**

```java
public class PrintStreamTest {
    public static void main(String[] args) {
        try (
                FileOutputStream fos = new FileOutputStream("src/lession_IO/锦瑟.txt");
                PrintStream ps = new PrintStream(fos)) {
            // 使用PrintStream执行输出
            ps.println("普通字符串");
            // 直接使用PrintStream输出对象
            ps.println(new PrintStreamTest());
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
}
```

注意：

1. PrintStream功能强大，需要输出文本内容时，都应该包装成PrintStream输出。
2. 在try（）中定义输入输出对象，程序结束后会自动关闭。
3. PrintStream属于FileOutputStream的上层流，我们关闭只关闭PrintStream即可，系统会自动关闭被他处理的流，所以FileOutputStream会自动关闭。

### 输入输出体系

![image-20211201221847276](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201221847276.png)

字节流的功能比字符流的功能强大，因为计算机里所有的数据都是二进制的，而字节流可以处理所有的二进制文件.

如果使用字节流来处理文本文件，则需要使用合适的方式把这些字节转换成字符，这就增加了编程的复杂度。

规则: 

1. 进行输入/输出的内容是文本内容，则应该考虑使用字符流。
2. 如果进行输入/输出的内容是二进制内容，则应该考虑使用字节流。

注意：

1. 计算机的文件常被分为文本文件和二进制文件两大类———所有能用记事本打开并看到其中字符内容的文件称为文本文件，反之则称为二进制文件。
2. 但实质是，计算机里的所有文件都是二进制文件，**文本文件只是二进制文件的一种特例**，当二进制文件里的内容恰好能被正常解析成字符时，则该二进制文件就变成了文本文件。
3. 正常的文本文件，如果打开该文件时强制使用了“错误”的字符集，例如使用EditPlus 打开刚刚生成的poem.txt文件时指定使用UTF-8字符集,将看到打开的poem.txt文件内容变成了乱码。如果希望看到正常的文本文件内容，则必须在打开文件时与保存文件时使用相同的字符集（ Windows 下简体中文默认使用GBK字符集，而Linux 下简体中文默认使用UTF-8字符集)。

以数组为物理节点的节点流，字节流以字节数组为节点，字符流以字符数组为节点;这种以数组为物理节点的节点流除了在创建节点流对象时需要传入一个字节数组或者字符数组之外，用法上与文件节点流完全相似。

字符流还可以使用字符串作为物理节点，用于实现从字符串读取内容，或将内容写入字符串（用StringBuffer充当字符串）的功能。下面程序示范了使用字符串作为物理节点的字符输入/输出流的用法。

```java
public class StringNodeTest
{
	public static void main(String[] args)
	{
		String src = "从明天起，做一个幸福的人\n"
			+ "喂马，劈柴，周游世界\n"
			+ "从明天起，关心粮食和蔬菜\n"
			+ "我有一所房子，面朝大海，春暖花开\n"
			+ "从明天起，和每一个亲人通信\n"
			+ "告诉他们我的幸福\n";
		char[] buffer = new char[32];
		int hasRead = 0;
		try(
			StringReader sr = new StringReader(src))
		{
			// 采用循环读取的访问读取字符串
			while((hasRead = sr.read(buffer)) > 0)
			{
				System.out.print(new String(buffer ,0 , hasRead));
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
		try(
			// 创建StringWriter时，实际上以一个StringBuffer作为输出节点
			// 下面指定的20就是StringBuffer的初始长度
			StringWriter sw = new StringWriter())
		{
			// 调用StringWriter的方法执行输出
			sw.write("有一个美丽的新世界，\n");
			sw.write("她在远方等我,\n");
			sw.write("哪里有天真的孩子，\n");
			sw.write("还有姑娘的酒窝\n");
			System.out.println("----下面是sw的字符串节点里的内容----");
			// 使用toString()方法返回StringWriter的字符串节点的内容
			System.out.println(sw.toString());
		}
		catch (IOException ex)
		{
			ex.printStackTrace();
		}
	}
}
```

1. 4个访问管道的流: PipedInputStream、PipedOutputStream、PipedReader、PipedWriter,它们都是用于实现**进程之间通信功能的**，分别是字节输入流、字节输出流、字符输入流和字符输出流。
2. 4个缓冲流则增加了缓冲功能，增加缓冲功能可以提高输入、输出的效率，增加缓冲功能后需要使用flush()才可以将缓冲区的内容写入实际的物理节点。
3. 对象流主要用于实现对象的序列化

### 转换流

输入/输出流体系中提供了两个转换流，这两个转换流用于**实现将字节流转换成字符流**，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流。

问题：为什么没有讲字符流转换成字节流的转换流？

1. 字符流和字节流的差别:字节流比字符流的使用范围更广，但字符流比字节流操作方便。

2. 如果有一个流已经是字符流了，也就是说，是一个用起来更方便的流，为什么要转换成字节流呢?

3. 如果现在有一个字节流，但可以确定这个字节流的内容都是文本内容，那么把它转换减字符流来处理就会更方便一些，所以Java只提供了将字节流转换成字符流的转换流，没有提供将字符流转换成字节流的转换流。

**获取键盘输入展示转换流**

Java使用System.in 代表标准输入，即键盘输入，**但这个标准输入流是InputStream类的实例**，使用不太方便，而且键盘输入内容都是文本内容，所以可以**使用InputStreamReader将其转换成字符输入流**。

普通的Reader读取输入内容时依然不太方便，可以将普通的Reader再次包装成BufferedReader，利用BufferedReader的readLine()方法可以一次读取一行内容。

```java
public class KeyinTest
{
	public static void main(String[] args)
	{
		try(
			// 将Sytem.in对象转换成Reader对象
			InputStreamReader reader = new InputStreamReader(System.in);
			// 将普通Reader包装成BufferedReader
			BufferedReader br = new BufferedReader(reader))
		{
			String line = null;
			// 采用循环方式来一行一行的读取
			while ((line = br.readLine()) != null)
			{
				// 如果读取的字符串为"exit"，程序退出
				if (line.equals("exit"))
				{
					System.exit(1);
				}
				// 打印读取的内容
				System.out.println("输入内容为:" + line);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}
```

```java
			// 将Sytem.in对象转换成Reader对象
			InputStreamReader reader = new InputStreamReader(System.in);
			// 将普通Reader包装成BufferedReader
			BufferedReader br = new BufferedReader(reader))
负责将System.in包装成BufferedReader, BufferedReader流具有缓冲功能，它可以一次读取一行文本——以换行符为标志，如果它没有读到换行符，则程序阻塞，等到读到换行符为止。运行上面程序可以发现这个特征，在控制台执行输入时，只有按下回车键，程序才会打印出刚刚输入的内容。
```

![image-20211201224218255](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211201224218255.png)

### 推回输出流(了解)

在输入/输出流体系中，有两个特殊的流与众不同，就是PushbackInputStream和PushbackReader,

1. void unread(byte[]J/char[] buf):将一个字节/字符数组内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。
2. void unread(byte[J/char[] b, int off, int len):将一个字节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。
3. void unread(int b):将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。

这三个方法与read()方法一一对应。

这两个推回输入流都带有一个推回缓冲区，当程序调用这两个推回输入流的unread()方法时，系统将会把指定数组的内容推回到该缓冲区里，而**推回输入流每次调用read()方法时总是先从推回缓冲区读取，只有完全读取了推回缓冲区的内容后，但还没有装满read()所需的数组时才会从原输入流中读取。**

![image-20211201224940203](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211201224940203.png)

当程序创建一个 PushbackInputStream和PushbackReader 时需要指定推回缓冲区的大小，默认的推回缓冲区的长度为1。如果程序中推回到推回缓冲区的内容超出了推回缓冲区的大小，将会引发Pushback buffer overflow的IOException异常。

```java
public class PushbackTest
{
	public static void main(String[] args)
	{
		try(
			// 创建一个PushbackReader对象，指定推回缓冲区的长度为64
			PushbackReader pr = new PushbackReader(new FileReader(
				"src/lession_IO/PushbackTest.java") , 64))
		{
			char[] buf = new char[32];
			// 用以保存上次读取的字符串内容
			String lastContent = "";
			int hasRead = 0;
			// 循环读取文件内容
			while ((hasRead = pr.read(buf)) > 0)
			{
				// 将读取的内容转换成字符串
				String content = new String(buf , 0 , hasRead);
				int targetIndex = 0;
				// 将上次读取的字符串和本次读取的字符串拼起来，
				// 查看是否包含目标字符串, 如果包含目标字符串
				if ((targetIndex = (lastContent + content)
					.indexOf("new PushbackReader")) > 0)
				{
					// 将本次内容和上次内容一起推回缓冲区
					pr.unread((lastContent + content).toCharArray());
					// 重新定义一个长度为targetIndex的char数组
					if(targetIndex > 32)
					{
						buf = new char[targetIndex];
					}
					// 再次读取指定长度的内容（就是目标字符串之前的内容）
					pr.read(buf , 0 , targetIndex);
					// 打印读取的内容
					System.out.print(new String(buf , 0 ,targetIndex));
					System.exit(0);
				}
				else
				{
					// 打印上次读取的内容
					System.out.print(lastContent);
					// 将本次内容设为上次读取的内容
					lastContent = content;
				}
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}
```

### RandomAccessFile

既可以读取文件，又可以向文件输出数据。

与普通输出流不同的是，支持随机访问，可以跳转到文件的任意地方修改数据。

由于RandomAccessFile可以自由访问文件的任意位置，所以如果只需要访问文件部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。

与OutputStream、Writer 等输出流不同的是，RandomAccessFile 允许自由定位文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此 RandomAccessFile可以向已存在的文件后追加内容。**如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile。**

RandomAccessFile的方法虽然多，但它有一个最大的局限，就是**只能读写文件，不能读写其他 IO节点**。

RandomAccessFile对象也包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件记录指针位于文件头（也就是0处)，当读/写了n个字节后，文件记录指针将会向后移动n个字节。除此之外，RandomAccessFile可以自由移动该记录指针，既可以向前移动，也可以向后移动。RandomAccessFile包含了如下两个方法来操作文件记录指针。

1. long getFilePointer():返回文件记录指针的当前位置。

2. void seek(long pos):将文件记录指针定位到pos位置。

RandomAccessFile既可以读文件，也可以写，所以它既包含了完全类似于InputStream的三个read()方法,其用法和InputStream的三个read()方法完全一样;也包含了完全类似于OutputStream的三个write()方法，其用法和OutputStream的三个write()方法完全一样。

除此之外，RandomAccessFile 还包含了一系列的readXxx()和 writeXxx()方法来完成输入、输出。

RandomAccessFile类有两个构造器,其实这两个构造器基本相同,只是指定文件的形式不同而已**一个使用String参数来指定文件名**,**一个使用File参数来指定文件本身**。除此之外,创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile 的访问模式，该参数有如下4个值。

"r":以只读方式打开指定文件。如果试图对该RandomAccessFile执行写入方法，都将抛出IOException异常。
"rw":以读、写方式打开指定文件。如果该文件尚不存在，则尝试创建该文件。
"rws":以读、写方式打开指定文件。相对于"rw"模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。
"rwd":以读、写方式打开指定文件。相对于"rw"模式，还要求对文件内容的每个更新都同步写入到底层存储设备。

**读操作**

```java
public class RandomAccessFileTest
{
	public static void main(String[] args)
	{
		try(
			RandomAccessFile raf =  new RandomAccessFile(
				"src/lession_IO/RandomAccessFileTest.java" , "r"))
		{
			// 获取RandomAccessFile对象文件指针的位置，初始位置是0
			System.out.println("RandomAccessFile的文件指针的初始位置："
				+ raf.getFilePointer());
			// 移动raf的文件记录指针的位置
			raf.seek(300);
			byte[] bbuf = new byte[1024];
			// 用于保存实际读取的字节数
			int hasRead = 0;
			// 使用循环来重复“取水”过程
			while ((hasRead = raf.read(bbuf)) > 0 )
			{
				// 取出“竹筒”中水滴（字节），将字节数组转换成字符串输入！
				System.out.print(new String(bbuf , 0 , hasRead ));
			}
		}
		catch (IOException ex)
		{
			ex.printStackTrace();
		}
	}
}
```

**写操作**

```java
public class AppendContent
{
	public static void main(String[] args)
	{
		try(
			//以读、写方式打开一个RandomAccessFile对象
			RandomAccessFile raf = new RandomAccessFile("out.txt" , "rw"))
		{
			//将记录指针移动到out.txt文件的最后
			raf.seek(raf.length());
			raf.write("追加的内容！\r\n".getBytes());
		}
		catch (IOException ex)
		{
			ex.printStackTrace();
		}
	}
}
```



**注意：**

RandomAccessFile依然不能向文件的指定位置插入内容,如果直接将文件记录指针移动到中间某位置后开始输出，则新输出的内容会覆盖文件中原有的内容。如果需要向指定位置插入内容，程序需要先把插入点后面的内容读入缓冲区，等把需要插入的数据写入文件后，再将缓冲区的内容追加到文件后面。

```java
public class InsertContent
{
	public static void insert(String fileName ,long pos
		, String insertContent) throws IOException
	{
		File tmp = File.createTempFile("tmp" , null);
		tmp.deleteOnExit();
		try(
			RandomAccessFile raf = new RandomAccessFile(fileName , "rw");
			// 使用临时文件来保存插入点后的数据
			FileOutputStream tmpOut = new FileOutputStream(tmp);
			FileInputStream tmpIn = new FileInputStream(tmp))
		{
			raf.seek(pos);
			// ------下面代码将插入点后的内容读入临时文件中保存------
			byte[] bbuf = new byte[64];
			// 用于保存实际读取的字节数
			int hasRead = 0;
			// 使用循环方式读取插入点后的数据
			while ((hasRead = raf.read(bbuf)) > 0 )
			{
				// 将读取的数据写入临时文件
				tmpOut.write(bbuf , 0 , hasRead);
			}
			// ----------下面代码插入内容----------
			// 把文件记录指针重新定位到pos位置
			raf.seek(pos);
			// 追加需要插入的内容
			raf.write(insertContent.getBytes());
			// 追加临时文件中的内容
			while ((hasRead = tmpIn.read(bbuf)) > 0 )
			{
				raf.write(bbuf , 0 , hasRead);
			}
		}
	}
	public static void main(String[] args)
		throws IOException
	{
		insert("src/lession_IO/InsertContent.java" , 45 , "插入的内容\r\n");
	}
}
```

上面程序中使用File的create' TempFile(String prefix, String suffix)方法创建了一个临时文件(该临时文件将在JVM退出时被删除),用以保存被插入文件的插入点后面的内容。程序先将文件中插入点后的内容读入临时文件中，然后重新定位到插入点，将需要插入的内容添加到文件后面，最后将临时文件的内容添加到文件后面，通过这个过程就可以向指定文件、指定位置插入内容。每次运行上面程序，都会看到向InsertContent.java 中插入了一行字符串。

## 序列化

### 序列化

序列化是指把一个Java对象变成二进制内容，本质上就是一个`byte[]`数组。

为什么要把Java对象序列化呢？因为序列化后可以把`byte[]`保存到文件中，或者把`byte[]`通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。

有序列化，就有反序列化，即把一个二进制内容（也就是`byte[]`数组）变回Java对象。有了反序列化，保存到文件中的`byte[]`数组又可以“变回”Java对象，或者从网络上读取`byte[]`并把它“变回”Java对象。

一个Java对象要能序列化，必须实现一个特殊的`java.io.Serializable`接口，它的定义如下：

```java
public interface Serializable {
}
```

`Serializable`接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。

把一个Java对象变为`byte[]`数组，需要使用`ObjectOutputStream`。它负责把一个Java对象写入一个字节流：

```java
public class Main {
    public static void main(String[] args) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {
            // 写入int:
            output.writeInt(12345);
            // 写入String:
            output.writeUTF("Hello");
            // 写入Object:
            output.writeObject(Double.valueOf(123.456));
        }
        System.out.println(Arrays.toString(buffer.toByteArray()));
    }
}
```

[-84, -19, 0, 5, 119, 11, 0, 0, 48, 57, 0, 5, 72, 101, 108, 108, 111, 115, 114, 0, 16, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 68, 111, 117, 98, 108, 101, -128, -77, -62, 74, 41, 107, -5, 4, 2, 0, 1, 68, 0, 5, 118, 97, 108, 117, 101, 120, 114, 0, 16, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 78, 117, 109, 98, 101, 114, -122, -84, -107, 29, 11, -108, -32, -117, 2, 0, 0, 120, 112, 64, 94, -35, 47, 26, -97, -66, 119]

`ObjectOutputStream`既可以写入基本类型，如`int`，`boolean`，也可以写入`String`（以UTF-8编码），还可以写入实现了`Serializable`接口的`Object`。

因为写入`Object`时需要大量的类型信息，所以写入的内容很大。

### 反序列化

和`ObjectOutputStream`相反，`ObjectInputStream`负责从一个字节流读取Java对象：

```
try (ObjectInputStream input = new ObjectInputStream(...)) {
    int n = input.readInt();
    String s = input.readUTF();
    Double d = (Double) input.readObject();
}
```

除了能读取基本类型和`String`类型外，调用`readObject()`可以直接返回一个`Object`对象。要把它变成一个特定类型，必须强制转型。

`readObject()`可能抛出的异常有：

- `ClassNotFoundException`：没有找到对应的Class；
- `InvalidClassException`：Class不匹配。

对于`ClassNotFoundException`，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，`Person`对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义`Person`类，所以无法反序列化。

对于`InvalidClassException`，这种情况常见于序列化的`Person`对象定义了一个`int`类型的`age`字段，但是反序列化时，`Person`类定义的`age`字段被改成了`long`类型，所以导致class不兼容。

为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的`serialVersionUID`静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变`serialVersionUID`的值，这样就能自动阻止不匹配的class版本：

```
public class Person implements Serializable {
    private static final long serialVersionUID = 2709425275741743919L;
}
```

要特别注意反序列化的几个重要特点：

反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。

### 安全性

因为Java的序列化机制可以导致一个实例能直接从`byte[]`数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的`byte[]`数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。

实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。
