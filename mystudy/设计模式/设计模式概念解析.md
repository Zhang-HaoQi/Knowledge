# 面向对象设计原则

![image-20211015212053578](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015212053578.png)

设计模式利用这些设计原则进行设计。

单一职责原则：当前类只解决一个方面的问题，如果职责越多，与其他类的关系越多，耦合度会升高。

开放-封闭原则：不做程序修改，只做功能添加，用新的类去开发新的功能。

里式替换原则：子类继承了父类，子类有父类的特性，且功能比父类强大。当子类中的一些方法进行重载覆盖时，此时就不能用父类指向子类。开闭原则是不希望盲目重载和修改父类的方法，这样会有安全隐患，因为你修改别人不知道，别人会认为子类和父类有关系。遵守这个原则，你就不会盲目重载方法。（接口就解决了这个问题）

依赖倒置原则：针对接口编程，不要针对实现编程。设计程序时，要依赖接口，不要依赖具体的实现类，可以更加灵活，不受太多的制约。

举例：硬件领域：如果计算机更换显卡，我们只需要换一个新的显卡就行。但是电视机是采用焊接的形式装的显卡，我们不能直接进行更换。两种方式各有千秋，根据用户习惯，计算机的显卡或内存的更换频率还是比较大的，但是电视是基本不会更换的，比较稳定。  在软件中，我们的系统实时可能要面对需求的变化，因此通过接口的方式，可以让我们的程序更容易地扩展或修改。

接口隔离原则：一个接口只做一件事情，可以减少错误的发生率。

组合重用原则：继承是紧耦合，我们要尽量少用，因为父类一遍，子类都得变。

迪米特法则：一个对象尽可能少的对其他对象有了解，只有了解少，才能用标准的方式去调用，如果知道的越多，很可能直接调用它，而不是用他提供的方法进行操作。程序中以封装的形式表现。

# 设计模式

## 创建型模式（创建对象的模式）

1. **抽象工厂模式：**提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。
   1.  一个系统要独立于其产品的创建、组合和表示时
   2.  当需要强调一系列相关的产品对象的设计以便进行联合使用时
       1.  为图形用户界面（GUI）组件定义不同平台的并行类层次结构
   3.  当提供一个产品类库，而只想显示它们的接口而不是实现时。
   4.  一个系统要由多个产品系列中的一个来配置时
2. **构建器模式：**将一个复杂类的表示与其构造相分离，使得相同的构造过程能够得出不同的表示。
   1. 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时：当构造过程必须允许被构造的对象有不同的表示时。
 3. **工厂方法模式：**定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法是的子类实例化的过程推迟。
     1. 适用于当一个类不知道它所必须创建的对象的类的时候：当一个类希望由它的子类来指定它所创建的对象的时候；
     2. 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 
 4. **原型模式：**用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。（直接复制，比照着再创建一个对象要节约时间）
     1. 当一个系统应该独立于它的产品创建、构成和表示时
     2. 当要实例化的类是在运行时刻指定时，例如通过动态装载，为了避免创建一个与产品类层次平行的工厂类层次时
     3. 当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
 5. **单例模式：**保证一个类只有一个实例，并提供一个访问它的全局访问点。
     1. 一个类只有一个实例
     2. 单例类提供一个访问唯一实例的全局访问点

## 结构型模式（处理类和对象的组合问题）

1. **适配器模式：**将一个类的接口转换成用户希望得到的另一种接口。使原本不相容的接口得以协同工作。

   1. 即是类结构模式，又是对象结构模式
   2. 与桥接模式类似，都给另一个对象提供了一定程度上的间接性，都涉及到自身以外的一个接口向这个对象转发请求。

2. **桥接模式：**将类的抽象部分和它的实现部分分离开来，使它们独立地变化。

   ![image-20211028112113612](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028112113612.png)

   1. 可应用与希望使用已存在的类，但其接口不符合需求的时候
   2. 与适配器模式类似。

3. **组合模式（层次）：**将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

4. **装饰模式（动态添加额外职责）：**动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更灵活。

   1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
   2. 处理那些可以撤销的职责
   3. 当不能采用生成子类的方式进行扩充时

5. **外观模式（对外统一接口）：**定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用。

   1. 要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂；
   2. 客户程序与抽象类的实现部分之间存在着很大的依赖性；
   3. 当需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点；

6. **享元模式（细粒度，共享）：**提供支持大量细粒度对象共享的有效方法。

   1. 一个应用程序使用了大量的对象
   2. 完全由于使用大量的对象而造成很大的存储开销
   3. 对象的大多数状态都可变为外部状态
   4. 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象
   5. 应用程序不依赖于对象标识

7. **代理模式：**为其他对象提供一种代理（与对象相同的接口）以控制这个对象的访问，已使在确实需要这个对象时才对它进行创建和初始化。

## 行为模式（类和对象交互的情况和职责分配）

行为设计模式大多注重封装变化，当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样，当该程序的其他部分依赖于这个方面时，它们都可以与此对象协作。这些模式通常定义一个抽象类来描述这些封装变化的对象，并且通常该模式依据这个对象来命名。             

1. **职责链模式（传递职责）：**通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。
   1. 有多个的对象可以处理一个请求，哪个对象处理该请求在运行时刻自动确定；
   2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；
   3. 可处理一个请求的对象集合应被动态指定。
2. **命令模式（日志记录，可撤销）：**将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销操作。
   1. 抽象出待执行的动作以参数化某对象，此模式是过程语言中的回调（callback）机制的一个面向对象的替代方式
   2. 在不同的时刻指定、排列和执行请求；
   3. 支持取消操作；
   4. 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍；
   5. 用构建在原语操作上的高层操作构造一个系统。
3. **解释器模式：**给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子。
4. **迭代器模式：**提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴漏该对象的内部表示。
5. **中介者模式（不直接引用）：**用一个中介对象来封装一系列的对象交互。它使个对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互
   1. 适用于一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
   2. 该模式与观察者模式相互竞争。中介者模式封装了其它对象进行通信，观察者模式引入了其它对象分布通信。
6. **备忘录模式（恢复对象）：**保存一个对象的某个状态，以便在适当的时候恢复对象。
7. **观察者模式：**当对象间存在一对多关系时，则使用观察者模式。比如，当一个对象被修改时，则会自动通知依赖它的对象。
   1. 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立地对象中以使它们可以各自独立地改变和复用；
   2. 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时；
   3. 当一个对象必须通知其他对象，它又不能假定其他对象是谁，即：不希望这些对象是紧耦合的。
8. **状态模式：**允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
9. **策略模式：**定义一系列算法，把它们一个个封装起来，并且使他们可以相互转换。此模式是的算法可以独立与使用它们的客户而变化。
   1. 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法；
   2. 需要使用一个算法的不同变体。例如，定义一些反应不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式；
   3. 算法使用客户不座该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构；
   4. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语旬。
10. **模板模式：**一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
11. **访问者模式：**将数据操作和数据结构分离。表示一个作用对象结构中的各元素的操作。它允许在不改变个元素的类的前提下定义作用于这些元素的新操作。

## 特殊

责任链，迭代器模式：行为型对象模式

桥接模式：结构型对象模式

适配器模式：类结构模式，结构型对象模式

工厂方法模式：类，对象创建型模式

解释器模式：类，对象行为型模式

访问者模式：行为型对象模式
