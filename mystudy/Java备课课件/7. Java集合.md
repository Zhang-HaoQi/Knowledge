# Java集合

## 0. 热身

```java
package lession11_26;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @Classname ListMain
 * @Description TODO
 * @Date 2021/11/26 13:25
 * @Created by DELL
 */
class SuperMan {
    private String name;
    private String idcard;
    private int age;
    private char sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIdcard() {
        return idcard;
    }

    public void setIdcard(String idcard) {
        this.idcard = idcard;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "SuperMan{" +
                "name='" + name + '\'' +
                ", idcard='" + idcard + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SuperMan superMan = (SuperMan) o;
        if (age != superMan.age) return false;
        if (sex != superMan.sex) return false;
        if (name != null ? !name.equals(superMan.name) : superMan.name != null) return false;
        return idcard != null ? idcard.equals(superMan.idcard) : superMan.idcard == null;
    }

//    @Override
//    public int hashCode() {
//        int result = name != null ? name.hashCode() : 0;
//        result = 31 * result + (idcard != null ? idcard.hashCode() : 0);
//        result = 31 * result + age;
//        result = 31 * result + (int) sex;
//        return result;
//    }
}

public class ListMain {
    public static void main(String[] args) {
        ArrayList arr = new ArrayList(10);
       // 操作Java提供的常用类。
        Integer a = 1;
        Boolean b = true;
        String str = "123456";
        arr.add(a);
        arr.add(b);
        arr.add(str);
        arr.get(0);
        arr.get(1);
        arr.get(2);
        arr.remove(true);
        arr.set(0, 500);
//        arr.set(10,800);  报错
        //往集合中添加SuperMan元素
         SuperMan superMan = new SuperMan();
         superMan.setName("绿巨人");
         superMan.setAge(18);
         superMan.setSex('男');
         superMan.setIdcard("1234567");
         arr.add(superMan);
        for (int i = 1; i <= 10; i++) {
            SuperMan man = new SuperMan();
            man.setName("绿巨人"+i);
            man.setAge(i);
            man.setSex('男');
            man.setIdcard("1928424"+"编号"+i);
            arr.add(man);
        }
        SuperMan man = new SuperMan();
        man.setName("绿巨人"+1);
        man.setAge(1);
        man.setSex('男');
        man.setIdcard("1928424"+"编号"+1);
        arr.add("sdihfkdsjfhkjs");
        System.out.println(arr.contains(man));
       System.out.println(arr);
       //使用泛型，规定集合中所存储的数据类型
        ArrayList<SuperMan> arrs = new ArrayList<>();
        for (int i = 1; i <= 10; i++) {
            SuperMan man1 = new SuperMan();
            man1.setName("绿巨人" + i);
            man1.setAge(i);
            man1.setSex('男');
            man1.setIdcard("1928424" + "编号" + i);
            arrs.add(man1);
        }
        //移除集合中元素时，注意集合中元素的移动
        for (int i = 0; i <arrs.size(); i++) {
            if (arrs.get(i).getAge()==5){
                arrs.remove(i);
            }
            if (arrs.get(i).getAge()==6){
                System.out.println("这是6岁的绿巨人");
            }
        }
        //使用stream流操作结合
        arrs.forEach(System.out::println);
        List<String> collect = arrs.stream()
                .sorted((v1,v2)->v2.getAge()-v1.getAge())
                .filter(e->e.getAge()>5)
                .map(SuperMan::getIdcard)
                .collect(Collectors.toList());
        collect.forEach(System.out::println);
        System.out.println(collect);


        //不使用stream
        ArrayList<String> superManIds=new ArrayList<>();
        for (int i = 0; i < arrs.size(); i++) {
           SuperMan man1 = arrs.get(i);
            if (man1.getAge()>5){
                superManIds.add(man1.getIdcard());
            }
        }
        superManIds.forEach(System.out::println);


    }
}

```



集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象(实际上保存的是对象的引用变量)。

集合里只能保存对象（实际上只是保存对象的引用变量，但通常习惯上认为集合里保存的是对象)。

Java的集合类主要由两个接口派生而出:Collection和 Map，Collection和 Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。

**集合体系**

![image-20211123210129611](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123210129611.png)

![image-20211123210754568](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123210754568.png)

**Map体系**

![image-20211123211125145](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123211125145.png)

## 1. Collection和Iterator接口

### Collection介绍

Collection接口是List、Set和 Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和 Queue集合。

1. boolean **add**(Object o):该方法用于向集合里添加一个元素。如果集合对象被添加操作改变了，则返回true。
2. boolean **addAll**(Collection c):该方法把集合c里的所有元素添加到指定集合里。如果集合对象被添加操作改变了，则返回true。
3. void **clear**():清除集合里的所有元素,将集合长度变为0。
4. boolean **contains**(Object o):返回集合里是否包含指定元素
5. boolean **containsAll**(Collection c):返回集合里是否包含集合c里的所有元素。
6. boolean **isEmpty()**:返回集合是否为空。当集合长度为О时返回true，否则返回false。
7. Iterator **iterator()**:返回一个Iterator对象，用于遍历集合里的元素。
8. boolean **remove(Object o)**:删除集合中的指定元素o，当集合中包含了一个或多个元素o时，该方法**只删除第一个符合条件的元素**，该方法将返回true。
9. boolean **removeAll(Collection c)**:**从集合中删除集合c里包含的所有元素**（相当于用调用该方法的集合减集合c)，如果删除了一个或一个以上的元素，则该方法返回true。
10. boolean **retainAll(Collection c)**:从集合中**删除集合c里不包含的元素**(相当于把调用该方法的集合变成该集合和集合c的交集)，如果该操作改变了调用该方法的集合，则该方法返回true。
11. int **size()**:该方法返回集合里元素的个数。
12. Object [] **toArray()**:该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。
13. 详情查看api文档

**集合练习**

```java
public class CollectionTest
{
	public static void main(String[] args)
	{
		Collection c = new ArrayList();
		// 添加元素
		c.add("孙悟空");
		// 虽然集合里不能放基本类型的值，但Java支持自动装箱
		c.add(6);
		System.out.println("c集合的元素个数为:" + c.size()); // 输出2
		// 删除指定元素
		c.remove(6);
		System.out.println("c集合的元素个数为:" + c.size()); // 输出1
		// 判断是否包含指定字符串
		System.out.println("c集合的是否包含\"孙悟空\"字符串:"
			+ c.contains("孙悟空")); // 输出true
		c.add("轻量级Java EE企业应用实战");
		System.out.println("c集合的元素：" + c);
		Collection books = new HashSet();
		books.add("轻量级Java EE企业应用实战");
		books.add("疯狂Java讲义");
		System.out.println("c集合是否完全包含books集合？"
			+ c.containsAll(books)); // 输出false
		// 用c集合减去books集合里的元素
		c.removeAll(books);
		System.out.println("c集合的元素：" + c);
		// 删除c集合里所有元素
		c.clear();
		System.out.println("c集合的元素：" + c);
		// 控制books集合里只剩下c集合里也包含的元素
		books.retainAll(c);
		System.out.println("books集合的元素:" + books);
	}
}
```

当使用System.out的printIn()方法来输出集合对象时，将输出[ele1,ele2...].[的形式，这显然是因为**所有的Collection实现类都重写了toString()方法**，该方法可以一次性地输出集合中的所有元素。

注意：如果不为集合设置泛型，那么默认情况下，集合存储的数据类型为Object类型

### 遍历集合

#### 1. 使用Lambda遍历集合

Java 8为Iterable接口新增了**一个forEach(Consumer action)默认方法**，该方法所需参数的类型是一
个函数式接口，而Iterable接口是Collection接口的父接口，因此Collection集合也可直接调用该方法。

当程序调用Iterable 的forEach(Consumer action)遍历集合 元素时，**程序会依次将集合元素传给**
**Consumer的accept(T t)方法(该接口中唯一的抽象方法)。** 正因为Consumer是函数式接口，因此可以
使用Lambda表达式来遍历集合元素。

如下程序示范了使用Lambda表达式来遍历集合元素。

```java
public class CollectionEach
{
	public static void main(String[] args)
	{
		// 创建一个集合
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 调用forEach()方法遍历集合
		books.forEach(obj -> System.out.println("迭代集合元素：" + obj));
	}
}
```

#### 2. 使用Iterator遍历集合元素

Collection系列集合、Map系列集合主要用于盛装其他对象，而 Iterator则主要用于遍历〈即迭代访问)Collection集合中的元素，Iterator对象也被称为迭代器。

Iterator接口隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口。

**定义的方法：**

1. boolean hasNext():如果被迭代的集合元素还没有被遍历完，则返回true。

2. Object next():返回集合里的下一个元素。

3. void remove(）:删除集合里上一次next方法返回的元素。

4. void forEachRemaining(Consumer action)，这是Java 8为lterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。

```java
public class IteratorTest
{
	public static void main(String[] args)
	{
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		while(it.hasNext())
		{
			// it.next()方法返回的数据类型是Object类型，因此需要强制类型转换
			String book = (String)it.next();
			System.out.println(book);
			if (book.equals("Java"))
			{
				// 从集合中删除上一次next方法返回的元素
				it.remove();
			}
			// 对book变量赋值，不会改变集合元素本身
			book = "测试字符串";   //无效
		}
		System.out.println(books);
	}
}
```

1. Iterator必须依附于Collection对象，若有一个Iterator对象，则必然有一个与之关联的Collection对象。Iterator提供了两个方法来迭代访问Collection集合里的元素，并可通过remove()方法来删除集合中上一次next()方法返回的集合元素。
2. 对迭代变量book进行赋值，但当再次输出books 集合时，会看到集合里的元素没有任何改变。当使用Iterator对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量，所以修改迭代变量的值对集合元素本身没有任何影响。
3. 当使用Iterator 迭代访问Collection 集合元素时，Collection 集合里的元素不能被改变，只有通过
   Iterator的remove0方法删除上一次next0方法返回的集合元素才可以;否则将会引发java.util.Concurrent
   ModificationException异常。

```java
public class IteratorErrorTest
{
	public static void main(String[] args)
	{
        Collection books = new HashSet();
		// 创建集合、添加元素的代码与前一个程序相同
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		while(it.hasNext())
		{
			String book = (String)it.next();
			System.out.println(book);
			if (book.equals("Java"))
			{
				// 使用Iterator迭代过程中，不可修改集合元素,下面代码引发异常
				books.remove(book);
			}
		}
	}
}
```

![image-20211123214335887](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123214335887.png)

注意：当我们进行集合迭代时，删除元素会导致错误。

#### 3. 使用Lambda表达式遍历Iterator

Java 8为Iterator新增了一个forEachRemaining(Consumer action)方法，该方法所需的Consumer参
数同样也是函数式接口。当程序调用Iterator的forEachRemaining(Consumer action)遍历集合元素时，程序会**依次**将集合元素传给Consumer的accept(T t)方法( 该接口中唯一的抽象方法)。

```java
public class IteratorEach
{
	public static void main(String[] args)
	{
		// 创建集合、添加元素的代码与前一个程序相同
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		// 使用Lambda表达式（目标类型是Comsumer）来遍历集合元素
		it.forEachRemaining(obj -> System.out.println("迭代集合元素：" + obj));
	}
}
```

#### 4. 使用foreach循环遍历集合元素

```java
public class ForeachTest
{
	public static void main(String[] args)
	{
		// 创建集合、添加元素的代码与前一个程序相同
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		for (Object obj : books)
		{
			// 此处的book变量也不是集合元素本身
			String book = (String)obj;
			System.out.println(book);
			if (book.equals("疯狂Android讲义"))
			{
				// 下面代码会引发ConcurrentModificationException异常
				books.remove(book);     //①
			}
		}
		System.out.println(books);
	}
}
```

#### 5. 使用Predicate操作集合

Java 8为Collection集合新增了一个个removelf(Predicate filter)方法，该方法将会批量删除符合filter
条件的所有元素。该方法需要一个Predicate (谓词)对象作为参数，Predicate 也是函数式接口，因此可
使用Lambda表达式作为参数。

removeIf，删除符合条件的数据，条件通过实现Predicate 的方法来创造。

![image-20211123220954780](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123220954780.png)

Predicate ：类似筛选条件。

![image-20211123221143697](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123221143697.png)

如下程序示范了使用Predicate 来过滤集合。

```java
public class PredicateTest
{
	public static void main(String[] args)
	{
		// 创建一个集合
		Collection books = new HashSet();
		books.add(new String("Java EE"));
		books.add(new String("Java"));
		books.add(new String("iOS"));
		books.add(new String("Ajax"));
		books.add(new String("Android"));
		// 使用Lambda表达式（目标类型是Predicate）过滤集合
		books.removeIf(ele -> ((String)ele).length() < 5);
		System.out.println(books);
	}
}
```

需求：

1. 统计书名中出现“疯狂”字符串的图书数量。
2. 统计书名中出现“Java”字符串的图书数量。
3. 统计书名长度大于10的图书数量。

```java
public class PredicateTest2
{
	public static void main(String[] args)
	{
		// 创建books集合、为books集合添加元素的代码与前一个程序相同。
		Collection books = new HashSet();
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂iOS讲义"));
		books.add(new String("疯狂Ajax讲义"));
		books.add(new String("疯狂Android讲义"));
		// 统计书名包含“疯狂”子串的图书数量
		System.out.println(calAll(books , ele->((String)ele).contains("疯狂")));
		// 统计书名包含“Java”子串的图书数量
		System.out.println(calAll(books , ele->((String)ele).contains("Java")));
		// 统计书名字符串长度大于10的图书数量
		System.out.println(calAll(books , ele->((String)ele).length() > 10));
	}
	public static int calAll(Collection books , Predicate p)
	{
		int total = 0;
		for (Object obj : books)
		{
			// 使用Predicate的test()方法判断该对象是否满足Predicate指定的条件
			if (p.test(obj))
			{
				total ++;
			}
		}
		return total;
	}
}
```

#### 6. 使用Stream流

Java 8新增了Stream、IntStream、 LongStream、 DoubleStream 等流式API,这些API代表多个支持串行和并行聚集操作的元素。

上面4个接口中，Stream是一个通用的流接口,而IntStream、LongStream、DoubleStream则代表元素类型为int、long、 double 的流。

每个流式API有对应的Builder, 例如Stream.Builder、 IntStream.Builder、LongStream.Builder、DoubleStream. Builder,开发者可以通过这些Builder来创建对应的流。

**使用Stream的步骤如下:**

1. 使用Stream或XxxStream的builder(）类方法创建该Stream对应的Builder。
2. 重复调用Builder的add（）方法向该流中添加多个元素。
3. 调用Builder的build（）方法获取对应的Stream。
4. 调用Stream的聚集方法。

```java
public class IntStreamTest
{
	public static void main(String[] args)
	{
		IntStream is = IntStream.builder()
			.add(20)
			.add(13)
			.add(-2)
			.add(18)
			.build();
		// 下面调用聚集方法的代码每次只能执行一个
		System.out.println("is所有元素的最大值：" + is.max().getAsInt());
		System.out.println("is所有元素的最小值：" + is.min().getAsInt());
		System.out.println("is所有元素的总和：" + is.sum());
		System.out.println("is所有元素的总数：" + is.count());
		System.out.println("is所有元素的平均值：" + is.average());
		System.out.println("is所有元素的平方是否都大于20:"
			+ is.allMatch(ele -> ele * ele > 20));
		System.out.println("is是否包含任何元素的平方大于20:"
			+ is.anyMatch(ele -> ele * ele > 20));
		// 将is映射成一个新Stream，新Stream的每个元素是原Stream元素的2倍+1
		IntStream newIs = is.map(ele -> ele * 2 + 1);
		// 使用方法引用的方式来遍历集合元素
		newIs.forEach(System.out::println); // 输出41 27 -3 37
	}
}
```

上面程序先创建了一个IntStream,接下来调用IntStream的聚集方法执行操作，这样即可获取该流的相关信息。

注意：一个IntStream调用一次聚集方法后，流就进行了关闭，不能调用其他的方法。

![image-20211124141450401](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211124141450401.png)Stream提供了大量的方法进行聚集操作，这些方法既可以是“中间的”(intermediate)，也可以是“末端的”(terminal)。

1. 中间方法:中间操作允许流保持打开状态，并允许直接调用后续方法。上面程序中的map()方法就是中间方法。中间方法的返回值是另外一个流。
2. 末端方法:末端方法是对流的最终操作。当对某个Stream执行末端方法后,该流将会被“消耗”且不再可用。上面程序中的sum()、count()、 averageO等 方法都是末端方法。

**流的方法还有如下两个特征。**

1. 有状态的方法:这种方法会给流增加一些新的属性，比如元素的唯一性、元素的最大数量、保证元素以排序的方式被处理等。有状态的方法往往需要更大的性能开销。
2. 短路方法:短路方法可以尽早结束对流的操作，不必检查所有的元素。

**常用的中间方法**

1. filter(Predicate predicate):过滤Stream中所有不符合predicate 的元素
2. mapToXxx(ToXxxFunction mapper):使用ToXxxFunction对流中的元素执行一对一的转换，该方法返回的新流中包含了ToXxxFunction转换生成的所有元素。
3. peek(Consumer action):依次对每个元素执行一些操作， 该方法返回的流与原有流包含相同的元素。该方法主要用于调试。
4. distinct(): 该方法用于排序流中所有重复的元素(判断元素重复的标准是使用equals)比较返回true。这是一个有状态的方法。
5. sorted(): 该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。
6. limit(long maxSize):该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个有状态的、短路方法。

**常用的末端方法**

1. forEach(Consumer action):遍历流中所有元素，对每个元素执行action。
2. toArray(): 将流中所有元素转换为一个数组。
3. reduce(): 该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。
4. min(): 返回流中所有元素的最小值。
5. max(): 返回流中所有元素的最大值。
6. count():返回流中所有元素的数量。
7. anyMatch(Predicate predicate):判断流中是否至少包含一个元素符合Predicate条件。
8. allMatch(Predicate predicate):判断流中是否每个元素都符合Predicate条件。
9. noneMatch(Predicate predicate):判断流中是否所有元素都不符合Predicate条件。
10. findFirst():返回流中的第一个元素。
11. findAny():返回流中的任意一个元素。

```java
public class CollectionStream
{
	public static void main(String[] args)
	{
		// 创建books集合、为books集合添加元素的代码与8.2.5小节的程序相同。
		Collection books = new HashSet();
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂iOS讲义"));
		books.add(new String("疯狂Ajax讲义"));
		books.add(new String("疯狂Android讲义"));
		// 统计书名包含“疯狂”子串的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele)
                   .contains("疯狂"))
			.count()); // 输出4
		// 统计书名包含“Java”子串的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele).contains("Java") )
			.count()); // 输出2
		// 统计书名字符串长度大于10的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele).length() > 10)
			.count()); // 输出2
		// 先调用Collection对象的stream()方法将集合转换为Stream,
		// 再调用Stream的mapToInt()方法获取原有的Stream对应的IntStream
		books.stream().mapToInt(ele -> ((String)ele).length())
			// 调用forEach()方法遍历IntStream中每个元素
			.forEach(System.out::println);// 输出8  11  16  7  8
	}
}
```

程序只要调用Collection的 stream()方法即可返回该集合对应的Stream，接下来就可通过Stream提供的方法对所有集合元素进行处理，这样大大地简化了集合编程的代码，这也是 Stream编程带来的优势。

```java
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
```

mapToInt()方法就是一个中间方法，因此程序可继续调用IntStream的 forEach()方法来遍历流中的元素。

## 2. List集合

List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。可以通过索引来访问指定位置的集合元素。

### 基本操作

List作为Collection接口的子接口，可以使用Collection接口里的全部方法。由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。

**常用方法**

1. void add(int index, Object element):将元素element插入到List集合的index 处。
2. boolean addAll(int index，Collection c):将集合c所包含的所有元素都插入到List集合的 index
   处。
3. Object get(int index):返回集合index索引处的元素。
4. int indexOf(Object o):返回对象o在List集合中第一次出现的位置索引。
5. int lastIndexOf(Object o):返回对象o在List集合中最后一次出现的位置索引。
6. Object remove(int index):删除并返回index索引处的元素。
7. Object set(int index, Object element):将index 索引处的元素替换成element对象，返回被替换的旧元素。
8. List subList(int fromIndex, int toIndex):返回从索引fromIndex (包含）到索引toIndex (不包含)处所有集合元素组成的子集合。
   所有的List实现类都可以调用这些方法来操作集合元素。与Set集合相比，List增加了根据索引来插入、替换和删除集合元素的方法。

```java
public class ListTest
{
	public static void main(String[] args)
	{
		List books = new ArrayList();
		// 向books集合中添加三个元素
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂Android讲义"));
		System.out.println(books);
		// 将新字符串对象插入在第二个位置
		books.add(1 , new String("疯狂Ajax讲义"));
		for (int i = 0 ; i < books.size() ; i++ )
		{
			System.out.println(books.get(i));
		}
		// 删除第三个元素
		books.remove(2);
		System.out.println(books);
		// 判断指定元素在List集合中位置：输出1，表明位于第二位
		System.out.println(books.indexOf(new String("疯狂Ajax讲义"))); 
		//将第二个元素替换成新的字符串对象
		books.set(1, new String("疯狂Java讲义"));
		System.out.println(books);
		//将books集合的第二个元素（包括）到第三个元素（不包括）截取成子集合
		System.out.println(books.subList(1 , 2));
	}
}
```

**问题：**

```java
		books.add(1 , new String("疯狂Ajax讲义"));	
// 判断指定元素在List集合中位置：输出1，表明位于第二位
		System.out.println(books.indexOf(new String("疯狂Ajax讲义"))); 
```

1. 我们往集合中添加了一个字符串对象“疯狂Ajax讲义”，但是我们又进行字符串新增时，添加的是一个新的字符串，两个字符串本质上并不属于同一个对象，但是我们使用books.indexOf(new String("疯狂Ajax讲义"))时，却发现能返回字符串所在的位置1.

2. 使用indexOf时或者remove（）对象时，集合判断的标准是引用类型的equals方法。

   1. ![image-20211125202451854](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211125202451854.png)

   2. ```java
      class A
      {
      	public boolean equals(Object obj)
      	{
      		return true;
      	}
      }
      public class ListTest2
      {
      	public static void main(String[] args)
      	{
      		List books = new ArrayList();
      		books.add(new String("轻量级Java EE企业应用实战"));
      		books.add(new String("疯狂Java讲义"));
      		books.add(new String("疯狂Android讲义"));
      		System.out.println(books);
      		// 删除集合中A对象，将导致第一个元素被删除
      		books.remove(new A());     // ①
      		System.out.println(books);
      		// 删除集合中A对象，再次删除集合中第一个元素
      		books.remove(new A());     // ②
      		System.out.println(books);
      	}
      }
      ```

   3. 当我们删除一个集合中默认不存在的元素时，会**默认删除集合中的第一个元素。**

      1. 因为走的是A的equals方法，因此默认都返回true。
      2. ![image-20211125202610932](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211125202610932.png)

**注意**：

使用List的set（int index,Object element）方法时，可以改变集合指定索引处的元素，但是指定的索引只能是集合索引所在的范围呢，set方法并不能改变List集合的长度。比如集合长度为5，在6的地方添加一个元素是不行的。

#### **Java8新增**

1. void replaceAll(UnaryOperator operator):根据 operator指定的计算规则重新设置List集合的所有元素。
2. void sort(Comparator c):根据Comparator参数对List集合的元素排序。

```java
public class ListTest3
{
	public static void main(String[] args)
	{
		List books = new ArrayList();
		// 向books集合中添加4个元素
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂Android讲义"));
		books.add(new String("疯狂iOS讲义"));
		// 使用目标类型为Comparator的Lambda表达式对List集合排序
		books.sort((o1, o2)->((String)o1).length() - ((String)o2).length());
		System.out.println(books);
		// 使用目标类型为UnaryOperator的Lambda表达式来替换集合中所有元素
		// 该Lambda表达式控制使用每个字符串的长度作为新的集合元素
		books.replaceAll(ele->((String)ele).length());
		System.out.println(books); // 输出[7, 8, 11, 16]

	}
}
```

#### 迭代器

List额外提供了一个listlterator()方法，该方法返回一个Listlterator对象，Listlterator 接口继承了lterator接口，提供了专门操作List 的方法。Listlterator接口在lterator接口基础上增加了如下方法。

1. boolean hasPrevious():返回该迭代器关联的集合是否还有上一个元素。
2. Object previous():返回该迭代器的上一个元素。
3. void add(Object o):在指定位置插入一个元素。

拿ListIterator 与普通的Iterator进行对比，不难发现Listlterator增加了向前迭代的功能(Iterator 只能向后迭代)，而且ListIlterator还可通过add()方法向List集合中添加元素（Iterator只能删除元素)。下面程序示范了ListIterator的用法。

```java
public class ListIteratorTest
{
    public static void main(String[] args)
    {
        String[] books = {
                "疯狂Java讲义", "疯狂iOS讲义",
                "轻量级Java EE企业应用实战"
        };
        List bookList = new ArrayList();
        for (int i = 0; i < books.length ; i++ )
        {
            bookList.add(books[i]);
        }
        ListIterator lit = bookList.listIterator();
        while (lit.hasNext())
        {
            System.out.println(lit.next());
//            lit.add("-------分隔符-------");
        }
        System.out.println("=======下面开始反向迭代=======");
        while(lit.hasPrevious())
        {
            System.out.println(lit.previous());
        }
    }
}

```

### ArrayList和Vector实现类

1. ArrayList和 Vector作为List类的两个典型实现，完全支持前面介绍的List接口的全部功能。

2. ArrayList和 Vector类都是基于数组实现的List类，ArrayList和Vector类封装了一个动态的、允许再分配的**Object[]数组**。Object[]数组的长度默认为10。

   1. ArrayList或Vector对象使用initialCapacity参数来设置该数组的长度，当向ArrayList或 Vector中添加元素超出了该数组的长度时，它们的initialCapacity 会自动增加。

   2. 如果向ArrayList或Vector集合中添加大量元素时，可使用ensureCapacity(int minCapacity)方法一次性地增加initialCapacity。这可以减少重分配的次数，从而提高性能。

   3. 如果开始就知道ArrayList或 Vector集合需要保存多少个元素，则可以在创建它们时就指定initialCapacity大小。

   4. ```java
            List<String> a = new ArrayList<>(15);
      ```

3. ArrayList和Vector在用法上几乎完全相同，Vector比较老，基本弃用，但是Vector线程是安全的，ArrayList是不安全的，但是实际使用中，需要线程的场景也不实用Vector，而是使用**Collections.synchronizedList** ()。

   1. ```java
       //线程不安全：
       List<Map<String,Object>> data=new ArrayList<Map<String,Object>>();
       //线程安全：
       List<Map<String,Object>> data=Collections.synchronizedList (new ArrayList<Map<String,Object>> ())
      ```

4. Vector提供了一个子类Stack，栈，先进后出，比较老，不使用。通常使用ArrayDeque代替。

   1. ArrayDeque底层基于数组，实现了List和Deque接口，性能好。

**ArrayList和 Vector还提供了如下两个方法来重新分配Object[]数组。**

1. void ensureCapacity(int minCapacity):将ArrayList或Vector集合的Object[]数组长度增加大于或等于minCapacity值。
2. void trimToSize():调整ArrayList或Vector集合的Object[]数组长度为当前元素的个数。调用该方法可减少ArrayList或 Vector集合对象占用的存储空间。

```java
        ArrayList b = new ArrayList(10);
        b.add(1);
        b.add(1);
        b.add(1);
        b.add(1);
        b.add(1);
        b.ensureCapacity(4);
        b.trimToSize();
        System.out.println(b.size());
```

### 固定长度的List

前面讲数组时介绍了一个操作数组的工具类: Arrays，该工具类里提供了asList(Object.. a)方法，该方法可以把一个数组或指定个数的对象转换成一个List集合，这个 List集合既不是ArrayList 实现类的实例，也不是 Vector实现类的实例，而是Arrays的内部类ArrayList的实例。
Arrays.ArrayList是一个固定长度的List集合，**程序只能遍历访问该集合里的元素**，**不可增加、删除该集合里的元素**。

![image-20211125211913374](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211125211913374.png)

```java
public class FixedSizeList
{
	public static void main(String[] args)
	{
		List fixedList = Arrays.asList("疯狂Java讲义"
			, "轻量级Java EE企业应用实战");
		// 获取fixedList的实现类，将输出Arrays$ArrayList   表名他是一个内部类。
		System.out.println(fixedList.getClass());
		// 使用方法引用遍历集合元素
		fixedList.forEach(System.out::println);
        
		// 试图增加、删除元素都会引发UnsupportedOperationException异常
		fixedList.add("疯狂Android讲义");
		fixedList.remove("疯狂Java讲义");
	}
}
```

## 3. Queue接口(了解，待深入)

Queue用于模拟队列这种数据结构，队列通常是指“先进先出”(FIFO）的容器。

新元素插入（offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素。

通常，队列不允许随机访问队列中的元素。

Queue接口中定义了如下几个方法。

1. void add(Object e):将指定元素加入此队列的尾部。
2. Object element():获取队列头部的元素，但是不删除该元素。
3. boolean offer(Object e):将指定元素加入此队列的尾部。当使用有容量限制的队列时，此方法通常比 add(Object e)方法更好。
4. Object peek():获取队列头部的元素，但是不删除该元素。如果此队列为空，则返回null。
5. Object poll():获取队列头部的元素，并删除该元素。如果此队列为空，则返回null。
6. Object remove():获取队列头部的元素，并删除该元素。

Queue接口有一个PriorityQueue实现类。

Queue还有一个Deque接口，Deque代表一个“双端队列”，双端队列可以同时从两端来添加、删除元素，因此 Deque 的实现类既可当成队列使用，也可当成栈使用。

Java为 Deque提供了ArrayDeque和 LinkedList两个实现类。

### PriorityQueue（优先队列）实现类

#### **推荐Blog**

1. https://www.cnblogs.com/guanghe/p/13450971.html
2. https://blog.csdn.net/ohwang/article/details/116934308
3. [(87条消息) Java PriorityQueue（优先队列）_javaZhong的博客-CSDN博客](https://blog.csdn.net/u010675669/article/details/86503464)

1. PriorityQueue不是绝对标准的队列，PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是**按队列元素的大小进行重新排序**。

2. **当调用peek()方法或者poll)方法取出队列中的元素时，并不是取出最先进入队列的元素，而是取出队列中最小的元素。违反了队列先进先出(FIFO)的基本规则。**

#### **普通使用**

```java
public class PriorityQueueTest
{
	public static void main(String[] args)
	{
		PriorityQueue pq = new PriorityQueue();
		// 下面代码依次向pq中加入四个元素
		pq.offer(6);
		pq.offer(-3);
		pq.offer(20);
		pq.offer(18);
		// 输出pq队列，并不是按元素的加入顺序排列
		System.out.println(pq); // 输出[-3, 6, 20, 18]
		// 访问队列第一个元素，其实就是队列中最小的元素：-3
		System.out.println(pq.poll());
	}
}
```

问题：

1. 直接输出集合，发现并没有按照大小排序，但是取出集合中的元素时，是从小到大取出的。
   1. 了解优先队列的底层。

PriorityQueue的元素有两种排序方式。
自然排序:采用自然顺序的 PriorityQueue集合中的元素必须实现了Comparable接口，而且应该是同一个类的多个实例，否则可能导致ClassCastException异常。

定制排序:创建PriorityQueue队列时，传入一个Comparator对象，该对象负责对队列中的所有元素进行排序。采用定制排序时不要求队列元素实现 Comparable接口。

#### **使用Comparator**

**创建Employee类**

```java
public class Employee {

    private Long id;

    private String name;

    private LocalDate dob;

    public Employee(Long id, String name, LocalDate dob) {

        super();

        this.id = id;

        this.name = name;

        this.dob = dob;

    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Override

    public String toString() {

        return "Employee [id=" + id + ", name=" + name + ", dob=" + dob + "]";

    }

    public static void main(String[] args) {
        Comparator<Employee> nameSorter = Comparator.comparing(Employee::getId);
        PriorityQueue<Employee> priorityQueue = new PriorityQueue<>(nameSorter);
        priorityQueue.add(new Employee(1l, "AAA", LocalDate.now()));
        priorityQueue.add(new Employee(4l, "CCC", LocalDate.now()));
        priorityQueue.add(new Employee(5l, "BBB", LocalDate.now()));
        priorityQueue.add(new Employee(2l, "FFF", LocalDate.now()));
        priorityQueue.add(new Employee(3l, "DDD", LocalDate.now()));
        priorityQueue.add(new Employee(6l, "EEE", LocalDate.now()));
        while(true) {
            Employee e = priorityQueue.poll();
            System.out.println(e);
            if(e == null) break;
        }
    }
}
```

#### **使用Comparable**

```java
public class Employees implements Comparable<Employees> {
    private Long id;

    private String name;

    private LocalDate dob;

    public Long getId() {
        return id;
    }

    public Employees(Long id, String name, LocalDate dob) {
        super();
        this.id = id;
        this.name = name;
        this.dob = dob;
    }
    @Override
    public int compareTo(Employees emp) {
        return this.getId().compareTo(emp.getId());
    }
    //Getters and setters
    @Override
    public String toString() {
        return "Employee [id=" + id + ", name=" + name + ", dob=" + dob + "]";
    }

    public static void main(String[] args) {
        PriorityQueue<Employees> priorityQueue = new PriorityQueue<>();
        priorityQueue.add(new Employees(1l, "AAA", LocalDate.now()));
        priorityQueue.add(new Employees(4l, "CCC", LocalDate.now()));
        priorityQueue.add(new Employees(5l, "BBB", LocalDate.now()));
        priorityQueue.add(new Employees(2l, "FFF", LocalDate.now()));
        priorityQueue.add(new Employees(3l, "DDD", LocalDate.now()));
        priorityQueue.add(new Employees(6l, "EEE", LocalDate.now()));
        while(true) {
            Employees e = priorityQueue.poll();
            System.out.println(e);
            if(e == null) break;
        }
    }

}
```

### Deque接口与ArrayDeque 实现类

Deque接口是Queue接口的子接口，它代表一个双端队列，Deque接口里定义了一些双端队列的方法，这些方法允许从两端来操作队列的元素。

1. void addFirst(Object e):将指定元素插入该双端队列的开头。
2. void addLast(Object e):将指定元素插入该双端队列的末尾。
3. lterator descendingIterator():返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。
4. Object getFirst():获取但不删除双端队列的第一个元素。Object getLast():获取但不删除双端队列的最后一个元素。
5. boolean offerFirst(Object e):将指定元素插入该双端队列的开头。
6. boolean offerLast(Object e):将指定元素插入该双端队列的末尾。
7. Object peekFirst():获取但不删除该双端队列的第一个元素;如果此双端队列为空，则返回null。
8. ObjectpeekLast():获取但不删除该双端队列的最后一个元素;如果此双端队列为空,则返回null。
9. Object pollFirst():获取并删除该双端队列的第一个元素;如果此双端队列为空，则返回null。
10. Object pollLast():获取并删除该双端队列的最后一个元素;如果此双端队列为空，则返回null。
11. Object pop()（栈方法): pop出该双端队列所表示的栈的栈顶元素。相当于removeFirst()。
12. void push(Object e)(栈方法):将一个元素 push进该双端队列所表示的栈的栈顶。相当于addFirst(e)。
13. Object removeFirst():获取并删除该双端队列的第一个元素。
14. Object removeFirstOccurrence(Object o):删除该双端队列的第一次出现的元素o。
15. Object removeLast():获取并删除该双端队列的最后一个元素。
16. boolean removeLastOccurrence(Object o):删除该双端队列的最后一次出现的元素o。

从上面方法中可以看出，Deque不仅可以当成双端队列使用，而且可以被当成栈来使用，包含了pop（出栈)、push（入栈）两个方法。

![image-20211125225508637](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211125225508637.png)

![image-20211125225528886](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211125225528886.png)

### 流的概念

```java
class Dish {
    private final String name;
    private final boolean vegetarian;
    private final int calories;
    private final Type type;

    public Dish(String name, boolean vegetarian, int calories, Type type) {
        this.name = name;
        this.vegetarian = vegetarian;
        this.calories = calories;
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public int getCalories() {
        return calories;
    }

    public Type getType() {
        return type;
    }

    @Override
    public String toString() {
        return name;
    }

    public enum Type {MEAT, FISH, OTHER}
}

public class StreamTest {
    public static void main(String[] args) {
        List<Dish> menu = Arrays.asList(
                new Dish("pork", false, 800, Dish.Type.MEAT),
                new Dish("beef", false, 700, Dish.Type.MEAT),
                new Dish("chicken", false, 400, Dish.Type.MEAT),
                new Dish("french fries", true, 530, Dish.Type.OTHER),
                new Dish("rice", true, 350, Dish.Type.OTHER),
                new Dish("season fruit", true, 120, Dish.Type.OTHER),
                new Dish("pizza", true, 550, Dish.Type.OTHER),
                new Dish("prawns", false, 300, Dish.Type.FISH),
                new Dish("salmon", false, 450, Dish.Type.FISH));
        /*要求：
         *1. 删选出calories小于400的Dish
         *2. 通过calories进行从小到大排序
         *3. 获取符合以上两种条件的name集合。
         */
        System.out.println("Java7");
        //Java7遍历
        List<Dish> lowCaloricDishes = new ArrayList<>();
        for (Dish d : menu) {
            if (d.getCalories() < 400) {
                lowCaloricDishes.add(d);
            }
        }
        Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
            public int compare(Dish d1, Dish d2) {
                return Integer.compare(d1.getCalories(), d2.getCalories());
            }
        });
        List<String> lowCaloricDishesName = new ArrayList<>();
        for (Dish d : lowCaloricDishes) {
            lowCaloricDishesName.add(d.getName());
        }
        lowCaloricDishes.forEach(System.out::println);
        System.out.println("Java8");
        //Java8
        lowCaloricDishes.stream()
                .filter(item->item.getCalories()<400)
               .sorted(Comparator.comparing(Dish::getCalories))
                .map(Dish::getName)
                .collect(Collectors.toList());
        lowCaloricDishes.forEach(System.out::println);
    }
}
```

![image-20211124113135709](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211124113135709.png)

将流操作链接起来构成流的流水线.



