# 2. Thymeleaf和域名搭建

## 1. 视图请求过程

![image-20220509201303056](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220509201303056.png)

## 2. Themleaf

### 1. 配置

1. 导入 themleaf 相关依赖

```xml
<!-- 模板引擎 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

2. 配置 关闭缓存，这样可以实时看到页面的更改

```yaml
spring:
  thymeleaf:
    cache: false
  resources:
    static-locations: classpath:/templates,classpath:static/  ///templates静态资源路径   配置，启动服务时，直接访问服务器对应地址即可自动跳转到templates下的index.html页面。   //static/ 可以直接通过浏览器访问该页面下的静态资源。
```

![image-20220509202425073](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220509202425073.png)

此时启动项目，访问项目会直接跳转到相应的index.html页面。相当于将这个页面设置成了欢迎页。

**还可以使用接口请求的方式，通过视图解析器转发到对应的页面（注意，这里有坑）**

如，我想通过访问接口，来进入index.html页面。

```java
@GetMapping(value = {"/","/index.html"})
private String indexPage(Model model) {
    //1、查出所有的一级分类
    List<CategoryEntity> categoryEntities = categoryService.getLevel1Categorys();
    model.addAttribute("categories",categoryEntities);
    return "index";
}
```

此时，配置信息需要更改，否则资源无法访问。

```xml
spring:
  thymeleaf:
    cache: false
    prefix: classpath:/templates/  # 前缀
    suffix: .html                  # 后缀
  resources:
    static-locations: classpath:/static/  
  mvc:
    static-path-pattern: /static/** # 配置mvc的静态资源路径，不配置这个，前端访问不了静态资源。（前端获取静态资源的路径是  <link rel="stylesheet" href="/static/index/css/GL.css">）
```

静态资源配置详解：[Spring Boot配置静态资源的地址与访问路径（spring.mvc.static-path-pattern和spring.web.resources.static-locations）_風の住む街~的博客-CSDN博客_spring.web.resources.static-locations](https://blog.csdn.net/weixin_38924500/article/details/109739021)

3. 引入相关资源

将静态资源导入 static 目录， 将视图页面导入 templates 目录

可以直接在浏览器通过：ip地址：端口号：静态资源路径访问服务器上面的静态资源。

如：

![image-20220509202724646](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220509202724646.png)

![image-20220509203026460](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220509203026460.png)

spring:   resources:   static-locations: classpath:templates/,classpath:static/

### 2. 自动配置原理

1. WebMvcAutoConfiguration配置类

2. 里面配置了SpringMVC的一些默认配置

3. 默认配置webjars目录

   ```java
       public void addResourceHandlers(ResourceHandlerRegistry registry) {
               if (!this.resourceProperties.isAddMappings()) {
                   logger.debug("Default resource handling disabled");
               } else {
                   Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
                   CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
                   if (!registry.hasMappingForPattern("/webjars/**")) {
                       this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{"/webjars/**"}).addResourceLocations(new String[]{"classpath:/META-INF/resources/webjars/"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                   }
   
                   String staticPathPattern = this.mvcProperties.getStaticPathPattern();
                   if (!registry.hasMappingForPattern(staticPathPattern)) {
                       this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                   }
   
               }
           }
   ```

4. 静态资源目录

   1. 如欢迎页

      ![image-20220509211427021](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220509211427021.png)

   2. this.resourceProperties.getStaticLocations()详情

   3. ```java
      @ConfigurationProperties(
          prefix = "spring.resources",
          ignoreUnknownFields = false
      )
      public class ResourceProperties {
          private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"};
          private String[] staticLocations;
      
      
          public ResourceProperties() {
              this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
          }
      ```

   4. 上述的四个目录都是默认配置的四个静态目录的路径，这些路径下的文件可以直接访问。
   5. 通过配置spring.resources.static-locations可以新添加静态路径

### 3. 默认前后缀

```java
    @GetMapping(value = {"/","index.html"})
    private String indexPage(Model model) {

        //1、查出所有的一级分类
        List<CategoryEntity> categoryEntities = categoryService.getLevel1Categorys();
        model.addAttribute("categories",categoryEntities);

        return "index";
        //返回的是  /templates/index.html
    }

```

1. 默认的前后缀

   ![image-20220509212924391](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220509212924391.png)

2. Model.addAttribute相当于把属性放到了request域中，可以在视图层获取存储在request域中的值。

### 4. thtmyleaf的详细使用

[Java项目《谷粒商城》Java架构师 | 微服务 | 大型电商项目_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1np4y1C7Yf?p=137)

**页面修改实时更新**

html相关代码修改后，刷新页面即回显最新效果

1. 引入dev-tools

   ```java
          <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-devtools</artifactId>
               <optional>true</optional>
           </dependency>
   ```

2. build project

   ![image-20220509214158680](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220509214158680.png)

3. 注意：一定要关闭thymeleaf的缓存

## 3. 业务

### 三级菜单

**数据返回格式**

![image-20220510094214608](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510094214608.png)

**controller**

```java
    @GetMapping(value = "/index/catalog.json")
    @ResponseBody
    public Map<String, List<Catelog2Vo>> getCatalogJson() {
        Map<String, List<Catelog2Vo>> catalogJson = categoryService.getCatalogJson();
        return catalogJson;
    }
```

**Catelog2Vo**

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Catelog2Vo {

    /**
     * 一级父分类的id
     */
    private String catalog1Id;

    /**
     * 三级子分类
     */
    private List<Category3Vo> catalog3List;

    private String id;

    private String name;


    /**
     * 三级分类vo
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class Category3Vo {

        /**
         * 父分类、二级分类id
         */
        private String catalog2Id;

        private String id;

        private String name;
    }

}
```

**service**

```java
    @Override
    public Map<String, List<Catelog2Vo>> getCatalogJson() {
        System.out.println("查询了数据库");

        //将数据库的多次查询变为一次
        List<CategoryEntity> selectList = this.baseMapper.selectList(null);

        //1、查出所有分类
        //1、1）查出所有一级分类
        List<CategoryEntity> level1Categorys = getParent_cid(selectList, 0L);

        //封装数据
        Map<String, List<Catelog2Vo>> parentCid = level1Categorys.stream().collect(Collectors.toMap(k -> k.getCatId().toString(), v -> {
            //1、每一个的一级分类,查到这个一级分类的二级分类
            List<CategoryEntity> categoryEntities = getParent_cid(selectList, v.getCatId());

            //2、封装上面的结果
            List<Catelog2Vo> catelog2Vos = null;
            if (categoryEntities != null) {
                catelog2Vos = categoryEntities.stream().map(l2 -> {
                    Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName().toString());

                    //1、找当前二级分类的三级分类封装成vo
                    List<CategoryEntity> level3Catelog = getParent_cid(selectList, l2.getCatId());

                    if (level3Catelog != null) {
                        List<Catelog2Vo.Category3Vo> category3Vos = level3Catelog.stream().map(l3 -> {
                            //2、封装成指定格式
                            Catelog2Vo.Category3Vo category3Vo = new Catelog2Vo.Category3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());

                            return category3Vo;
                        }).collect(Collectors.toList());
                        catelog2Vo.setCatalog3List(category3Vos);
                    }

                    return catelog2Vo;
                }).collect(Collectors.toList());
            }

            return catelog2Vos;
        }));

        return parentCid;
    }
```

**使用redis优化**

```java
   @Override
    public Map<String, List<Catelog2Vo>> getCatalogJson() {
        System.out.println("查询了数据库");
        String s = redisTemplate.opsForValue().get("catalogJSON");
        if (StringUtils.isNotEmpty(s)){
            Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDb();
            redisTemplate.opsForValue().set("catalogJSON", JSON.toJSONString(catalogJsonFromDb));
            return catalogJsonFromDb;
        }
        Map<String, List<Catelog2Vo>> stringListMap = JSON.parseObject(s, new TypeReference<Map<String, List<Catelog2Vo>>>() {
        });
        return  stringListMap;
    }
```



## 4.nginx搭建域名访问坏境

### 1. 正向代理和反向代理

![image-20220510095056221](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510095056221.png)

**正向代理：**如访问http://www.google.cn/，国内是无法直接访问的，此时我们通过vpn，帮我们代理。即发送请求到代理服务器，代理服务器帮我们请求http://www.google.cn/。在这个过程中，用户是知道要访问的网站的真实地址（http://www.google.cn/），只不过无法直接访问，需要代理服务器帮我们访问；谷歌是不知道哪个用户访问了自己，只知道代理服务器地址，不知道用户的服务器地址。

**反向代理：**项目上线后，服务器真实地址是不暴露在外界的，即在内网上，否则很容易受到攻击。此时如果用户想要访问，必须通过代理服务器，如nginx。用户通过nginx发送请求，nginx将请求服务器获取用户所需的资源返回给用户。这个过程中，nginx提供了两个ip，一个是外网ip，供用户使用。一个是内网ip，供nginx代理。用户是不知道服务器真实的地址，一切对服务器的操作都由nginx代理服务器进行。

### 2. 搭建域名访问

![image-20220510094815136](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510094815136.png)

访问流程：用户通过域名，访问到项目。在这个过程中，用户通过域名进行访问时，先通过dns解析到域名真实的ip地址，再发送请求。

但因没有购买域名，想通过访问gulimall访问到我们的项目时，可以修改本机的hosts文件。

![image-20220510100604104](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510100604104.png)

### 3. nginx配置文件

![image-20220510101927833](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510101927833.png)

nginx.conf

![image-20220510102422635](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510102422635.png)

**conf.d/default.conf**

![image-20220510102543065](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510102543065.png)

### 4.  部署服务

所有访问gulimall.com的请求，都转到商品服务。

#### 方式一：不通过网关，直接代理

![image-20220510101810355](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510101810355.png)

![image-20220510103327869](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510103327869.png)

注意：使用的是阿里云服务器，代理的是windows本地开发的地址，因此访问不到。使用本地虚拟机即可。

**使用阿里云服务器配置**

使用阿里云服务器的时，是无法直接代理到本地服务的，此时可以通过花生壳的内网穿透功能，花生壳会提供一个公网的ip供我们访问。

1. 配置花生壳

   ![image-20220510161704272](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510161704272.png)

2. 如果域名有备案，可以配置域名，否则只能通过ip地址进行访问。
   1. ![image-20220510170918522](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510170918522.png)
3. 注意：
   1. 配置nginx监听服务的端口号时，因为我们不能通过域名进行访问，所以一个配置文件只能监听一个端口号。
   2. 如果nginx上有两个端口号，我们的两个nginx配置文件都可以监听80端口，通过servername的不同来区分。
   3. 但是当项目只能通过ip访问时，两个项目不能使用同一端口号。

**问题：**商品服务有可能部署在了多台服务器，每台服务器的地址和端口号都不一样，不可能通过每次修改nginx的配置文件来配置，可以通过网关来配置。

#### 方式二：负载均衡到网关配置。

![image-20220510203550928](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510203550928.png)

1. nginx接收到请求后，将请求发送给网关（网关也可能多个），网关再动态路由到指定的服务

2. nginx配置

   1. nginx负载均衡使用文档：[Using nginx as HTTP load balancer](https://nginx.org/en/docs/http/load_balancing.html)

   2. ![image-20220510172902131](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510172902131.png)

   3. 配置网关的内网穿透

      ![image-20220510171922673](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510171922673.png)

   4. 配置上游服务器组合服务代理

      1. 上游服务器组即网关组，有几个写几个。

      ![image-20220510172203856](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510172203856.png)

      ![image-20220510172358936](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510172358936.png)

      

3. 此时请求gulimall.mfei.fun，发现404。我们请求发送到了网关，但是网关不知道要去哪里找服务，因此需要配置网关。

4. 网关配置路由规则

   1. 配置域名访问规则

   2. ![image-20220510200512075](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510200512075.png)

   3. mfei.fun下的请求都转发到	gulimall-project模块下

   4. 注意：此配置要放在所有配置的最后，因为是监听的域名。如果放到前面，请求/api/ware时，默认走的都是该转发，因为都是mfei.fun为域名进行访问的。

   5. ```java
          # 配置域名访问时，直接访问商品服务
          - id: gulimall_host_route
            uri: lb://gulimall-product
            predicates:
              - Host=**.mfei.fun           # mfei.fun下的请求都转发到	gulimall-project模块下
         
      ```

   6. 问题：此时还是404无法访问

      1. 原因：nginx代理的原因
      2. 服务由浏览器-nginx-gateway-服务。浏览器到nginx时，此时携带的Host：gulimall.mfei.fun，但是当nginx请求网关时，该Host发生了更改，因此此时是nginx访问服务。（这期间host， cookie等都可能发生更改）
      3. 解决：设置proxy_set_header HOST $host，这样nginx将不会丢失Host,表示使用当前请求的host
      3. 完成：![image-20220511144344418](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511144344418.png)




### 5. 域名映射效果。

![image-20220510203821123](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510203821123.png)

# 3. 压力测试

使用压力测试，我们有希望找到很多种用其他测试方法更难发现的错误。有两种错误类型是: **内存泄漏，并发与同步**。 

有效的压力测试系统将应用以下这些关键条件:**重复**，**并发**，**量级**，**随机变化**。

## 1. 性能指标

1. 响应时间（Response Time: RT） ：响应时间指用户从客户端发起一个请求开始，到客户端接收到从服务器端返回的响 应结束，整个过程所耗费的时间。 

2. HPS（Hits Per Second） ：每秒点击次数，单位是次/秒。 

3. TPS（Transaction per Second）：系统每秒处理交易数，单位是笔/秒

4. QPS（Query per Second）：系统每秒处理查询次数，单位是次/秒。 对于互联网业务中，如果某些业务有且仅有一个请求连接，那么 TPS=QPS=HPS，一 

   般情况下用 TPS 来衡量整个业务流程，用 QPS 来衡量接口查询次数，用 HPS 来表 示对服务器单击请求

5. 无论 TPS、QPS、HPS,此指标是衡量系统处理能力非常重要的指标，越大越好，根据经验，一般情况下：
   1. 金融行业：1000TPS~50000TPS，不包括互联网化的活动 
   2. 保险行业：100TPS~100000TPS，不包括互联网化的活动 
   3. 制造行业：10TPS~5000TPS 
   4. 互联网电子商务：10000TPS~1000000TPS 
   5. 互联网中型网站：1000TPS~50000TPS 
   6. 互联网小型网站：500TPS~10000TPS

6. 最大响应时间（Max Response Time） 指用户发出请求或者指令到系统做出反应（响应） 的最大时间。
7. 最少响应时间（Mininum ResponseTime） 指用户发出请求或者指令到系统做出反应（响 应）的最少时间。
8. 90%响应时间（90% Response Time） 是指所有用户的响应时间进行排序，第 90%的响应时间。
9. 从外部看，性能测试主要关注如下三个指标 
   1. 吞吐量：每秒钟系统能够处理的请求数、任务数。 
   2. 响应时间：服务处理一个请求一个任务的耗时。 
   3. 错误率：一批请求中结果出错的请求所占比例。

## 2. jmeter的使用

### 1. 基本使用

1. 创建线程组和报告

![image-20220511150313485](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511150313485.png)

2. 设置请求

![image-20220511150330291](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511150330291.png)

3. 报告

![image-20220511150451879](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511150451879.png)

4. 发现吞吐量较低，可以调整虚拟机内存大小来提高吞吐量

![image-20220511150614541](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511150614541.png)

### 2. Adress Already in user 错误解决

https://www.bilibili.com/video/BV1np4y1C7Yf?p=143

### 3. **分析结果,优化**

**影响性能考虑点包括**： 

数据库、应用程序、中间件（tomact、Nginx）、网络和操作系统等方面 

1. 浏览器访问--nginx--gateway--tomcat--服务

首先考虑自己的应用属于 **CPU** **密集型**还是 **IO** **密集型**

1. CPU:与计算相关，如果项目运算过程中，CPU很高，说明时CPU密集型
   1. 升级服务器，换CPU，使用多态服务
2. IO：网络IO，磁盘IO

### 4. 性能监控

#### 1. JVM内存模型

![image-20220511152520216](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511152520216.png)

![image-20220511152711651](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511152711651.png)



所有的对象实例以及数组都要在堆上分配。堆是垃圾收集器管理的主要区域，也被称为“GC 堆”；也是我们优化最多考虑的地方。 

堆可以细分为： 

1. 新生代 
   1. Eden 空间 
   2. From Survivor 空间 
   3. To Survivor 空间 
2. 老年代 
3. 永久代/元空间 
   1. Java8 以前永久代，受 jvm 管理，java8 以后元空间，直接使用物理内存。因此， 默认情况下，元空间的大小仅受本地内存限制。 

![image-20220511153109178](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511153109178.png)

#### 2. 堆的垃圾回收

![image-20220511153049990](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511153049990.png)

1. 新对象创建时，先判断**新生代**的内存是否满足，如果不满足，执行YGC，若还不满足，执行FGC，满足放入老年代，不满足则OOM异常
2. 如果伊甸园的内存不满足时，YGC执行后，会把幸存的对象尝试把对象放入S0，S0和S1来回交换，如果S0或S1中的对象生存超过阈值（好几次GC都没清除），则会进入老年代。如果YGC执行后，Eden放不下时，尝试放入S0,S1，如果都放不下，则会尝试放入老年代。
3. FULLGC非常慢，优化应用的时候，尽量避免进行FULLGC
4. 性能优化时，要时刻关注新生代和老年代的变化，来进行调优。

 #### 3. jconsole和jvisualvm

压力测试之间，监控堆里面的内存变化，以及线程数量，来监测。

##### jconsole

1. cmd，输入jconsole
2. 链接服务 gulimall-project
3. ![image-20220511154314762](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511154314762.png)
4. ![image-20220511154422780](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511154422780.png)

##### jvisualVM（功能更强）

1. cmd，输入jvisualVM
2. 用途：监控内存泄露，跟踪垃圾回收，执行时内存、cpu 分析，线程分析... 
3. 线程
   1. ![image-20220511154944355](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511154944355.png)
   2. ![image-20220511154825830](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511154825830.png)
   3. ![image-20220511154918775](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511154918775.png)
      1. 运行：正在运行的 
      2. 休眠：sleep 
      3. 等待：wait 
      4. 驻留：线程池里面的空闲线程 
      5. 监视：阻塞的线程，正在等待锁
   4. 监控内存的垃圾回收
      1. 默认监控不到，需要安装插件。
      2. ![image-20220511155202347](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511155202347.png)
      3. ![image-20220511155650115](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511155650115.png)
         1. Eden Space (99.000M,87.000M)表示伊甸园最大分配99M，实际分配87M

#### 4. JMETER测试接口

测试首页接口。首页接口的请求流程：浏览器发送请求—>nginx—>gateway—>服务器

期间经历了nginx和gateway两层中间件

##### 1. 中间件对接口的影响

###### nginx

1. 测试nginx的默认80端口。![image-20220511160227403](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511160227403.png)

2. ![image-20220511160319680](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511160319680.png)

3. ![image-20220511160402864](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511160402864.png)

4. 监控nginx的cpu使用率

   1. docker stats
   2. ![image-20220511160636115](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511160636115.png)

5. 结果

   ![image-20220511200752351](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511200752351.png)



 ###### 网关

1. ![image-20220511162748476](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511162748476.png)
2. 调整堆内大小为-Xmx300m
3. CPU和内存使用情况
   1. ![image-20220511164105426](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511164105426.png)
   2. 可以看出gateway对cpu的使用较多。
   3. ![image-20220511164223120](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511164223120.png)
   4. 发现，伊甸园内存较少，执行了好多次垃圾回收，可以通过调整伊甸园的内存大小，来减少垃圾回收的次数，节约时间。

##### 2. 简单服务

```java
    @RequestMapping("/hello")
    //@RequiresPermissions("product:spuinfo:list")
    public String hello(){
       return "hello";
    }
```

![image-20220511170114150](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511170114150.png)

![image-20220511170133031](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511170133031.png)

##### 3. gateway+简单服务

其中，gateway还经历了nacos，因此性能又大降。

![image-20220511173315252](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511173315252.png)

中间件越多，吞吐量越低

##### 4. 全链路测试（nginx+网关+简单服务）

![image-20220511173230340](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511173230340.png)

##### 5. 压测业务数据（不包含nginx和网关）

###### 1. **首页**

```java
    @GetMapping(value = {"/","/index.html"})
    private String indexPage(Model model) {
        //1、查出所有的一级分类
        List<CategoryEntity> categoryEntities = categoryService.getLevel1Categorys();
        model.addAttribute("categories",categoryEntities);
        return "index";
    }
```

![image-20220511212241620](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511212241620.png)

消耗包含数据库查询和视图渲染

###### 2. **三级菜单**

内部包含多次数据库查询

```java
@GetMapping(value = "/index/catalog.json")
@ResponseBody
public Map<String, List<Catelog2Vo>> getCatalogJson() {
    Map<String, List<Catelog2Vo>> catalogJson = categoryService.getCatalogJson();
    return catalogJson;
}
```

![image-20220511201725530](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511201725530.png)

![image-20220511201702419](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511201702419.png)

一共请求了600多次，产生了600多次gc，可见新生代内存需要调整，默认情况下，新生代占堆内存的1/3。

当前情况下，堆内存分配的时300M，新生代可用内存是90M，调节新生代内存为150M

调整后，900多次请求，产生了60多次gc，gc的数量大大减少

![image-20220511203243367](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511203243367.png)



![image-20220511203509310](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511203509310.png)

但是总的吞入量还是没有提升，原因在于业务中，多次进行了循环操作数据库的操作。

###### **3. 首页的全量数据**（对比上面的首页）

```java
    @GetMapping(value = {"/","/index.html"})
    private String indexPage(Model model) {
        //1、查出所有的一级分类
        List<CategoryEntity> categoryEntities = categoryService.getLevel1Categorys();
        model.addAttribute("categories",categoryEntities);
        return "index";
    }
```

包含页面返回的img和js等静态资源。![image-20220511204101471](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511204101471.png)

![image-20220511204058738]()

![image-20220511203857928](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511203857928.png)

因为下载了图片和css，js文件等静态资源，速度大大的降低了。

![image-20220511205104394](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511205104394.png)

##### 6. 优化

###### 1. 通过索引优化（此处主要针对压测业务数据中的首页进行优化）

如果开了thymeleaf的cache缓存，性能会略有提升，但是不明显。

![image-20220511205830266](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511205830266.png)

其它方法：数据库+索引，关闭日志打印

![image-20220511211226307](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511211226307.png)

添加索引

![image-20220511211342551](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511211342551.png)



测试

![image-20220511211528951](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511211528951.png)

最小值和最大值有所提升，但是不是很明显。

###### 2. nginx动静分离

在上面5压测业务数据中，在压测首页所有数据时，由于图片和js等静态资源都在服务器中，需要从tomcat服务器下载，造成网站的吞吐量较低，使用nginx的动静分离。

![image-20220511213355408](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511213355408.png)

将这些静态资源都放入nginx，由nginx直接将静态资源返回，不用经过后台的服务。

![image-20220511213615818](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511213615818.png)

**规则：**

1. 项目所有的静态资源，都放到nginx里面 
2. 为了区分资源是静态资源，还是需要通过服务器获取资源，规定/static/**的所有请求都由nginx直接返回。

**配置**

在gulimall.conf中添加 

```java
location /static/{
 root /usr/share/nginx/html;  # 当请求路径中包含/static/时，则去这里找资源
}
将所有静态资源上传到html下的static文件jai
```



![image-20220511222139912](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220511222139912.png)

# 4. 缓存

**哪些数据适合放入缓存？** 

1. 即时性、数据一致性要求不高的
   1. 即时性：如物流状态
   2. 数据一致性：比如更改了某个商品的分类，商品分类的数据一致性不高，晚几分钟更新redis中的数据可以理解

2. 访问量大且更新频率不高的数据（读多，写少）
   1. 商品信息

![image-20220510211507367](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510211507367.png)

**注意：**在开发中，凡是放入缓存中的数据我们都应该指定过期时间，使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致问题。

## 1. 缓存的选择

**本地缓存**

1. 使用本地缓存，直接使用公共成员HashMap进行存储。
2. 接口请求数据时，判断map中是否有数据，有的话返回，没有的话查库返回。
3. 问题：
   1. 在单机应用下没有任何问题，并且速度很快
   2. 在分布式的应用下，如果每个服务都存储一个map，如果A服务中修改了当前map中的数据，但是B服务中的得不到实时修改，下次请求负载均衡到B服务时，获取的可能还是旧的数据。
   3. ![image-20220510212358756](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510212358756.png)
4. 解决：使用分布式中间件reids解决。
   1. ![image-20220510212406057](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220510212406057.png)



## 2. redis整合

### 1. 整合redis

操作的模块为gulimall-product

**导入依赖**

```java
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

**配置**

```yml
spring:
  redis:
    host: 192.168.163.131
    port: 6379
```

**redis的自动化配置（spring提供）**

![image-20220512094044096](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220512094044096.png)

**测试**

```java
@Autowired
RedisTemplate redisTemplate;

@Test
public void testRedis(){
    Map<String, List<Catelog2Vo>> catalogJson = categoryService.getCatalogJson();
    ValueOperations valueOperations = redisTemplate.opsForValue();
    //序列化
    String cate = JSONObject.toJSONString(catalogJson);
    valueOperations.set("cateAll",cate);
    Object cateAll = valueOperations.get("cateAll");
    //反序列化
      //使用TypeReference
    Map<String, List<Catelog2Vo>> res = JSON.parseObject(String.valueOf(cateAll), new TypeReference<Map<String, List<Catelog2Vo>>>() {
    });
    System.out.println(res);
    //使用class
    HashMap<String, List<Catelog2Vo>> hashMap = JSON.parseObject(String.valueOf(cateAll), new HashMap<String, List<Catelog2Vo>>().getClass());
    System.out.println(hashMap);
}
```

### 2. redis异常

压力测试获取分类接口。

**controller**

```java
    @GetMapping(value = "/index/catalog.json")
    @ResponseBody
    public Map<String, List<Catelog2Vo>> getCatalogJson() {
        Map<String, List<Catelog2Vo>> catalogJson = categoryService.getCatalogJson();
        return catalogJson;
    }
```

**service**

```java
    @Override
    public Map<String, List<Catelog2Vo>> getCatalogJson() {
        String s = redisTemplate.opsForValue().get("catalogJSON");
        if (StringUtils.isNotEmpty(s)){
            Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDb();
            redisTemplate.opsForValue().set("catalogJSON", JSON.toJSONString(catalogJsonFromDb));
            return catalogJsonFromDb;
        }
        Map<String, List<Catelog2Vo>> stringListMap = JSON.parseObject(s, new TypeReference<Map<String, List<Catelog2Vo>>>() {
        });
        return  stringListMap;
    }
```

#### 1. 异常产生

压力测试时，出现了堆外内存异常。

![image-20220516163635456](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220516163635456.png)

原因，springboot2.0之后默认使用lettuce作为redis的客户端，它使用netty网络通信，lettuce的bug导致netty堆外内存溢出异常。

如果没有指定堆外内存，默认使用虚拟机内存作为堆外内存。假如我设置-Xmx为300时，堆外内存此时也是300。

![image-20220516164214280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220516164214280.png)

**解决方式：**

1. 设置 -Dio.netty.maxDirectMemory增大堆外内存（只能缓解，数据量大的时候还会出异常）
2. 升级lettuce客户端（不行）（具体问题在线上解决）
3. 使用jedis
   1. lettuce使用netty作为网络通信，吞吐量大
   2. jedis比较老，版本较低

lettuce和jedis操作redis的底层客户端，spring再次封装，封装成了redistemplate

![image-20220516164920342](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220516164920342.png)

#### 2. 使用jedis

```xml
      <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
          //排除lettuce
            <exclusions>
                <exclusion>
                    <groupId>io.lettuce</groupId>
                    <artifactId>lettuce-core</artifactId>
                </exclusion></exclusions>
        </dependency>
	//添加jedis
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency>
```

springboot的依赖里面包含jedis的版本依赖

![image-20220516164428885](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220516164428885.png)



### 3. 压测结果汇总

![image-20220516164704293](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220516164704293.png)

### 4. 缓存问题

以下缓存操作可能产生的问题：

```java
    @Override
    public Map<String, List<Catelog2Vo>> getCatalogJson() {
        String s = redisTemplate.opsForValue().get("catalogJSON");
        if (StringUtils.isNotEmpty(s)){
            Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDb();
            redisTemplate.opsForValue().set("catalogJSON", JSON.toJSONString(catalogJsonFromDb));
            return catalogJsonFromDb;
        }
        Map<String, List<Catelog2Vo>> stringListMap = JSON.parseObject(s, new TypeReference<Map<String, List<Catelog2Vo>>>() {
        });
        return  stringListMap;
    }
```

#### 1. 穿透

问题：有100w的请求进来，查询商品数据，假如此时这些商品都不存在，redis中没有，那么请求全都进入了数据库，某一时刻100w的请求，导致数据库压力过大崩溃。如果有人刻意利用这个漏洞，不断请求，很可能造成服务崩溃。

解决方式：null的数据在redis中存储一份，下次请求就可以走redis。为了防止之后这条数据更新又有，需要将其设定一个过期时间。（布隆过滤器）

![image-20220516170041877](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220516170041877.png)

#### 2. 雪崩

问题：100w条数据同时放入redis，并设置一样的过期时间，某一时刻，缓存全部失效，请求全部进入数据库查询

![image-20220516170414107](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220516170414107.png)

#### 3. 击穿

问题：某一高频热点key，在某一时刻失效，而此时刻有百万数据访问，此时百万请求都请求数据库，导致数据库崩溃。

解决方式：加锁，只让一个人查数据库，查到的数据放入缓存，别人拿到锁时，不再查数据库，直接查redis。

![image-20220516171125529](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220516171125529.png)

#### 4. 缓存问题解决方案

1. 穿透：返回null的时候，redis存储false的标记
2. 雪崩：设置过期时间（加随机值）
3. 击穿：加锁

### 本地锁

拿三级列表举例，三级列表的接口是经常调用的，但是该接口需要循环查多次数据库。如果将三级列表数据存入缓存，加入某一时刻同时有100w条请求访问该接口，此时可能造成数据库崩溃。

使用本地锁优化三级列表接口

**controller**

```java
//index/json/catalog.json
@GetMapping(value = "/index/catalog.json")
@ResponseBody
public Map<String, List<Catelog2Vo>> getCatalogJson() {
    Map<String, List<Catelog2Vo>> catalogJson = categoryService.getCatalogJson();
    return catalogJson;
}
```

**具体业务：**

```java
    @Override
    public Map<String, List<Catelog2Vo>> getCatalogJson() {
        //redis查询
        String res = redisTemplate.opsForValue().get("catalogJSON");
        if (StringUtils.isEmpty(res)) {
            //进行数据库查询
            Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDbWithLocalLock();
            return catalogJsonFromDb;
        }
        Map<String, List<Catelog2Vo>> stringListMap = JSON.parseObject(res, new TypeReference<Map<String, List<Catelog2Vo>>>() {});
        return stringListMap;
    }
```

1. 在进行数据库查询前加锁，防止击穿
2. 锁中进行二次数据库查询，防止在缓存已有的情况下再次查库

```java
public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithLocalLock() {
        System.out.println("查询了数据库");
        //todo 加锁，防止击穿
        synchronized (this){
            //1.进行数据库查询----(查询目的：防止多条请求同时到这里，第一条请求往redis中添加过后，之后的请求再进行数据库查询)
            String res = redisTemplate.opsForValue().get("catalogJSON");
            if (StringUtils.isNotEmpty(res)){
                Map<String, List<Catelog2Vo>> stringListMap = JSON.parseObject(res, new TypeReference<Map<String, List<Catelog2Vo>>>() {});
                return stringListMap;
            }
            //2.具体业务
            List<CategoryEntity> selectList = this.baseMapper.selectList(null);
            List<CategoryEntity> level1Categorys = getParent_cid(selectList, 0L);
            Map<String, List<Catelog2Vo>> parentCid = level1Categorys.stream().collect(Collectors.toMap(k -> k.getCatId().toString(), v -> {
                List<CategoryEntity> categoryEntities = getParent_cid(selectList, v.getCatId());
                List<Catelog2Vo> catelog2Vos = null;
                if (categoryEntities != null) {
                    catelog2Vos = categoryEntities.stream().map(l2 -> {
                        Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName().toString());
                        List<CategoryEntity> level3Catelog = getParent_cid(selectList, l2.getCatId());
                        if (level3Catelog != null) {
                            List<Catelog2Vo.Category3Vo> category3Vos = level3Catelog.stream().map(l3 -> {
                                Catelog2Vo.Category3Vo category3Vo = new Catelog2Vo.Category3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());
                                return category3Vo;
                            }).collect(Collectors.toList());
                            catelog2Vo.setCatalog3List(category3Vos);
                        }

                        return catelog2Vo;
                    }).collect(Collectors.toList());
                }
                return catelog2Vos;
            }));
            //3.存储
            //防止穿透
            if (parentCid == null) {
                redisTemplate.opsForValue().set("catalogJSON", "null", 1L, TimeUnit.HOURS);
            } else {
                //防止雪崩
                redisTemplate.opsForValue().set("catalogJSON", JSON.toJSONString(parentCid), new Random(10L).nextLong(), TimeUnit.HOURS);
            }
            return parentCid;
        }
    }
```

**加锁的内容：**

1. 确认缓存没有
2. 数据库信息的获取
3. redis存储查询的信息（如果不加锁，redis有网络消耗，可能在redis存储数据的过程中，有其他请求进来，再次进行查库操作）

![image-20220517113610426](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220517113610426.png)

**结果：**

最终只进行了一次数据库查询。

![image-20220520163604620](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220520163604620.png)



**本地锁在多台服务器下的表现**

![image-20220520170131878](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220520170131878.png)

![image-20220520170123764](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220520170123764.png)

### 分布式锁

![image-20220521145252048](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220521145252048.png)

原理：所有的服务都去一个地方占坑，占到了你就有了这把锁。

![image-20220521145637643](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220521145637643.png)

#### 1. 使用redis实现分布式锁

##### 基本原理

**思路：**

1. 请求过来时，若要进行查库，必须占有redis中的锁。
2. 占到锁后，进行数据库查询，查询完成后，释放掉之前占有的锁。

**redis占锁**

请求过来，去redis占锁，假如设置一个key，value字段。占锁时，执行set 操作，如果set成功，则说明占锁成功，如果set失败，表示key已经存在，则设置失败。

![image-20220831092033112](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831092033112.png)

![image-20220831092042768](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831092042768.png)

使用  set lock 1 NX 命令，表示如果lock不存在，则设置lock：1,否则设置失败。同时开三个redis客户端，同时执行set lock 1 NX命令。

客户端1：失败

![image-20220831092943211](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831092943211.png)

客户端2：成功

![image-20220831092949021](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831092949021.png)

客户端3：失败

![image-20220831092953812](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831092953812.png)



##### 代码

1. 请求数据

   ```java
       @Override
       public Map<String, List<Catelog2Vo>> getCatalogJson() {
           //redis查询
           String res = redisTemplate.opsForValue().get("catalogJSON");
           if (StringUtils.isEmpty(res)) {
               //进行数据库查询
               Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDbWithRedisLock();
               return catalogJsonFromDb;
           }
           Map<String, List<Catelog2Vo>> stringListMap = JSON.parseObject(res, new TypeReference<Map<String, List<Catelog2Vo>>>() {
           });
           System.out.println("缓存返回");
           return stringListMap;
       }
   
   ```

2. 如果数据在redis中不存在，则执行数据库查询操作

   ```java
       public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithRedisLock() {
           //todo 加锁，防止击穿
           Boolean hasLock = redisTemplate.opsForValue().setIfAbsent("lock", "yes");
           if (hasLock) {
               //加锁成功
               Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDb();
               //执行完毕后删除锁
               Boolean lock = redisTemplate.delete("lock");
               return catalogJsonFromDb;
           } else {
               //模拟synechionzed的自旋锁
               try {
                   //休眠100ms后重试
                   Thread.sleep(100);
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
               return getCatalogJsonFromDbWithRedisLock();
           }
       }
   ```

   问题：

   1. ```java
                  //加锁成功
                  Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDb();
                  //执行完毕后删除锁
                  Boolean lock = redisTemplate.delete("lock");
      ```

      1. 加锁成功后，执行业务代码，结果业务报错了，那么此时就不会删除锁，造成其他线程一直等待，造成死锁。

      2. 进行删锁步骤时，程序闪断，造成锁没有删除。

      3. 解决方式：为锁设置过期时间。

         ```java
           Boolean hasLock = redisTemplate.opsForValue().setIfAbsent("lock", "yes");   
                if (hasLock) {
                     //加锁成功
                     redisTemplate.expire("lock",30,TimeUnit.SECONDS);
                     Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDb();
                     Boolean lock = redisTemplate.delete("lock");
                     return catalogJsonFromDb;
                 }
         ```

         问题1：加锁操作没有保持原子性

         ![image-20220831094602503](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831094602503.png)

         解决：将设置key和过期时间设置为原子操作。

         ```java
                Boolean hasLock = redisTemplate.opsForValue().setIfAbsent("lock", "yes",30,TimeUnit.SECONDS);
         ```

         问题2：加锁成功之后，接下来执行getCatalogJsonFromDb()这个业务，执行业务的过程中有可能遇到网络阻塞（数据库连接，第三方服务调用）等等，可能花费的时间比较长，导致设置键为lock的key过期了，业务还没有执行完，此时又一个线程可能执行该方法，又创建了一个lock，那么第一个线程业务执行完，删除lock的时候，删除的就是第二个线程产生的lock，如此循环往复，可能产生问题。

         解决：

          1. 我们可以通过延长key的过期时间解决

          2. 也可以为每一个线程加lock时，生成一个uuid，当删除key的时候，判断uuid的值是否一样

             ```java
                      String uuid = UUID.randomUUID().toString();
                     Boolean hasLock = redisTemplate.opsForValue().setIfAbsent("lock", uuid,30,TimeUnit.SECONDS);
                     if (hasLock) {
                         //加锁成功
                         Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDb();
                         if (uuid.equals(redisTemplate.opsForValue().get("lock"))){
                              redisTemplate.delete("lock");
                         }
                         return catalogJsonFromDb;
                     }
             ```

         3. 问题：这样写还有一个问题，我们这样操作是先查询了redis，再通过判断来删除lock，是两步骤操作，还有可能产生问题

            1. 如果redisTemplate.opsForValue().get("lock")返回1，而uuid也是1，那么此时就要执行删除操作，但是需要注意的是，redis的操作是有网络消耗的，很可能我要执行 redisTemplate.delete("lock");的时候，此时lock过期了，而其他的线程又生成了一个lock，uuid是2，之后第一个线程又执行了redisTemplate.delete("lock")操作，那么就又把别人的key给删除了。

            2. 分析之后，我们需要把这两部操作，变为一个操作

               ```java
                if (uuid.equals(redisTemplate.opsForValue().get("lock"))){
                                redisTemplate.delete("lock");
                           }
               ```

            3. 此时就需要使用redis的lua脚本：参考：http://www.redis.cn/commands/set.html

               ![image-20220831145531786](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831145531786.png)

               lua脚本的执行，要么全成功，要么全失败，因此我们可以使用该脚本来解决删除异常的问题。

               ```shell
                 //删除锁
                               String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
                               redisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList("lock"), uuid);
               ```

            4. 问题：还有一个问题就是业务执行时间过长，业务还没有执行完成，锁过期
               1. 解决方案：锁的自动续期，在执行业务的时候getCatalogJsonFromDb();，实现锁的自动续期。

最终代码实现：

```java
    public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithRedisLock() {
        //todo 加锁，防止击穿
        String uuid = UUID.randomUUID().toString();
        Boolean hasLock = redisTemplate.opsForValue().setIfAbsent("lock", uuid,30,TimeUnit.SECONDS);
        if (hasLock) {
            //加锁成功
            Map<String, List<Catelog2Vo>> catalogJsonFromDb;
            try {
                catalogJsonFromDb = getCatalogJsonFromDb();
            }finally {
                //删除锁
                String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
                redisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList("lock"), uuid);

            }
//            if (uuid.equals(redisTemplate.opsForValue().get("lock"))){
//                 redisTemplate.delete("lock");
//            }
            return catalogJsonFromDb;
        } else {
            //模拟synechionzed的自旋锁
            try {
                //休眠100ms后重试
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            //优化：自旋前，再读一次redis，如果数据已经存储进redis，那么就不进行自旋，直接返回即可。
          String res = redisTemplate.opsForValue().get("catalogJSON");
            if (StringUtils.isEmpty(res)) {
                //进行数据库查询
                Map<String, List<Catelog2Vo>> catalogJsonFromDb = getCatalogJsonFromDbWithRedisLock();
                return getCatalogJsonFromDbWithRedisLock();
            }
          return  JSON.parseObject(res, new TypeReference<Map<String, List<Catelog2Vo>>>() {});
        }
    }
```

该方式虽然实现了分布式锁的功能，但是是我们自己写的，redis官方给并不推荐。我们可以使用redlock代替。

![image-20220831153726615](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831153726615.png)

#### 2. 使用redisson实现分布式锁

[1. 概述 · redisson/redisson Wiki (github.com)](https://github.com/redisson/redisson/wiki/1.-概述)

![image-20220831154155257](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220831154155257.png)



##### 基本使用

1. 引入依赖

   ```java
           <!-- 以后使用Redisson作为所有分布式锁 -->
           <dependency>
               <groupId>org.redisson</groupId>
               <artifactId>redisson</artifactId>
               <version>3.12.0</version>
           </dependency>
   ```

2. 创建配置类

   1. 使用单节点模式配置useSingleServer。详细配置见文档：[2. 配置方法 · redisson/redisson Wiki (github.com)](https://github.com/redisson/redisson/wiki/2.-配置方法)

   ```java
   package com.atguigu.gulimall.product.config;
   
   import org.redisson.Redisson;
   import org.redisson.api.RedissonClient;
   import org.redisson.config.Config;
   
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   
   @Configuration
   public class RedissionConfig {
   
       //所有对redission的操作都是使用Redissionclient对象。
       @Bean(destroyMethod="shutdown")
     public   RedissonClient redissonClient()  {
           Config config = new Config();
           config.useSingleServer().setAddress("redis://39.96.41.35:6379");
           config.useSingleServer().setPassword("123456");
           RedissonClient redisson = Redisson.create(config);
           return redisson;
       }
   
   }
   ```

##### 锁使用

[8. 分布式锁和同步器 · redisson/redisson Wiki (github.com)](https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器)

###### 可重入锁

可重入锁：A方法调用需要锁a，在A方法的内部调用B方法，B方法也需要锁a，A方法调用B方法时，因为此时A已经拿到了锁a，在可重锁的情况下，可以直接调用B方法。如果是不可重入锁，那么调用B方法时，必须等待A将锁a释放才可以，此时就会出现问题。

![image-20220914092319652](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914092319652.png)

获取锁时，只要锁的名字一样，就是同一把锁。

```java
@ResponseBody
    @GetMapping(value = "/hello")
    public String hello() {

        //1、获取一把锁，只要锁的名字一样，就是同一把锁
        RLock myLock = redisson.getLock("my-lock");
        //2、加锁
        myLock.lock();      //阻塞式等待。默认加的锁都是30s
        //1）、锁的自动续期，如果业务超长，运行期间自动锁上新的30s。不用担心业务时间长，锁自动过期被删掉
        //2）、加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认会在30s内自动过期，不会产生死锁问题
        // myLock.lock(10,TimeUnit.SECONDS);   //10秒钟自动解锁,自动解锁时间一定要大于业务执行时间
        //问题：在锁时间到了以后，不会自动续期
        //1、如果我们传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时就是 我们制定的时间
        //2、如果我们指定锁的超时时间，就使用 lockWatchdogTimeout = 30 * 1000 【看门狗默认时间】
        //只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】,每隔10秒都会自动的再次续期，续成30秒
        // internalLockLeaseTime 【看门狗时间】 / 3， 10s
        try {
            log.info("加锁成功，执行业务..." + Thread.currentThread().getId());
            try {
                Thread.sleep(10000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            //3、解锁  假设解锁代码没有运行，Redisson会不会出现死锁
            log.info("释放锁..." + Thread.currentThread().getId());
            myLock.unlock();
        }

        return "hello";
    }
```

加锁之后，连续发送两条请求，第一条请求释放锁后，第二条请求才能获取锁继续执行。

![image-20220914090116558](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914090116558.png)

![image-20220914091820123](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914091820123.png)

 使用lock锁，默认锁的过期时间是30s，如果锁过期，业务并没有结束，那么锁会自动续期，这是看门狗机制。

![image-20220914092233068](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914092233068.png)

```java
myLock.lock(10,TimeUnit.SECONDS);   //10秒钟自动解锁,自动解锁时间一定要大于业务执行时间 (推荐使用)
//问题：在锁时间到了以后，不会自动续期
//1、如果我们传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时就是 我们制定的时间
//2、如果我们指定锁的超时时间，就使用 lockWatchdogTimeout = 30 * 1000 【看门狗默认时间】
//只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】,每隔10秒都会自动的再次续期，续成30秒
```

指定过期时间时，看门狗不会自动续期。

![image-20220914092926031](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914092926031.png)

看门狗时间：

```java
   this.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();
```

![image-20220914093013133](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914093013133.png)

![image-20220914093300612](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914093300612.png)

###### 公平锁

默认情况下，线程是抢占锁的，公平锁是当前线程释放锁后，直接给到下一个排队的锁。线程排序执行，防饿死应用场景

![image-20220914093734608](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914093734608.png)

###### 读写锁

![image-20220914093751283](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914093751283.png)

读写锁：如果线程A在写，线程B要读，那么B必须等待A执行完毕后释放写锁，线程B才能读。如果所有的线程都在读，则不影响，如果有多个线程在写，那么需要排队执行。

```java
  /**
     * 保证一定能读到最新数据，修改期间，写锁是一个排它锁（互斥锁、独享锁），读锁是一个共享锁
     * 写锁没释放读锁必须等待
     * 读 + 读 ：相当于无锁，并发读，只会在Redis中记录好，所有当前的读锁。他们都会同时加锁成功
     * 写 + 读 ：必须等待写锁释放
     * 写 + 写 ：阻塞方式
     * 读 + 写 ：有读锁。写也需要等待
     * 只要有读或者写的存都必须等待
     * @return
     */
    @GetMapping(value = "/write")
    @ResponseBody
    public String writeValue() {
        String s = "";
        RReadWriteLock readWriteLock = redisson.getReadWriteLock("rw-lock");
        RLock rLock = readWriteLock.writeLock();
        try {
            //1、改数据加写锁，读数据加读锁
            rLock.lock();
            s = UUID.randomUUID().toString();
            ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();
            ops.set("writeValue",s);
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            rLock.unlock();
        }

        return s;
    }

    @GetMapping(value = "/read")
    @ResponseBody
    public String readValue() {
        String s = "";
        RReadWriteLock readWriteLock = redisson.getReadWriteLock("rw-lock");
        //加读锁
        RLock rLock = readWriteLock.readLock();
        try {
            rLock.lock();
            ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();
            s = ops.get("writeValue");
            try { TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rLock.unlock();
        }

        return s;
    }
```

###### 信号量

![image-20220914104230602](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914104230602.png)

![image-20220914104307503](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914104307503.png)

信号量操作的值是数字。每当acquire一次，数量就会-1，release一次，数量就会+1。

```java
/**
 * 车库停车
 * 3车位
 * 信号量也可以做分布式限流
 */
@GetMapping(value = "/park")
@ResponseBody
public String park() throws InterruptedException {

    RSemaphore park = redisson.getSemaphore("park");
    park.trySetPermits(10000);//设置信号数量
//        park.acquire();     //获取一个信号、获取一个值,占一个车位  阻塞操作，一定要获取一个值
    boolean flag = park.tryAcquire();

    if (flag) {
        //执行业务   需要注意的是，业务执行失败，是不会还原信号量的，不过可以手动的释放    park.release();
    } else {
        return "error";
    }

    return "ok=>" + flag;
}

@GetMapping(value = "/go")
@ResponseBody
public String go() {
    RSemaphore park = redisson.getSemaphore("park");
    park.release();     //释放一个车位
    return "ok";
}
```

调用park:

![image-20220914100011201](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914100011201.png)





###### 闭锁

![image-20220914104325222](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914104325222.png)

一个锁的释放，必须等待相应数量的锁释放后，才可以释放。

如放假锁门：只有所有班的人都走完了，才可以锁大门。一个五个班，需要执行五次countDown操作。

```java
    /**
     * 放假、锁门
     * 1班没人了
     * 5个班，全部走完，我们才可以锁大门
     * 分布式闭锁
     */

    @GetMapping(value = "/lockDoor")
    @ResponseBody
    public String lockDoor() throws InterruptedException {

        RCountDownLatch door = redisson.getCountDownLatch("door");
        door.trySetCount(5);
        door.await();       //等待闭锁完成

        return "放假了...";
    }

    @GetMapping(value = "/gogogo/{id}")
    @ResponseBody
    public String gogogo(@PathVariable("id") Long id) {
        RCountDownLatch door = redisson.getCountDownLatch("door");
        door.countDown();       //计数-1

        return id + "班的人都走了...";
    }
```

![image-20220914104622571](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914104622571.png)

### 缓存的一致性

数据库和redis是两个数据库，当数据库中的数据更新时，要保持redis和数据库中的数据一致。

缓存一致性的两种方案：

**双写模式**：更新数据库后，就更新redis

问题：有可能造成暂时的脏数据，一定要为缓存设立过期时间，否则脏数据有可能一致存在。

![image-20220914112050537](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914112050537.png)

**失效模式**

问题：也有可能生成脏数据，必须设置过期时间。

![image-20220914112139849](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914112139849.png)

**缓存一致性的解决方案**

![image-20220914112238454](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914112238454.png)

两个模式，如果对数据的实时性要求不高，那么添加过期时间即可。一段时间后，肯定能获取最新的数据。

如果对数据的实时性要求很高，那么就需要添加读写锁。

![image-20220914112420686](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914112420686.png)

canal更新缓存：可以通过监听mysql的binlog日志来更新redis，不好的是需要多维护一个canal服务。

canal解决数据异构：商城中，每个人推荐的内容可能都不一样，通过canal收集用户数据后，生成用户推荐表，为不同的用户推荐不同的数据。

### springcache整合redis

https://www.bilibili.com/video/BV1np4y1C7Yf?p=167

# 5. 异步

## 线程和线程池

### 创建线程的方式

1. 继承Thread

   ```java
   package com.xunqi.gulimall.search.thread;
   
   import java.util.concurrent.*;
   
   
   public class ThreadTest {
   
   
       public static void main(String[] args) throws ExecutionException, InterruptedException {
            System.out.println("main......start.....");
            Thread thread = new Thread01();
            thread.start();
            System.out.println("main......end.....");
      
      
       }
   
   
       public static class Thread01 extends Thread {
           @Override
           public void run() {
               System.out.println("当前线程：" + Thread.currentThread().getId());
               int i = 10 / 2;
               System.out.println("运行结果：" + i);
           }
       }
   
      
   }
   
   ```

2. 实现Runnable接口

   ```java
   package com.xunqi.gulimall.search.thread;
   
   import java.util.concurrent.*;
   
   
   public class ThreadTest {
   
   
       public static void main(String[] args) throws ExecutionException, InterruptedException {
            System.out.println("main......start.....");
      		 Runable01 runable01 = new Runable01();
            new Thread(runable01).start();
            System.out.println("main......end.....");
      
      
       }
   
   
       public static class Runable01 implements Runnable {
           @Override
           public void run() {
               System.out.println("当前线程：" + Thread.currentThread().getId());
               int i = 10 / 2;
               System.out.println("运行结果：" + i);
           }
       }
   
      
   }
   
   ```

3. 实现Callable接口（可以获取返回值）

   ```java
   package com.xunqi.gulimall.search.thread;
   
   import java.util.concurrent.*;
   
   
   public class ThreadTest {
   
   
       public static void main(String[] args) throws ExecutionException, InterruptedException {
            System.out.println("main......start.....");
            FutureTask<Integer> futureTask = new FutureTask<>(new Callable01());
            new Thread(futureTask).start();
           System.out.println(futureTask.get());//发生阻塞，该方法执行结束后，才会打印main,,,end,,,
            System.out.println("main......end.....");
      
      
       }
   
   
       public static class Callable01 implements Callable<Integer> {
           @Override
           public Integer call() throws Exception {
               System.out.println("当前线程：" + Thread.currentThread().getId());
               int i = 10 / 2;
               System.out.println("运行结果：" + i);
               return i;
           }
       }
      
   }
   
   ```

4. 使用线程池

   1. 使用线程池可以限制线程资源，如设置了100的线程数量，那么最多开启100条线程，如果需要更多的线程资源，需要排队使用。

   ```java
   package com.xunqi.gulimall.search.thread;
   
   import java.util.concurrent.*;
   
   
   public class ThreadTest {
    
       //注意：线程池是全局设置。
       public static ExecutorService executor = Executors.newFixedThreadPool(10);
   
       public static void main(String[] args) throws ExecutionException, InterruptedException {
      
               executor.submit(new Thread01());
       }
   
       public static class Thread01 extends Thread {
           @Override
           public void run() {
               System.out.println("当前线程：" + Thread.currentThread().getId());
               int i = 10 / 2;
               System.out.println("运行结果：" + i);
           }
       }
   }
   
   ```

   区别
   1、2不能得到返回值。3可以获取返回值1、2、3都不能控制资源
   4可以控制资源,性能稳定。

### 线程池原理

运行流程： 

1. 线程池创建，准备好 core 数量的核心线程，准备接受任务 

2. 新的任务进来，用 core 准备好的空闲线程执行。 
   1. core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队列获取任务执行 
   2. 阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量 
   3. max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自 动销毁。最终保持到 core 大小 
   4. 如果线程数开到了 max 的数量，还有新任务进来，就会使用 reject 指定的拒绝策 略进行处理 

3、所有的线程创建都是由指定的 factory 创建的。

[面试突击30：线程池是如何执行的？拒绝策略有哪些？ - 掘金 (juejin.cn)](https://juejin.cn/post/7075132214257827877#heading-0)

![image-20220914165758876](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914165758876.png)

创建线程池：

```java
    private static void threadPool() {

        ExecutorService threadPool = new ThreadPoolExecutor(
                200,
                10,
                10L,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<Runnable>(10000),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );

        //定时任务的线程池
        ExecutorService service = Executors.newScheduledThreadPool(2);
        //单线程的线程池，后台从队列获取任务，挨个执行。
        Executors.newSingleThreadExecutor();
        //core是0，所有线程都可以回收。
        Executors.newCachedThreadPool();
        //固定大小的线程池，核心线程数和最大线程数相等
        Executors.newFixedThreadPool(10);
    }
```

参数解读：

![image-20220914164629543](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914164629543.png)

```java
1. corePoolSize:核心线程数量  要保留在池中的线程数，即使它们处于空闲状态，除非设置了允许核心线程超时
2. maximumPoolSize：最大线程数量  线程池内所允许的最大线程数
3. keepAliveTime：存活时间  当线程数大于核心线程数量时，这是多余的空闲线程在终止之前等待新任务的最长时间。如果此时有11个线程，那么这个线程等待设置的时间后还没有新的任务要执行，那么多余的线程会释放。释放掉11-5=6个线程
4. unit ：时间  keepAliveTime的时间
5. workQueue：阻塞队列    用于在执行任务之前保留任务的队列。此队列将仅保存由执行方法提交的可运行任务。（如果此时线程数已经=最大线程数量，那么新创建的任务将入队列中等待）
6. threadFactory：线程工厂
7. handler：删除策略
```

面试题目：

**一个线程池**core 7 max 20 ，queue：50，**100并发进来怎么分配的；** 

先有 7 个能直接得到执行，接下来 50 个进入队列排队，在多开 13 个继续执行。现在 70 个 

被安排上了。剩下 30 个默认拒绝策略。

![image-20220914171629315](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914171629315.png)

![image-20220914200808014](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914200808014.png)

### **CompletableFuture**

参考资料：[CompletableFuture原理与实践-外卖商家端API的异步化 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html)

#### 基本使用

![image-20220914172817106](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914172817106.png)

Future 是 Java 5 添加的类，用来描述一个异步计算的结果。（复杂）

在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以 通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。 CompletableFuture 类实现了 Future 接口，所以你还是可以像以前一样通过`get`方法阻塞或 者轮询的方式获得结果，但是这种方式不推荐使用。 CompletableFuture 和 FutureTask 同属于 Future 接口的实现类，都可以获取线程的执行结果。

![image-20220914172934380](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914172934380.png)

![image-20220914172959669](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914172959669.png)

使用run 方法

```java
public class ThreadTest {

    public static ExecutorService executor = Executors.newFixedThreadPool(10);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
             System.out.println("当前线程：" + Thread.currentThread().getId());
             int i = 10 / 2;
             System.out.println("运行结果：" + i);
         }, executor);
    }}        

```

使用supply

```java
public class ThreadTest {

    public static ExecutorService executor = Executors.newFixedThreadPool(10);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
     CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
         System.out.println("当前线程：" + Thread.currentThread().getId());
         int i = 10 / 0;
         System.out.println("运行结果：" + i);
         return i;
     }, executor);
     future.get();//获取返回结果
    }}        

```

#### 异步编排

使用异步编排功能：完成时回调。

![image-20220914202510561](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914202510561.png)

![image-20220914202903520](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914202903520.png)

```java
package com.xunqi.gulimall.search.thread;

import java.util.concurrent.*;

public class ThreadTest {

    public static ExecutorService executor = Executors.newFixedThreadPool(10);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        /**
         * 方法完成后的处理
         */
         CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
             System.out.println("当前线程：" + Thread.currentThread().getId());
             int i = 10 / 0;
             System.out.println("运行结果：" + i);
             return i;
         }, executor).whenComplete((res,exception) -> {
             //虽然能得到异常信息，但是没法修改返回数据
             System.out.println("异步任务成功完成了...结果是：" + res + "异常是：" + exception);
         }).exceptionally(throwable -> {
             //可以感知异常，同时返回默认值
             return 10;
         });
        Integer res = future.get();
        System.out.println(res);//10
    }

}

```

#### handle方法

whencomplete可以感知，但是不能修改返回结果，handle可以。

```java
package com.xunqi.gulimall.search.thread;

import java.util.concurrent.*;

public class ThreadTest {

    public static ExecutorService executor = Executors.newFixedThreadPool(10);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
         /**
         * 方法执行完后端处理
         */
         CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
             System.out.println("当前线程：" + Thread.currentThread().getId());
             int i = 10 / 2;
             System.out.println("运行结果：" + i);
             return i;
         }, executor).handle((result,thr) -> {
             if (result != null) {
                 return result * 2;
             }
             if (thr != null) {
                 System.out.println("异步任务成功完成了...结果是：" + result + "异常是：" + thr);
                 return 0;
             }
             return 0;
         });
    }

}

```

#### 线程串行化

![image-20220914203433424](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914203433424.png)



1. thenApply：获取上一步结果，并有返回值
2. thenAccept：获取上一步结果，无返回值
3. thenAsync：不能获取上一步结果，无返回值

```java
package com.xunqi.gulimall.search.thread;

import java.util.concurrent.*;

public class ThreadTest {

    public static ExecutorService executor = Executors.newFixedThreadPool(10);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
      /**
         * 线程串行化
         * 1、thenRunL：不能获取上一步的执行结果
         * 2、thenAcceptAsync：能接受上一步结果，但是无返回值
         * 3、thenApplyAsync：能接受上一步结果，有返回值
         *
         */
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getId());
            int i = 10 / 2;
            System.out.println("运行结果：" + i);
            return i;
        }, executor).thenApplyAsync(res -> {
            System.out.println("apply启动了..." + res);
            return "Hello" + res;
        }, executor);
        System.out.println("main......end....." + future.get());

        CompletableFuture<Void> future1 = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getId());
            int i = 10 / 2;
            System.out.println("运行结果：" + i);
            return i;
        }, executor).thenRun(() -> {
            System.out.println("run启动了....");
        });
        System.out.println(future1);

        CompletableFuture<Void> future2 = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getId());
            int i = 10 / 2;
            System.out.println("运行结果：" + i);
            return i;
        }, executor).thenAccept((res) -> {
            System.out.println("accept启动了....");
        });
        System.out.println(future2);
    }

}

```

#### 两任务组合—都要完成

![image-20220915111620962](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915111620962.png)

两个任务必须都完成，触发该任务。 

thenCombine：组合两个 future，获取两个 future 的返回结果，并返回当前任务的返回值 

thenAcceptBoth：组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有返回值。 

runAfterBoth：组合两个 future，不需要获取 future 的结果，只需两个 future 处理完任务后， 处理该任务。

```java
    CompletableFuture<Integer> future01 = CompletableFuture.supplyAsync(() -> {
            System.out.println("线程1开始：" + Thread.currentThread().getId());
            int i = 10 / 2;
            System.out.println("线程1结束：" + i);
            return i;
        }, executor);


        CompletableFuture<Integer> future02 = CompletableFuture.supplyAsync(() -> {
            System.out.println("线程2开始：" + Thread.currentThread().getId());
            int i = 10 / 2;
            System.out.println("线程2结束：" + i);
            return i;
        }, executor);

        CompletableFuture<Integer> future03 = future01.thenCombineAsync(future02, (fn1, fn2) -> {
            System.out.println("线程3开始：" + Thread.currentThread().getId());
            return fn1 + fn2;
        }, executor);
        Integer integer = future03.get();
        System.out.println(integer);
```

结果：

![image-20220915113211691](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915113211691.png)



#### 两任务组合—完成一个

![image-20220915141128972](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915141128972.png)

![image-20220915142533012](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915142533012.png)



```java
        CompletableFuture<Integer> future01 = CompletableFuture.supplyAsync(() -> {
            System.out.println("线程1开始：" + Thread.currentThread().getId());
            int i = 10 / 2;
            System.out.println("线程1结束：" + i);
            return i;
        }, executor);


        CompletableFuture<Integer> future02 = CompletableFuture.supplyAsync(() -> {
            System.out.println("线程2开始：" + Thread.currentThread().getId());
            int i =6/ 2;
            System.out.println("线程2结束：" + i);
            return i;
        }, executor);

       CompletableFuture<Integer> future = future01.applyToEitherAsync(future02,(fn1)->{
            System.out.println(fn1);
            return 1;
        },executor);
        System.out.println(future.get());
```

#### 多任务组合

![image-20220915143956865](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915143956865.png)

```java
CompletableFuture<Integer> future01 = CompletableFuture.supplyAsync(() -> {
            System.out.println("线程1开始：" + Thread.currentThread().getId());
            int i = 10 / 2;
            System.out.println("线程1结束：" + i);
            return i;
        }, executor);


        CompletableFuture<Integer> future02 = CompletableFuture.supplyAsync(() -> {
            System.out.println("线程2开始：" + Thread.currentThread().getId());
            int i =6/ 2;
            System.out.println("线程2结束：" + i);
            return i;
        }, executor);

        CompletableFuture<Integer> future03= CompletableFuture.supplyAsync(() -> {
            System.out.println("线程3开始：" + Thread.currentThread().getId());
            int i =6/ 2;
            System.out.println("线程3结束：" + i);
            return i;
        }, executor);

        CompletableFuture<Void> allOf = CompletableFuture.allOf(future01, future02, future03);
        allOf.get();
```

#### 使用

1. **创建自定义线程池。**

   1. 自定义线程池的大小

      ```java
      @ConfigurationProperties(prefix = "gulimall.thread")
      // @Component
      @Data
      public class ThreadPoolConfigProperties {
      
          private Integer coreSize;
      
          private Integer maxSize;
      
          private Integer keepAliveTime;
      
      
      }
      ```

   2. 配置线程池

      1. 这里我直接将ThreadPoolConfigProperties以参数的形式使用，是因为我加了@EnableConfigurationProperties(ThreadPoolConfigProperties.class)该注解。
      2. 如果不想加此注解，那么ThreadPoolConfigProperties需要注册到容器中，即@Component注解需要开启。

      ```java
      @EnableConfigurationProperties(ThreadPoolConfigProperties.class)
      @Configuration
      public class MyThreadConfig {
      
      
          @Bean
          public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {
              return new ThreadPoolExecutor(
                      pool.getCoreSize(),
                      pool.getMaxSize(),
                      pool.getKeepAliveTime(),
                      TimeUnit.SECONDS,
                      new LinkedBlockingDeque<>(100000),
                      Executors.defaultThreadFactory(),
                      new ThreadPoolExecutor.AbortPolicy()
              );
          }
      
      }
      ```

   2. 业务编写

      1. 原始业务

         ![image-20220915145554118](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915145554118.png)

      2. 使用异步优化

         1. 只有获取到1，才能获取到3,4,5.

         ```java
             @Override
             public SkuItemVo item(Long skuId) throws ExecutionException, InterruptedException {
         
                 SkuItemVo skuItemVo = new SkuItemVo();
         
                 CompletableFuture<SkuInfoEntity> infoFuture = CompletableFuture.supplyAsync(() -> {
                     //1、sku基本信息的获取  pms_sku_info
                     SkuInfoEntity info = this.getById(skuId);
                     skuItemVo.setInfo(info);
                     return info;
                 }, executor);
         
         
                 CompletableFuture<Void> saleAttrFuture = infoFuture.thenAcceptAsync((res) -> {
                     //3、获取spu的销售属性组合
                     List<SkuItemSaleAttrVo> saleAttrVos = skuSaleAttrValueService.getSaleAttrBySpuId(res.getSpuId());
                     skuItemVo.setSaleAttr(saleAttrVos);
                 }, executor);
         
         
                 CompletableFuture<Void> descFuture = infoFuture.thenAcceptAsync((res) -> {
                     //4、获取spu的介绍    pms_spu_info_desc
                     SpuInfoDescEntity spuInfoDescEntity = spuInfoDescService.getById(res.getSpuId());
                     skuItemVo.setDesc(spuInfoDescEntity);
                 }, executor);
         
         
                 CompletableFuture<Void> baseAttrFuture = infoFuture.thenAcceptAsync((res) -> {
                     //5、获取spu的规格参数信息
                     List<SpuItemAttrGroupVo> attrGroupVos = attrGroupService.getAttrGroupWithAttrsBySpuId(res.getSpuId(), res.getCatalogId());
                     skuItemVo.setGroupAttrs(attrGroupVos);
                 }, executor);
         
         
                 // Long spuId = info.getSpuId();
                 // Long catalogId = info.getCatalogId();
         
                 //2、sku的图片信息    pms_sku_images
                 CompletableFuture<Void> imageFuture = CompletableFuture.runAsync(() -> {
                     List<SkuImagesEntity> imagesEntities = skuImagesService.getImagesBySkuId(skuId);
                     skuItemVo.setImages(imagesEntities);
                 }, executor);
         
                 CompletableFuture<Void> seckillFuture = CompletableFuture.runAsync(() -> {
                     //3、远程调用查询当前sku是否参与秒杀优惠活动
                     R skuSeckilInfo = seckillFeignService.getSkuSeckilInfo(skuId);
                     if (skuSeckilInfo.getCode() == 0) {
                         //查询成功
                         SeckillSkuVo seckilInfoData = skuSeckilInfo.getData("data", new TypeReference<SeckillSkuVo>() {
                         });
                         skuItemVo.setSeckillSkuVo(seckilInfoData);
         
                         if (seckilInfoData != null) {
                             long currentTime = System.currentTimeMillis();
                             if (currentTime > seckilInfoData.getEndTime()) {
                                 skuItemVo.setSeckillSkuVo(null);
                             }
                         }
                     }
                 }, executor);
         
         
                 //等到所有任务都完成
                 CompletableFuture.allOf(saleAttrFuture,descFuture,baseAttrFuture,imageFuture,seckillFuture).get();
         
                 return skuItemVo;
             }
         ```


# 6. 短信服务

如何防范短信接口被恶意调用（被刷）

[如何防范短信接口被恶意调用（被刷） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/20879468)

# 7. 订单系统

## 订单流程

![image-20220915164240802](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915164240802.png)

![image-20220915164118214](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915164118214.png)

1、订单创建与支付 

(1) 、订单创建前需要预览订单，选择收货信息等 

(2) 、订单创建需要锁定库存，库存有才可创建，否则不能创建 

(3) 、订单创建后超时未支付需要解锁库存 

(4) 、支付成功后，需要进行拆单，根据商品打包方式，所在仓库，物流等进行拆单 

(5) 、支付的每笔流水都需要记录，以待查账 

(6) 、订单创建，支付成功等状态都需要给 MQ 发送消息，方便其他系统感知订阅

2、逆向流程 

(1) 、修改订单，用户没有提交订单，可以对订单一些信息进行修改，比如配送信息， 优惠信息，及其他一些订单可修改范围的内容，此时只需对数据进行变更即可。 

(2) 、订单取消，**用户主动取消订单和用户超时未支付**，两种情况下订单都会取消订 单，而超时情况是系统自动关闭订单，所以在订单支付的响应机制上面要做支付的限时处理，尤其是在前面说的下单减库存的情形下面，可以保证快速的释放库存。 另外需要需要处理的是促销优惠中使用的优惠券，权益等视平台规则，进行相应补回给用户。 

(3) 、退款，在待发货订单状态下取消订单时，分为缺货退款和用户申请退款。如果是 全部退款则订单更新为关闭状态，若只是做部分退款则订单仍需进行进行，同时生 成一条退款的售后订单，走退款流程。退款金额需原路返回用户的账户。 

(4) 、发货后的退款，发生在仓储货物配送，在配送过程中商品遗失，用户拒收，用户 收货后对商品不满意，这样情况下用户发起退款的售后诉求后，需要商户进行退款 的审核，双方达成一致后，系统更新退款状态，对订单进行退款操作，金额原路返 回用户的账户，同时关闭原订单数据。仅退款情况下暂不考虑仓库系统变化。如果 发生双方协调不一致情况下，可以申请平台客服介入。在退款订单商户不处理的情况下，系统需要做限期判断，比如 5 天商户不处理，退款单自动变更同意退款。

## fengin远程调用问题

### 丢失请求头

![image-20220915170048787](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915170048787.png)

因为远程调用时，fengin是重新发送了一个请求，并没有吧老请求的数据同步过来，因此需要设置拦截器（RequestInterceptor），为新request添加上老请求的信息。

![image-20220915170433671](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915170433671.png)

````java
@Configuration
public class GuliFeignConfig {

    @Bean("requestInterceptor")
    public RequestInterceptor requestInterceptor() {

        RequestInterceptor requestInterceptor = new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate template) {
                //1、使用RequestContextHolder拿到刚进来的请求数据
                ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

                if (requestAttributes != null) {
                    //老请求
                    HttpServletRequest request = requestAttributes.getRequest();

                    if (request != null) {
                        //2、同步请求头的数据（主要是cookie）
                        //把老请求的cookie值放到新请求上来，进行一个同步
                        String cookie = request.getHeader("Cookie");
                        template.header("Cookie", cookie);
                    }
                }
            }
        };

        return requestInterceptor;
    }

}

````

### fengin异步调用丢失用户信息

在远程调用中，我们使用拦截器的方式，来为远程调用的请求中添加老请求的请求信息，但是使用异步调用时，发现老请求的请求信息并没有获取到。

原因：用户的请求信息都存储在了ThreadLocal中，异步调用相当于又重新开启了一个线程，因此不能获取之前线程的请求信息。

![image-20220915202112944](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915202112944.png)

老的请求信息都在主线程中存放，但是异步调用时，又重新开启了线程，因此无法获取老的请求信息。

解决方式：在异步调用的时候，将主线程的Threadlocal信息存放在新的线程中。

![image-20220915202456654](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915202456654.png)











![image-20220915163057892](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915163057892.png)

## 接口幂等性

参考资料：

#### 订单的重复提交

![image-20220915204920788](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915204920788.png)

思考：提交订单的操作，用户如果短时间内点击了多次提交，如何确保数据库中只生成一条订单信息，以及库存服务只会-1；

#### 幂等性介绍

**接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的**，不会因 为多次点击而产生了副作用；比如说支付场景，用户购买了商品支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结 果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条．．．,这就没有保证接口的幂等性。 

哪些情况需要防止：

1. 用户多次点击按钮
2. 用户页面跳转后返回
3. 微服务之间调用
   1. A服务调减库存服务，因为网络原因（假如远程调用该最长为30s），库存服务较慢，A调用超时了，但是此时A只知道库存服务调用超时，并不知道库存服务最终是否执行成功，即究竟库存有没有减，如果库存减成功，当用户再次调用接口时，会不会再次减库存。

![image-20220915204025015](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220915204025015.png)

针对于  insert into user  (userid，name),userid不是主键的情况，如果想要保持幂等，可以给userid设置一个唯一约束。

#### 幂等性解决方案

#### token机制

1. 进入提交订单页面，后台生成一个验证码，存放到redis中

2. 提交订单前，需要输入验证码，提交订单时，验证码和订单一起提交。

3. 提交时，先判断redis中有无验证码，有的话即正常提交，删除redis验证码，执行逻辑。无得话说明验证码已被删除，或者绕过验证提交，拒绝订单提交。

   1. 判断验证码是否存在

   2. 存在，即对比redis和用户传入的验证码是否相同

   3. 相同的话则删除redis中的验证码，执行后续业务，不同的话则拒绝执行业务

   4. 注意：以上三步操作是原子操作，需要使用luna脚本。

   5. ```java
      if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end

业务编写：

服务端生成验证码：

```java
//为用户设置一个token，三十分钟过期时间（存在redis）
String token = UUID.randomUUID().toString().replace("-", "");
redisTemplate.opsForValue().set(USER_ORDER_TOKEN_PREFIX+memberResponseVo.getId(),token,30, TimeUnit.MINUTES);
confirmVo.setOrderToken(token);
```

提交订单业务：

```java
        //1、验证令牌是否合法【令牌的对比和删除必须保证原子性】
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        String orderToken = vo.getOrderToken();

        //通过lure脚本原子验证令牌和删除令牌
        Long result = redisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class),
                Arrays.asList(USER_ORDER_TOKEN_PREFIX + memberResponseVo.getId()),
                orderToken);

        if (result == 0L) {
            //令牌验证失败
            responseVo.setCode(1);
            return responseVo;
        } else {
            //令牌验证成功
        }
```



#### 锁机制

![image-20220916102012342](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916102012342.png)

![image-20220916102025740](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916102025740.png)

#### 唯一约束

![image-20220916102124993](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916102124993.png)

![image-20220916102253590](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916102253590.png)

## 本地事务在分布式事务下的问题

下单后，需要远程调用锁库存和用户积分服务。如果在远程调用过程中，远程服务出现了异常，或者远程服务超时，订单服务不知道远程服务是否成功执行，此时并不能确定事务是否需要回滚。

![image-20220916104643400](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916104643400.png)

三个服务：

1. 订单服务
2. 库存服务
3. 积分服务

订单服务，远程调用库存服务和基本服务，三个服务都加了自己本地事务。

情况一：

1. 订单服务还未调用库存服务和积分服务，订单服务失败回滚——>正常
2. 订单服务远程调用库存服务，库存服务失败回滚，订单服务收到异常后，也回滚——>正常
3. 订单服务远程调用库存服务，服务调用成功，但是受到网络波动，即库存服务执行成功，也成功锁定了库存，但是花费了50s，但是订单服务的远程调用最大可接受的时间是30s，此时订单服务受到异常消息，订单服务回滚，但是库存服务并不会回滚，导致下单失败，但是成功减了库存——>失败
4. 库存服务异常，调用积分服务失败，此时回滚，但是库存服务是远程调用，已经成功了，不会回滚，订单服务回滚，此时又造成下单失败，但是成功减了库存——>失败

### 本地事务

 事务的传播行为

![image-20220916105545094](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916105545094.png)

需要注意的是，在spring中，事务的调用是通过代理对象调用的，在本类中直接调用b和c方法，事务是不生效的，因为没有使用代理对象，直接调用b，c相当于把b,c的代码复制到a中，并不会走b，c的代理。如果b，c方法在其他service中，这样调用是生效的。

解决：使用aop，创建代理对象调用本类的方法。

1.  引入依赖  

   ```java
           <!-- 引入aop -->
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-aop</artifactId>
           </dependency>
   ```

   2. 他里面有aspectj代理，替代jdk动态代理，使用aspectj代理，及时没有接口也可以创建代理对象

2. @EnableAspectJAutoProxy：开启aspectj动态代理功能，以后的所有动态代理都是由aspectj创建

3. 使用代理对象调用bc方法，解决在本类中调用事务方法不生效。

4. 使用AopContext.currentProxy来获取当前类的代理对象。

   ![image-20220916110631700](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916110631700.png)

### 分布式事务

![image-20220916144550372](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916144550372.png)

#### CAP定理

![image-20220916141414858](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916141414858.png)

只有CP和AP系统，不可能三者兼备或CA系统。

分区容错性是必须有的，在P的情况下，在保持一致性的条件下，如果去保持可用性，那么如果三个服务，其中两个服务的A=1，那么第三个服务断了，如果三个条件都满足，那么必须等到第三个服务恢复后，把A=1更新上，此时才满足三个服务。

在p的情况下，保持可用性的条件下，如果三个服务有一个服务断了，那么申请所有服务A=2的时候，在线的两个服务可以成功，但是第三个服务断了，A还是=1，因此无法保证一致性。

![image-20220916144652668](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916144652668.png)

![image-20220916141827667](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916141827667.png)

[Raft (thesecretlivesofdata.com)](http://thesecretlivesofdata.com/raft/)

节点有三种状态：

1. 随从
2. 候选人
3. 领导

#### Base理论

![image-20220916144838656](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916144838656.png)

#### 一致性

![image-20220916144917142](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916144917142.png)

#### 分布式事务的几种方案

##### 2PC模式（刚性事务）

分为两个阶段，假如有服务A和服务B分别是两个事务，两个服务执行完可以提交事务时，先向事务管理器发送一个预备指令，当事务管理器收到两个服务可以提交事务的命令后，就向两个服务发出可以提交事务的指令，服务A和服务B都提交事务，依次来保证事务提交。

如果事务A和事务B其中有一个产生失败，没有发出预备指令，那么事务管理器则认为两个服务失败，通知两个服务回滚事务。



特点：简单，但是性能不理想。



![image-20220916145201574](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916145201574.png)

##### **柔性事务-TCC 事务补偿型方案** 

 两个业务，服务A和服务B，分别操作两个数据库，开发人员编写三段代码，try，confirm，cancel。

try：准备资源  +2

confirm：提交

cancel：回滚   -2

第一阶段：主服务让各个阶段提供try模块代码

第二阶段：主服务让各个阶段提供commit模块代码

如果第二阶段执行成功，则提交事务。如果失败，则执行第三阶段。



![image-20220916145343990](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916145343990.png)

##### **柔性事务-最大努力通知型方案**

服务A中远程调用服务B和服务C，如果服务A失败了，会尽最大努力通知服务B和服务C，两个子服务收到后，执行相应的回滚。

为了避免消息收不到，可以隔一段时间通知一次。

![image-20220916145430192](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916145430192.png)

##### **柔性事务-可靠消息+最终一致性方案（异步确保型）** 

和最大努力通知一样。

![image-20220916145535307](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916145535307.png)

### seata的使用

[springcloud整合分布式事务(seata) - 简书 (jianshu.com)](https://www.jianshu.com/p/f699b3b558bd)

[289、商城业务-分布式事务-Seata分布式事务体验_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1np4y1C7Yf?p=290&vd_source=383642096a66f0385ac22b0096523696)

![image-20220916200341641](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916200341641.png)

问题：

如果使用seata的AT模式，并不适用于下订单这样的高并发场景，对于创建sku业务（其中也包含一些远程调用）或者是并发要求不高的业务，可以使用seata。

对于高并发场景，可以配合消息队列使用。后台管理系统的一些简单场景，推荐使用seata的AT模式。

### 消息队列优化下订单服务

**订单服务**

下单服务中，需要远程调用库存服务。此时发送消息到消息队列，消息过期时间为40分钟。（如果下单成功，单子过期时间为30分钟）。

库存服务受到消息后，判断该订单是否在订单记录表中存在，如果存在，说明订单成功交易，下单正常。如果订单不存在，说明下单失败，订单并没有产生，则将减去的库存重新加上去。

**如果使用定时任务，来定时轮询订单，会造成一个很大的问题就是时间误差。如果设置每30分钟运行一次，而一个订单在定时任务执行一分钟后下单了，定时任务再次执行时，该订单才产生29分钟，因此不会处理，只有定时任务再次轮询时，此时该订单已经创建了59分钟了，才会处理该订单。**

![image-20220916171206162](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916171206162.png)

使用消息队列时，可以给队列设置一个过期时间，这样进入到这个队列的所有消息，过期时间都是一样的。当然，也可以给每个消息分别设置一个过期时间，但是rabbitmq的消费机制是惰性的，如果第一条消息过期时间是10分钟，第二条消息消费时间是1分钟，消费时，看到第一条消息是十分钟后才过期的，此时消费者会10分钟之后再来取该消息，第二条一分钟过期的消息只有在第一条消息消费后，才可以继续消费。

#### 下单后，30分钟后如果还未支付，自动关闭订单

![image-20220916172642014](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916172642014.png)

```java
@Configuration
public class MyRabbitMQConfig {

    /* 容器中的Queue、Exchange、Binding 会自动创建（在RabbitMQ）不存在的情况下 */

    /**
     * 死信队列
     *
     * @return
     */@Bean
    public Queue orderDelayQueue() {
        /*
            Queue(String name,  队列名字
            boolean durable,  是否持久化
            boolean exclusive,  是否排他
            boolean autoDelete, 是否自动删除
            Map<String, Object> arguments) 属性
         */
        HashMap<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "order-event-exchange");
        arguments.put("x-dead-letter-routing-key", "order.release.order");
        arguments.put("x-message-ttl", 60000); // 消息过期时间 1分钟
        Queue queue = new Queue("order.delay.queue", true, false, false, arguments);

        return queue;
    }

    /**
     * 普通队列
     *
     * @return
     */
    @Bean
    public Queue orderReleaseQueue() {

        Queue queue = new Queue("order.release.order.queue", true, false, false);

        return queue;
    }

    /**
     * TopicExchange
     *
     * @return
     */
    @Bean
    public Exchange orderEventExchange() {
        /*
         *   String name,
         *   boolean durable,
         *   boolean autoDelete,
         *   Map<String, Object> arguments
         * */
        return new TopicExchange("order-event-exchange", true, false);

    }


    @Bean
    public Binding orderCreateBinding() {
        /*
         * String destination, 目的地（队列名或者交换机名字）
         * DestinationType destinationType, 目的地类型（Queue、Exhcange）
         * String exchange,
         * String routingKey,
         * Map<String, Object> arguments
         * */
        return new Binding("order.delay.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.create.order",
                null);
    }

    @Bean
    public Binding orderReleaseBinding() {

        return new Binding("order.release.order.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.release.order",
                null);
    }


}
```

消费者：

![image-20220916202449628](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916202449628.png)

生产者：

![image-20220916202555622](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916202555622.png)

配置：

```java
@Configuration
public class MyRabbitConfig {

    private RabbitTemplate rabbitTemplate;

    @Primary
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        this.rabbitTemplate = rabbitTemplate;
        rabbitTemplate.setMessageConverter(messageConverter());
        initRabbitTemplate();
        return rabbitTemplate;
    }

    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    /**
     * 定制RabbitTemplate
     * 1、服务收到消息就会回调
     *      1、spring.rabbitmq.publisher-confirms: true
     *      2、设置确认回调
     * 2、消息正确抵达队列就会进行回调
     *      1、spring.rabbitmq.publisher-returns: true
     *         spring.rabbitmq.template.mandatory: true
     *      2、设置确认回调ReturnCallback
     *
     * 3、消费端确认(保证每个消息都被正确消费，此时才可以broker删除这个消息)
     *
     */
    // @PostConstruct  //MyRabbitConfig对象创建完成以后，执行这个方法
    public void initRabbitTemplate() {

        /**
         * 1、只要消息抵达Broker就ack=true
         * correlationData：当前消息的唯一关联数据(这个是消息的唯一id)
         * ack：消息是否成功收到
         * cause：失败的原因
         */
        //设置确认回调
        rabbitTemplate.setConfirmCallback((correlationData,ack,cause) -> {
            System.out.println("confirm...correlationData["+correlationData+"]==>ack:["+ack+"]==>cause:["+cause+"]");
        });


        /**
         * 只要消息没有投递给指定的队列，就触发这个失败回调
         * message：投递失败的消息详细信息
         * replyCode：回复的状态码
         * replyText：回复的文本内容
         * exchange：当时这个消息发给哪个交换机
         * routingKey：当时这个消息用哪个路邮键
         */
        rabbitTemplate.setReturnCallback((message,replyCode,replyText,exchange,routingKey) -> {
            System.out.println("Fail Message["+message+"]==>replyCode["+replyCode+"]" +
                    "==>replyText["+replyText+"]==>exchange["+exchange+"]==>routingKey["+routingKey+"]");
        });
    }
}

```



总体流程图：

![image-20220916172715962](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916172715962.png)

#### 下单后，订单异常，库存自动解锁

**库存服务**

锁定库存成功，说明下单成功，库存可以减去。

库存解锁，说明下单失败，已经减去的库存需要加上。

![image-20220916203252723](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220916203252723.png)

库存解锁场景：

1. 下订单成功，订单过期没有支付或用户手动提交都要解锁库存
2. 下订单成功，库存锁定成功，其他调用或代码出现异常，造成订单回滚，因为库存服务为远程调用，因此库存服务不会回滚。此时就需要解锁库存。

#### 如何防止消息丢失

![image-20220917142053147](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917142053147.png)

1. 发送消息异常

   1. 消息发送时，使用try，catch捕获异常，如果出现异常，将消息信息持久化到数据库。

      日志记录表

      ```java
      CREATE TABLE `mq_message` ( `message_id` char(32) NOT NULL, `content` text, `to_exchane` varchar(255) DEFAULT NULL, `routing_key` varchar(255) DEFAULT NULL, `class_type` varchar(255) DEFAULT NULL, `message_status` int(1) DEFAULT '0' COMMENT '0-新建 1-已发送 2-错误抵达 3-已抵达', `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`message_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
      ```

   2. 使用定时任务，定时扫描数据库中未消费的消息

2. 消息抵达broke

   1. 设置抵达队列的回调

3. 消息确认机制

   1. publisher ，consumer  手动ack 。 生产者和消费者都要确认。

#### 如何防止消息重复

![image-20220917143725550](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917143725550.png)

#### 消息积压

![image-20220917144011018](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917144011018.png)

上线专门的队列消费服务：将所有的消息取出来，存到数据库中，然后一条一条的执行处理。

## 订单接口总设计思路

订单接口所涉及的业务：

![image-20220917145954950](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917145954950.png)

问题：

1. 幂等性问题（订单多次下单）
2. 事务问题（远程服务调取成功，后续执行本地服务代码时，出现异常，本地代码回滚，远程服务没有回滚）
3. 消息的可靠性

### 幂等性问题

**幂等性问题解决：**

进入提交订单页面（购物车页面）时，回显购物车数据的时候顺便在redis中生成一个当前用户下单的唯一标识，当用户提交订单时，需要将此标识携带。

提交订单逻辑中，先判断redis中是否存在该唯一标识，存在即可继续执行，不存在则提示用户下单失败，请重试等操作。

**其他解决方案：**

前端解决方案：

1. 点击提交后，禁用按钮
2. 防抖和节流：[中二Devil的个人博客 (z2devil.cn)](https://z2devil.cn/article/103/detail)
3. 消息的可靠性

后端解决方案：

https://www.zhihu.com/question/324268535

防重和幂等：防重指的是防止重复提交，幂等指的是多次请求如一次，简单说，就是防重可以给对重复请求抛异常，幂等是对重复的请求响应第一次的结果，在我们讨论的这个场景里，幂等就是响应唯一的订单号。

### 分布式事务

远程服务调取成功，后续执行本地服务代码时，出现异常，本地代码回滚，远程服务没有回滚。可以使用seata分布式事务的解决方案解决，但是seata的解决效率偏低，适用于后台但是并不适用于高并发场景，对于高并发场景，可以使用消息队列。

![image-20220917163648335](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917163648335.png)

库存在订单解锁前，

![image-20220917223746556](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917223746556.png)

消息队列的总设计

![image-20220917163804595](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917163804595.png)

#### 如何防止消息丢失

![image-20220917142053147](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917142053147.png)

1. 发送消息异常

   1. 消息发送时，使用try，catch捕获异常，如果出现异常，将消息信息持久化到数据库。

      日志记录表

      ```java
      CREATE TABLE `mq_message` ( `message_id` char(32) NOT NULL, `content` text, `to_exchane` varchar(255) DEFAULT NULL, `routing_key` varchar(255) DEFAULT NULL, `class_type` varchar(255) DEFAULT NULL, `message_status` int(1) DEFAULT '0' COMMENT '0-新建 1-已发送 2-错误抵达 3-已抵达', `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`message_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
      ```

   2. 使用定时任务，定时扫描数据库中未消费的消息

2. 消息抵达broke

   1. 设置抵达队列的回调

3. 消息确认机制

   1. publisher ，consumer  手动ack 。 生产者和消费者都要确认。

#### 如何防止消息重复

![image-20220917143725550](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917143725550.png)

#### 消息积压

![image-20220917144011018](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917144011018.png)

上线专门的队列消费服务：将所有的消息取出来，存到数据库中，然后一条一条的执行处理。

# 8. 支付

## 秘钥

### 对称加密和非对称加密

![image-20220917201832234](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917201832234.png)

不安全：发送方或者接收方秘钥泄露，会造成破解。

![image-20220917201812712](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917201812712.png)

较安全，发送方加密的数据，接收方需要用另一把钥匙解密，接收方给发送方发消息时，使用的是另外两把要是，除非四把钥匙都被破解，不然信息很难泄露。

非对称加密经常用于金融领域。

### 什么是公钥、私钥、加密、签名和验签？

![image-20220917202742588](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917202742588.png)

![image-20220917202811320](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917202811320.png)

![image-20220917202840225](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917202840225.png)

 ### 业务中加密流程

![image-20220917203947743](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917203947743.png)

### 收单操作

1. 如果下完订单后，进入支付页面，但是一直等待不支付，30分钟后，订单取消了，此时取支付。仍然是可以支付成功的。但是此时订单已经取消了。
2.  如果订单30m过期，在29m最后一刻时，我点击了付款，此时还未收到支付宝支付成功的回调，订单取消成功后，支付宝此时才传递回支付成功的回调，相当于订单取消了，但是用户又支付了。
   1. 解决方式，订单自动取消时，可以主动调用支付宝的收单接口
      1. 争议：此时还有可能造成支付宝的成功还没有接收到，但是又调用了支付宝的收单接口，相当于还是产生了上述问题。

![image-20220917222902185](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220917222902185.png)

相关api可以去支付宝开放平台获取。

[支付宝开放平台 - 能力详情 (alipay.com)](https://open.alipay.com/api/detail?code=I1080300001000041203)

![image-20220918114022958](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220918114022958.png)

对账问题：

可以使用定时任务，在服务闲的时候，进行对账操作。



# 9. 秒杀业务

## 秒杀物品上架

### 上架流程

秒杀业务瞬时流量较大，通常独立一个服务。

![image-20220918115000270](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220918115000270.png)

随机码：如果要秒杀id为1的商品，直接传shop/1,如果用户更换1为2，那么就秒杀了二号商品。引入随机码，防止用户恶意秒杀。用户秒杀物品的时候，还需携带当前用户的随机码。

用户秒杀订单时，需要传递订单id以及随机码，然后我们程序拿着订单id去redis中判断随机码是否正确，如果正确的话，则拿着随机码去redis中进行减库存操作。

![image-20220918170613118](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220918170613118.png)

秒杀高并发访问，不能每次都去查数据库，而是把数据存储到缓存中。

今天12：00要上架A商品，10:0的时候用定时任务扫描需要上架的商品，将商品信息放入redis中。

1. 查出近三天所要开展的活动
2. 查询这些活动所要上架的商品
3. 商品和活动信息保存到redis中
4. 设置信号量，为秒杀物品的个数。 
5. 为定时任务加锁，防止任务被多次调用。（分布式锁）

### 定时任务在集群下的问题

  问题：使用定时任务执行代码时，如果是集群，那么每个服务都会执行定时任务，造成任务重复执行。

![image-20220918160900388](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220918160900388.png)

假如A2先获取锁执行，其他服务执行定时任务代码时，发现商品信息在redis中已存在，结束方法即可。

![image-20220918162402572](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220918162402572.png)

## 秒杀关注的问题

![image-20220919105336883](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919105336883.png)

![image-20220919110019226](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919110019226.png)

1. 秒杀业务单独一个服务
2. 使用随机码，只有秒杀开始的时候，才能获得到随机码，进行秒杀。如果在秒杀活动开始前，是获取不到随机码的，不能提前抢购
3. 库存预热：秒杀活动开始前，将商品库存提前放入redis中，并使用信号量控制。
4. 动静分离：图片等静态资源都存放入nginx
5. 恶意请求拦截：抢购商品必须登录
6. 流量错峰：
7. 限流，熔断，降级：
8. 队列削峰：秒杀成功，创建订单，订单的执行在消息队列中靠订单服务执行

## 开始抢购

### 抢购流程：

![image-20220919112302217](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919112302217.png)

整个抢购流程，没有使用到数据库，大大增加了服务器的吞吐量，用户抢购成功后，直接将消息发送到消息队列，让订单服务慢慢消费。这边直接提示用户抢购成功，让用户支付即可。缺点：订单服务如果炸的话，可能导致订单业务没法执行。

还有一种方案是，抢购兼容正常商品的一个下单逻辑，走正常的提交订单，减库存等操作。缺点是需要服务需要远程调用，比较耗时。

**立即抢购传递参数：场次id和物品id（1—10），随机码，数量**

```java
    @GetMapping(value = "/kill")
    public String seckill(@RequestParam("killId") String killId,
                          @RequestParam("key") String key,
                          @RequestParam("num") Integer num,
                          Model model) {

        String orderSn = null;
        try {
            //1、判断是否登录
            orderSn = seckillService.kill(killId,key,num);
            model.addAttribute("orderSn",orderSn);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "success";
    }


    @Override
    public String kill(String killId, String key, Integer num) throws InterruptedException {

        long s1 = System.currentTimeMillis();
        //获取当前用户的信息
        MemberResponseVo user = LoginUserInterceptor.loginUser.get();

        //1、获取当前秒杀商品的详细信息从Redis中获取
        BoundHashOperations<String, String, String> hashOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);
        String skuInfoValue = hashOps.get(killId);
        if (StringUtils.isEmpty(skuInfoValue)) {
            return null;
        }
        //(合法性效验)
        SeckillSkuRedisTo redisTo = JSON.parseObject(skuInfoValue, SeckillSkuRedisTo.class);
        Long startTime = redisTo.getStartTime();
        Long endTime = redisTo.getEndTime();
        long currentTime = System.currentTimeMillis();
        //判断当前这个秒杀请求是否在活动时间区间内(效验时间的合法性)
        if (currentTime >= startTime && currentTime <= endTime) {

            //2、效验随机码和商品id
            String randomCode = redisTo.getRandomCode();
            String skuId = redisTo.getPromotionSessionId() + "-" +redisTo.getSkuId();
            if (randomCode.equals(key) && killId.equals(skuId)) {
                //3、验证购物数量是否合理和库存量是否充足
                Integer seckillLimit = redisTo.getSeckillLimit();

                //获取信号量
                String seckillCount = redisTemplate.opsForValue().get(SKU_STOCK_SEMAPHORE + randomCode);
                Integer count = Integer.valueOf(seckillCount);
                //判断信号量是否大于0,并且买的数量不能超过库存
                if (count > 0 && num <= seckillLimit && count > num ) {
                    //4、验证这个人是否已经买过了（幂等性处理）,如果秒杀成功，就去占位。userId-sessionId-skuId
                    //SETNX 原子性处理
                    String redisKey = user.getId() + "-" + skuId;
                    //设置自动过期(活动结束时间-当前时间)
                    Long ttl = endTime - currentTime;
                    Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(redisKey, num.toString(), ttl, TimeUnit.MILLISECONDS);
                    if (aBoolean) {
                        //占位成功说明从来没有买过,分布式锁(获取信号量-1)
                        RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + randomCode);
                        //TODO 秒杀成功，快速下单
                        //使用100ms来尝试拿信号量，100ms内拿到即成功，拿不到则说明信号量没有或网络阻塞了，当成失败处理。
                        boolean semaphoreCount = semaphore.tryAcquire(num, 100, TimeUnit.MILLISECONDS);
                        //保证Redis中还有商品库存
                        if (semaphoreCount) {
                            //创建订单号和订单信息发送给MQ
                            // 秒杀成功 快速下单 发送消息到 MQ 整个操作时间在 10ms 左右
                            String timeId = IdWorker.getTimeId();
                            SeckillOrderTo orderTo = new SeckillOrderTo();
                            orderTo.setOrderSn(timeId);
                            orderTo.setMemberId(user.getId());
                            orderTo.setNum(num);
                            orderTo.setPromotionSessionId(redisTo.getPromotionSessionId());
                            orderTo.setSkuId(redisTo.getSkuId());
                            orderTo.setSeckillPrice(redisTo.getSeckillPrice());
                            rabbitTemplate.convertAndSend("order-event-exchange","order.seckill.order",orderTo);
                            long s2 = System.currentTimeMillis();
                            log.info("耗时..." + (s2 - s1));
                            return timeId;
                        }
                    }
                }
            }
        }
        long s3 = System.currentTimeMillis();
        log.info("耗时..." + (s3 - s1));
        return null;
    }
```

![image-20220919114241389](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919114241389.png)

### sentinel

![image-20220919143843352](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919143843352.png)

```xml
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
        </dependency>
```

监控图表：

![image-20220919143734766](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919143734766.png)

引入这个依赖，sentinel展示图表信息。

配置信息：

![image-20220919143816952](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919143816952.png)

**熔断配置**

使用熔断保护时，需要配置开启fengin的熔断保护

![image-20220919151440985](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919151440985.png)

![image-20220919150011725](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919150011725.png)

![image-20220919150019136](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919150019136.png)

![image-20220919151211541](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919151211541.png)

熔断：发生在调用方，可以设置策略，调用几次不成功就不调用了。

降级：发生在提供方，设置策略，单位时间内失败几次，就不提供服务了，走提供方的默认方法。

**自定义受保护的资源**

![image-20220919152320150](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919152320150.png)

### 网关流控

在网关模块引入

![image-20220919152505697](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919152505697.png)

在网关层进行接口的拦截，请求就不需要进入我们的系统。

定制请求失败时的返回信息：

![image-20220919205429253](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220919205429253.png)



**核心：**

加锁保证原子性

删锁保证原子性

### 待学习

穿透的解决方案：布隆过滤器

