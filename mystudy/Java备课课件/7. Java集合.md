# Java集合

## 0. 热身

```java
package lession11_26;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @Classname ListMain
 * @Description TODO
 * @Date 2021/11/26 13:25
 * @Created by DELL
 */
class SuperMan {
    private String name;
    private String idcard;
    private int age;
    private char sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIdcard() {
        return idcard;
    }

    public void setIdcard(String idcard) {
        this.idcard = idcard;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "SuperMan{" +
                "name='" + name + '\'' +
                ", idcard='" + idcard + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SuperMan superMan = (SuperMan) o;
        if (age != superMan.age) return false;
        if (sex != superMan.sex) return false;
        if (name != null ? !name.equals(superMan.name) : superMan.name != null) return false;
        return idcard != null ? idcard.equals(superMan.idcard) : superMan.idcard == null;
    }

//    @Override
//    public int hashCode() {
//        int result = name != null ? name.hashCode() : 0;
//        result = 31 * result + (idcard != null ? idcard.hashCode() : 0);
//        result = 31 * result + age;
//        result = 31 * result + (int) sex;
//        return result;
//    }
}

public class ListMain {
    public static void main(String[] args) {
        ArrayList arr = new ArrayList(10);
       // 操作Java提供的常用类。
        Integer a = 1;
        Boolean b = true;
        String str = "123456";
        arr.add(a);
        arr.add(b);
        arr.add(str);
        arr.get(0);
        arr.get(1);
        arr.get(2);
        arr.remove(true);
        arr.set(0, 500);
//        arr.set(10,800);  报错
        //往集合中添加SuperMan元素
         SuperMan superMan = new SuperMan();
         superMan.setName("绿巨人");
         superMan.setAge(18);
         superMan.setSex('男');
         superMan.setIdcard("1234567");
         arr.add(superMan);
        for (int i = 1; i <= 10; i++) {
            SuperMan man = new SuperMan();
            man.setName("绿巨人"+i);
            man.setAge(i);
            man.setSex('男');
            man.setIdcard("1928424"+"编号"+i);
            arr.add(man);
        }
        SuperMan man = new SuperMan();
        man.setName("绿巨人"+1);
        man.setAge(1);
        man.setSex('男');
        man.setIdcard("1928424"+"编号"+1);
        arr.add("sdihfkdsjfhkjs");
        System.out.println(arr.contains(man));
       System.out.println(arr);
       //使用泛型，规定集合中所存储的数据类型
        ArrayList<SuperMan> arrs = new ArrayList<>();
        for (int i = 1; i <= 10; i++) {
            SuperMan man1 = new SuperMan();
            man1.setName("绿巨人" + i);
            man1.setAge(i);
            man1.setSex('男');
            man1.setIdcard("1928424" + "编号" + i);
            arrs.add(man1);
        }
        //移除集合中元素时，注意集合中元素的移动
        for (int i = 0; i <arrs.size(); i++) {
            if (arrs.get(i).getAge()==5){
                arrs.remove(i);
            }
            if (arrs.get(i).getAge()==6){
                System.out.println("这是6岁的绿巨人");
            }
        }
        //使用stream流操作结合
        arrs.forEach(System.out::println);
        List<String> collect = arrs.stream()
                .sorted((v1,v2)->v2.getAge()-v1.getAge())
                .filter(e->e.getAge()>5)
                .map(SuperMan::getIdcard)
                .collect(Collectors.toList());
        collect.forEach(System.out::println);
        System.out.println(collect);


        //不使用stream
        ArrayList<String> superManIds=new ArrayList<>();
        for (int i = 0; i < arrs.size(); i++) {
           SuperMan man1 = arrs.get(i);
            if (man1.getAge()>5){
                superManIds.add(man1.getIdcard());
            }
        }
        superManIds.forEach(System.out::println);


    }
}

```



集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象(实际上保存的是对象的引用变量)。

集合里只能保存对象（实际上只是保存对象的引用变量，但通常习惯上认为集合里保存的是对象)。

Java的集合类主要由两个接口派生而出:Collection和 Map，Collection和 Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。

**集合体系**

![image-20211123210129611](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123210129611.png)

![image-20211123210754568](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123210754568.png)

**Map体系**

![image-20211123211125145](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123211125145.png)

## 1. Collection和Iterator接口

### Collection介绍

Collection接口是List、Set和 Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和 Queue集合。

1. boolean **add**(Object o):该方法用于向集合里添加一个元素。如果集合对象被添加操作改变了，则返回true。
2. boolean **addAll**(Collection c):该方法把集合c里的所有元素添加到指定集合里。如果集合对象被添加操作改变了，则返回true。
3. void **clear**():清除集合里的所有元素,将集合长度变为0。
4. boolean **contains**(Object o):返回集合里是否包含指定元素
5. boolean **containsAll**(Collection c):返回集合里是否包含集合c里的所有元素。
6. boolean **isEmpty()**:返回集合是否为空。当集合长度为О时返回true，否则返回false。
7. Iterator **iterator()**:返回一个Iterator对象，用于遍历集合里的元素。
8. boolean **remove(Object o)**:删除集合中的指定元素o，当集合中包含了一个或多个元素o时，该方法**只删除第一个符合条件的元素**，该方法将返回true。
9. boolean **removeAll(Collection c)**:**从集合中删除集合c里包含的所有元素**（相当于用调用该方法的集合减集合c)，如果删除了一个或一个以上的元素，则该方法返回true。
10. boolean **retainAll(Collection c)**:从集合中**删除集合c里不包含的元素**(相当于把调用该方法的集合变成该集合和集合c的交集)，如果该操作改变了调用该方法的集合，则该方法返回true。
11. int **size()**:该方法返回集合里元素的个数。
12. Object [] **toArray()**:该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。
13. 详情查看api文档

**集合练习**

```java
public class CollectionTest
{
	public static void main(String[] args)
	{
		Collection c = new ArrayList();
		// 添加元素
		c.add("孙悟空");
		// 虽然集合里不能放基本类型的值，但Java支持自动装箱
		c.add(6);
		System.out.println("c集合的元素个数为:" + c.size()); // 输出2
		// 删除指定元素
		c.remove(6);
		System.out.println("c集合的元素个数为:" + c.size()); // 输出1
		// 判断是否包含指定字符串
		System.out.println("c集合的是否包含\"孙悟空\"字符串:"
			+ c.contains("孙悟空")); // 输出true
		c.add("轻量级Java EE企业应用实战");
		System.out.println("c集合的元素：" + c);
		Collection books = new HashSet();
		books.add("轻量级Java EE企业应用实战");
		books.add("疯狂Java讲义");
		System.out.println("c集合是否完全包含books集合？"
			+ c.containsAll(books)); // 输出false
		// 用c集合减去books集合里的元素
		c.removeAll(books);
		System.out.println("c集合的元素：" + c);
		// 删除c集合里所有元素
		c.clear();
		System.out.println("c集合的元素：" + c);
		// 控制books集合里只剩下c集合里也包含的元素
		books.retainAll(c);
		System.out.println("books集合的元素:" + books);
	}
}
```

当使用System.out的printIn()方法来输出集合对象时，将输出[ele1,ele2...].[的形式，这显然是因为**所有的Collection实现类都重写了toString()方法**，该方法可以一次性地输出集合中的所有元素。

注意：如果不为集合设置泛型，那么默认情况下，集合存储的数据类型为Object类型

### 遍历集合

#### 1. 使用Lambda遍历集合

Java 8为Iterable接口新增了**一个forEach(Consumer action)默认方法**，该方法所需参数的类型是一
个函数式接口，而Iterable接口是Collection接口的父接口，因此Collection集合也可直接调用该方法。

当程序调用Iterable 的forEach(Consumer action)遍历集合 元素时，**程序会依次将集合元素传给**
**Consumer的accept(T t)方法(该接口中唯一的抽象方法)。** 正因为Consumer是函数式接口，因此可以
使用Lambda表达式来遍历集合元素。

如下程序示范了使用Lambda表达式来遍历集合元素。

```java
public class CollectionEach
{
	public static void main(String[] args)
	{
		// 创建一个集合
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 调用forEach()方法遍历集合
		books.forEach(obj -> System.out.println("迭代集合元素：" + obj));
	}
}
```

#### 2. 使用Iterator遍历集合元素

Collection系列集合、Map系列集合主要用于盛装其他对象，而 Iterator则主要用于遍历〈即迭代访问)Collection集合中的元素，Iterator对象也被称为迭代器。

Iterator接口隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口。

**定义的方法：**

1. boolean hasNext():如果被迭代的集合元素还没有被遍历完，则返回true。

2. Object next():返回集合里的下一个元素。

3. void remove(）:删除集合里上一次next方法返回的元素。

4. void forEachRemaining(Consumer action)，这是Java 8为lterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。

```java
public class IteratorTest
{
	public static void main(String[] args)
	{
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		while(it.hasNext())
		{
			// it.next()方法返回的数据类型是Object类型，因此需要强制类型转换
			String book = (String)it.next();
			System.out.println(book);
			if (book.equals("Java"))
			{
				// 从集合中删除上一次next方法返回的元素
				it.remove();
			}
			// 对book变量赋值，不会改变集合元素本身
			book = "测试字符串";   //无效
		}
		System.out.println(books);
	}
}
```

1. Iterator必须依附于Collection对象，若有一个Iterator对象，则必然有一个与之关联的Collection对象。Iterator提供了两个方法来迭代访问Collection集合里的元素，并可通过remove()方法来删除集合中上一次next()方法返回的集合元素。
2. 对迭代变量book进行赋值，但当再次输出books 集合时，会看到集合里的元素没有任何改变。当使用Iterator对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量，所以修改迭代变量的值对集合元素本身没有任何影响。
3. 当使用Iterator 迭代访问Collection 集合元素时，Collection 集合里的元素不能被改变，只有通过
   Iterator的remove0方法删除上一次next0方法返回的集合元素才可以;否则将会引发java.util.Concurrent
   ModificationException异常。

```java
public class IteratorErrorTest
{
	public static void main(String[] args)
	{
        Collection books = new HashSet();
		// 创建集合、添加元素的代码与前一个程序相同
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		while(it.hasNext())
		{
			String book = (String)it.next();
			System.out.println(book);
			if (book.equals("Java"))
			{
				// 使用Iterator迭代过程中，不可修改集合元素,下面代码引发异常
				books.remove(book);
			}
		}
	}
}
```

![image-20211123214335887](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123214335887.png)

注意：当我们进行集合迭代时，删除元素会导致错误。

#### 3. 使用Lambda表达式遍历Iterator

Java 8为Iterator新增了一个forEachRemaining(Consumer action)方法，该方法所需的Consumer参
数同样也是函数式接口。当程序调用Iterator的forEachRemaining(Consumer action)遍历集合元素时，程序会**依次**将集合元素传给Consumer的accept(T t)方法( 该接口中唯一的抽象方法)。

```java
public class IteratorEach
{
	public static void main(String[] args)
	{
		// 创建集合、添加元素的代码与前一个程序相同
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		// 使用Lambda表达式（目标类型是Comsumer）来遍历集合元素
		it.forEachRemaining(obj -> System.out.println("迭代集合元素：" + obj));
	}
}
```

#### 4. 使用foreach循环遍历集合元素

```java
public class ForeachTest
{
	public static void main(String[] args)
	{
		// 创建集合、添加元素的代码与前一个程序相同
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		for (Object obj : books)
		{
			// 此处的book变量也不是集合元素本身
			String book = (String)obj;
			System.out.println(book);
			if (book.equals("疯狂Android讲义"))
			{
				// 下面代码会引发ConcurrentModificationException异常
				books.remove(book);     //①
			}
		}
		System.out.println(books);
	}
}
```

#### 5. 使用Predicate操作集合

Java 8为Collection集合新增了一个个removelf(Predicate filter)方法，该方法将会批量删除符合filter
条件的所有元素。该方法需要一个Predicate (谓词)对象作为参数，Predicate 也是函数式接口，因此可
使用Lambda表达式作为参数。

removeIf，删除符合条件的数据，条件通过实现Predicate 的方法来创造。

![image-20211123220954780](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123220954780.png)

Predicate ：类似筛选条件。

![image-20211123221143697](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123221143697.png)

如下程序示范了使用Predicate 来过滤集合。

```java
public class PredicateTest
{
	public static void main(String[] args)
	{
		// 创建一个集合
		Collection books = new HashSet();
		books.add(new String("Java EE"));
		books.add(new String("Java"));
		books.add(new String("iOS"));
		books.add(new String("Ajax"));
		books.add(new String("Android"));
		// 使用Lambda表达式（目标类型是Predicate）过滤集合
		books.removeIf(ele -> ((String)ele).length() < 5);
		System.out.println(books);
	}
}
```

需求：

1. 统计书名中出现“疯狂”字符串的图书数量。
2. 统计书名中出现“Java”字符串的图书数量。
3. 统计书名长度大于10的图书数量。

```java
public class PredicateTest2
{
	public static void main(String[] args)
	{
		// 创建books集合、为books集合添加元素的代码与前一个程序相同。
		Collection books = new HashSet();
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂iOS讲义"));
		books.add(new String("疯狂Ajax讲义"));
		books.add(new String("疯狂Android讲义"));
		// 统计书名包含“疯狂”子串的图书数量
		System.out.println(calAll(books , ele->((String)ele).contains("疯狂")));
		// 统计书名包含“Java”子串的图书数量
		System.out.println(calAll(books , ele->((String)ele).contains("Java")));
		// 统计书名字符串长度大于10的图书数量
		System.out.println(calAll(books , ele->((String)ele).length() > 10));
	}
	public static int calAll(Collection books , Predicate p)
	{
		int total = 0;
		for (Object obj : books)
		{
			// 使用Predicate的test()方法判断该对象是否满足Predicate指定的条件
			if (p.test(obj))
			{
				total ++;
			}
		}
		return total;
	}
}
```

#### 6. 使用Stream流

Java 8新增了Stream、IntStream、 LongStream、 DoubleStream 等流式API,这些API代表多个支持串行和并行聚集操作的元素。

上面4个接口中，Stream是一个通用的流接口,而IntStream、LongStream、DoubleStream则代表元素类型为int、long、 double 的流。

每个流式API有对应的Builder, 例如Stream.Builder、 IntStream.Builder、LongStream.Builder、DoubleStream. Builder,开发者可以通过这些Builder来创建对应的流。

**使用Stream的步骤如下:**

1. 使用Stream或XxxStream的builder(）类方法创建该Stream对应的Builder。
2. 重复调用Builder的add（）方法向该流中添加多个元素。
3. 调用Builder的build（）方法获取对应的Stream。
4. 调用Stream的聚集方法。

```java
public class IntStreamTest
{
	public static void main(String[] args)
	{
		IntStream is = IntStream.builder()
			.add(20)
			.add(13)
			.add(-2)
			.add(18)
			.build();
		// 下面调用聚集方法的代码每次只能执行一个
		System.out.println("is所有元素的最大值：" + is.max().getAsInt());
		System.out.println("is所有元素的最小值：" + is.min().getAsInt());
		System.out.println("is所有元素的总和：" + is.sum());
		System.out.println("is所有元素的总数：" + is.count());
		System.out.println("is所有元素的平均值：" + is.average());
		System.out.println("is所有元素的平方是否都大于20:"
			+ is.allMatch(ele -> ele * ele > 20));
		System.out.println("is是否包含任何元素的平方大于20:"
			+ is.anyMatch(ele -> ele * ele > 20));
		// 将is映射成一个新Stream，新Stream的每个元素是原Stream元素的2倍+1
		IntStream newIs = is.map(ele -> ele * 2 + 1);
		// 使用方法引用的方式来遍历集合元素
		newIs.forEach(System.out::println); // 输出41 27 -3 37
	}
}
```

上面程序先创建了一个IntStream,接下来调用IntStream的聚集方法执行操作，这样即可获取该流的相关信息。

注意：一个IntStream调用一次聚集方法后，流就进行了关闭，不能调用其他的方法。

![image-20211124141450401](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211124141450401.png)Stream提供了大量的方法进行聚集操作，这些方法既可以是“中间的”(intermediate)，也可以是“末端的”(terminal)。

1. 中间方法:中间操作允许流保持打开状态，并允许直接调用后续方法。上面程序中的map()方法就是中间方法。中间方法的返回值是另外一个流。
2. 末端方法:末端方法是对流的最终操作。当对某个Stream执行末端方法后,该流将会被“消耗”且不再可用。上面程序中的sum()、count()、 averageO等 方法都是末端方法。

**流的方法还有如下两个特征。**

1. 有状态的方法:这种方法会给流增加一些新的属性，比如元素的唯一性、元素的最大数量、保证元素以排序的方式被处理等。有状态的方法往往需要更大的性能开销。
2. 短路方法:短路方法可以尽早结束对流的操作，不必检查所有的元素。

**常用的中间方法**

1. filter(Predicate predicate):过滤Stream中所有不符合predicate 的元素
2. mapToXxx(ToXxxFunction mapper):使用ToXxxFunction对流中的元素执行一对一的转换，该方法返回的新流中包含了ToXxxFunction转换生成的所有元素。
3. peek(Consumer action):依次对每个元素执行一些操作， 该方法返回的流与原有流包含相同的元素。该方法主要用于调试。
4. distinct(): 该方法用于排序流中所有重复的元素(判断元素重复的标准是使用equals)比较返回true。这是一个有状态的方法。
5. sorted(): 该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。
6. limit(long maxSize):该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个有状态的、短路方法。

**常用的末端方法**

1. forEach(Consumer action):遍历流中所有元素，对每个元素执行action。
2. toArray(): 将流中所有元素转换为一个数组。
3. reduce(): 该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。
4. min(): 返回流中所有元素的最小值。
5. max(): 返回流中所有元素的最大值。
6. count():返回流中所有元素的数量。
7. anyMatch(Predicate predicate):判断流中是否至少包含一个元素符合Predicate条件。
8. allMatch(Predicate predicate):判断流中是否每个元素都符合Predicate条件。
9. noneMatch(Predicate predicate):判断流中是否所有元素都不符合Predicate条件。
10. findFirst():返回流中的第一个元素。
11. findAny():返回流中的任意一个元素。

```java
public class CollectionStream
{
	public static void main(String[] args)
	{
		// 创建books集合、为books集合添加元素的代码与8.2.5小节的程序相同。
		Collection books = new HashSet();
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂iOS讲义"));
		books.add(new String("疯狂Ajax讲义"));
		books.add(new String("疯狂Android讲义"));
		// 统计书名包含“疯狂”子串的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele)
                   .contains("疯狂"))
			.count()); // 输出4
		// 统计书名包含“Java”子串的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele).contains("Java") )
			.count()); // 输出2
		// 统计书名字符串长度大于10的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele).length() > 10)
			.count()); // 输出2
		// 先调用Collection对象的stream()方法将集合转换为Stream,
		// 再调用Stream的mapToInt()方法获取原有的Stream对应的IntStream
		books.stream().mapToInt(ele -> ((String)ele).length())
			// 调用forEach()方法遍历IntStream中每个元素
			.forEach(System.out::println);// 输出8  11  16  7  8
	}
}
```

程序只要调用Collection的 stream()方法即可返回该集合对应的Stream，接下来就可通过Stream提供的方法对所有集合元素进行处理，这样大大地简化了集合编程的代码，这也是 Stream编程带来的优势。

```java
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
```

mapToInt()方法就是一个中间方法，因此程序可继续调用IntStream的 forEach()方法来遍历流中的元素。

### 流的概念

```java
class Dish {
    private final String name;
    private final boolean vegetarian;
    private final int calories;
    private final Type type;

    public Dish(String name, boolean vegetarian, int calories, Type type) {
        this.name = name;
        this.vegetarian = vegetarian;
        this.calories = calories;
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public int getCalories() {
        return calories;
    }

    public Type getType() {
        return type;
    }

    @Override
    public String toString() {
        return name;
    }

    public enum Type {MEAT, FISH, OTHER}
}

public class StreamTest {
    public static void main(String[] args) {
        List<Dish> menu = Arrays.asList(
                new Dish("pork", false, 800, Dish.Type.MEAT),
                new Dish("beef", false, 700, Dish.Type.MEAT),
                new Dish("chicken", false, 400, Dish.Type.MEAT),
                new Dish("french fries", true, 530, Dish.Type.OTHER),
                new Dish("rice", true, 350, Dish.Type.OTHER),
                new Dish("season fruit", true, 120, Dish.Type.OTHER),
                new Dish("pizza", true, 550, Dish.Type.OTHER),
                new Dish("prawns", false, 300, Dish.Type.FISH),
                new Dish("salmon", false, 450, Dish.Type.FISH));
        /*要求：
         *1. 删选出calories小于400的Dish
         *2. 通过calories进行从小到大排序
         *3. 获取符合以上两种条件的name集合。
         */
        System.out.println("Java7");
        //Java7遍历
        List<Dish> lowCaloricDishes = new ArrayList<>();
        for (Dish d : menu) {
            if (d.getCalories() < 400) {
                lowCaloricDishes.add(d);
            }
        }
        Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
            public int compare(Dish d1, Dish d2) {
                return Integer.compare(d1.getCalories(), d2.getCalories());
            }
        });
        List<String> lowCaloricDishesName = new ArrayList<>();
        for (Dish d : lowCaloricDishes) {
            lowCaloricDishesName.add(d.getName());
        }
        lowCaloricDishes.forEach(System.out::println);
        System.out.println("Java8");
        //Java8
        lowCaloricDishes.stream()
                .filter(item->item.getCalories()<400)
                .sorted(Comparator.comparing(Dish::getCalories))
                .map(Dish::getName)
                .collect(Collectors.toList());
        lowCaloricDishes.forEach(System.out::println);
    }
}
```

![image-20211124113135709](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211124113135709.png)

将流操作链接起来构成流的流水线.

## 2. List集合

List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。可以通过索引来访问指定位置的集合元素。List作为Collection接口的子接口，可以使用Collection接口里的全部方法。

### 基本操作

**常用方法**

1. void add(int index, Object element):将元素element插入到List集合的index 处。
2. boolean addAll(int index，Collection c):将集合c所包含的所有元素都插入到List集合的 index
   处。
3. Object get(int index):返回集合index索引处的元素。
4. int indexOf(Object o):返回对象o在List集合中第一次出现的位置索引。
5. int lastIndexOf(Object o):返回对象o在List集合中最后一次出现的位置索引。
6. Object remove(int index):删除并返回index索引处的元素。
7. Object set(int index, Object element):将index 索引处的元素替换成element对象，返回被替换的旧元素。
8. List subList(int fromIndex, int toIndex):返回从索引fromIndex (包含）到索引toIndex (不包含)处所有集合元素组成的子集合。
   所有的List实现类都可以调用这些方法来操作集合元素。与Set集合相比，List增加了根据索引来插入、替换和删除集合元素的方法。

```java
public class ListTest
{
	public static void main(String[] args)
	{
		List books = new ArrayList();
		// 向books集合中添加三个元素
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂Android讲义"));
		System.out.println(books);
		// 将新字符串对象插入在第二个位置
		books.add(1 , new String("疯狂Ajax讲义"));
		for (int i = 0 ; i < books.size() ; i++ )
		{
			System.out.println(books.get(i));
		}
		// 删除第三个元素
		books.remove(2);
		System.out.println(books);
		// 判断指定元素在List集合中位置：输出1，表明位于第二位
		System.out.println(books.indexOf(new String("疯狂Ajax讲义"))); 
		//将第二个元素替换成新的字符串对象
		books.set(1, new String("疯狂Java讲义"));
		System.out.println(books);
		//将books集合的第二个元素（包括）到第三个元素（不包括）截取成子集合
		System.out.println(books.subList(1 , 2));
	}
}
```

**问题：**

```java
		books.add(1 , new String("疯狂Ajax讲义"));	
// 判断指定元素在List集合中位置：输出1，表明位于第二位
		System.out.println(books.indexOf(new String("疯狂Ajax讲义"))); 
```

1. 我们往集合中添加了一个字符串对象“疯狂Ajax讲义”，但是我们又进行字符串新增时，添加的是一个新的字符串，两个字符串本质上并不属于同一个对象，但是我们使用books.indexOf(new String("疯狂Ajax讲义"))时，却发现能返回字符串所在的位置1.

2. 使用indexOf时或者remove（）对象时，集合判断的标准是引用类型的equals方法。

   1. ![image-20211125202451854](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211125202451854.png)

   2. ```java
      class A
      {
      	public boolean equals(Object obj)
      	{
      		return true;
      	}
      }
      public class ListTest2
      {
      	public static void main(String[] args)
      	{
      		List books = new ArrayList();
      		books.add(new String("轻量级Java EE企业应用实战"));
      		books.add(new String("疯狂Java讲义"));
      		books.add(new String("疯狂Android讲义"));
      		System.out.println(books);
      		// 删除集合中A对象，将导致第一个元素被删除
      		books.remove(new A());     // ①
      		System.out.println(books);
      		// 删除集合中A对象，再次删除集合中第一个元素
      		books.remove(new A());     // ②
      		System.out.println(books);
      	}
      }
      ```

   3. 当我们删除一个集合中默认不存在的元素时，会**默认删除集合中的第一个元素。**

      1. 因为走的是A的equals方法，因此默认都返回true。
      2. ![image-20211125202610932](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211125202610932.png)

**注意**：

使用List的set（int index,Object element）方法时，可以改变集合指定索引处的元素，但是指定的索引只能是集合索引所在的范围呢，set方法并不能改变List集合的长度。比如集合长度为5，在6的地方添加一个元素是不行的。

#### **Java8新增**

1. void replaceAll(UnaryOperator operator):根据 operator指定的计算规则重新设置List集合的所有元素。
2. void sort(Comparator c):根据Comparator参数对List集合的元素排序。

```java
public class ListTest3
{
	public static void main(String[] args)
	{
		List books = new ArrayList();
		// 向books集合中添加4个元素
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂Android讲义"));
		books.add(new String("疯狂iOS讲义"));
		// 使用目标类型为Comparator的Lambda表达式对List集合排序
		books.sort((o1, o2)->((String)o1).length() - ((String)o2).length());
		System.out.println(books);
		// 使用目标类型为UnaryOperator的Lambda表达式来替换集合中所有元素
		// 该Lambda表达式控制使用每个字符串的长度作为新的集合元素
		books.replaceAll(ele->((String)ele).length());
		System.out.println(books); // 输出[7, 8, 11, 16]

	}
}
```

#### 迭代器

List额外提供了一个listlterator()方法，该方法返回一个Listlterator对象，Listlterator 接口继承了lterator接口，提供了专门操作List 的方法。Listlterator接口在lterator接口基础上增加了如下方法。

1. boolean hasPrevious():返回该迭代器关联的集合是否还有上一个元素。
2. Object previous():返回该迭代器的上一个元素。
3. void add(Object o):在指定位置插入一个元素。

拿ListIterator 与普通的Iterator进行对比，不难发现Listlterator增加了向前迭代的功能(Iterator 只能向后迭代)，而且ListIlterator还可通过add()方法向List集合中添加元素（Iterator只能删除元素)。下面程序示范了ListIterator的用法。

```java
public class ListIteratorTest
{
    public static void main(String[] args)
    {
        String[] books = {
                "疯狂Java讲义", "疯狂iOS讲义",
                "轻量级Java EE企业应用实战"
        };
        List bookList = new ArrayList();
        for (int i = 0; i < books.length ; i++ )
        {
            bookList.add(books[i]);
        }
        ListIterator lit = bookList.listIterator();
        while (lit.hasNext())
        {
            System.out.println(lit.next());
//            lit.add("-------分隔符-------");
        }
        System.out.println("=======下面开始反向迭代=======");
        while(lit.hasPrevious())
        {
            System.out.println(lit.previous());
        }
    }
}

```

### ArrayList和Vector实现类

1. ArrayList和 Vector作为List类的两个典型实现，完全支持前面介绍的List接口的全部功能。

2. ArrayList和 Vector类都是基于数组实现的List类，ArrayList和Vector类封装了一个动态的、允许再分配的**Object[]数组**。Object[]数组的长度默认为10。

   1. ArrayList或Vector对象使用initialCapacity参数来设置该数组的长度，当向ArrayList或 Vector中添加元素超出了该数组的长度时，它们的initialCapacity 会自动增加。

   2. 如果向ArrayList或Vector集合中添加大量元素时，可使用ensureCapacity(int minCapacity)方法一次性地增加initialCapacity。这可以减少重分配的次数，从而提高性能。

   3. 如果开始就知道ArrayList或 Vector集合需要保存多少个元素，则可以在创建它们时就指定initialCapacity大小。

   4. ```java
            List<String> a = new ArrayList<>(15);
      ```

3. ArrayList和Vector在用法上几乎完全相同，Vector比较老，基本弃用，但是Vector线程是安全的，ArrayList是不安全的，但是实际使用中，需要线程的场景也不实用Vector，而是使用**Collections.synchronizedList** ()。

   1. ```java
       //线程不安全：
       List<Map<String,Object>> data=new ArrayList<Map<String,Object>>();
       //线程安全：
       List<Map<String,Object>> data=Collections.synchronizedList (new ArrayList<Map<String,Object>> ())
      ```

4. Vector提供了一个子类Stack，栈，先进后出，比较老，不使用。通常使用ArrayDeque代替。

   1. ArrayDeque底层基于数组，实现了List和Deque接口，性能好。

**ArrayList和 Vector还提供了如下两个方法来重新分配Object[]数组。**

1. void ensureCapacity(int minCapacity):将ArrayList或Vector集合的Object[]数组长度增加大于或等于minCapacity值。
2. void trimToSize():调整ArrayList或Vector集合的Object[]数组长度为当前元素的个数。调用该方法可减少ArrayList或 Vector集合对象占用的存储空间。

```java
        ArrayList b = new ArrayList(10);
        b.add(1);
        b.add(1);
        b.add(1);
        b.add(1);
        b.add(1);
        b.ensureCapacity(4);
        b.trimToSize();
        System.out.println(b.size());
```

### 固定长度的List

前面讲数组时介绍了一个操作数组的工具类: Arrays，该工具类里提供了asList(Object.. a)方法，该方法可以把一个数组或指定个数的对象转换成一个List集合，这个 List集合既不是ArrayList 实现类的实例，也不是 Vector实现类的实例，而是Arrays的内部类ArrayList的实例。
Arrays.ArrayList是一个固定长度的List集合，**程序只能遍历访问该集合里的元素**，**不可增加、删除该集合里的元素**。

![image-20211125211913374](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211125211913374.png)

```java
public class FixedSizeList
{
	public static void main(String[] args)
	{
		List fixedList = Arrays.asList("疯狂Java讲义"
			, "轻量级Java EE企业应用实战");
		// 获取fixedList的实现类，将输出Arrays$ArrayList   表名他是一个内部类。
		System.out.println(fixedList.getClass());
		// 使用方法引用遍历集合元素
		fixedList.forEach(System.out::println);
        
		// 试图增加、删除元素都会引发UnsupportedOperationException异常
		fixedList.add("疯狂Android讲义");
		fixedList.remove("疯狂Java讲义");
	}
}
```

## 3. Queue接口(了解，待深入)

Queue用于模拟队列这种数据结构，队列通常是指“先进先出”(FIFO）的容器。

新元素插入（offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素。

通常，队列不允许随机访问队列中的元素。

Queue接口中定义了如下几个方法。

1. void add(Object e):将指定元素加入此队列的尾部。
2. Object element():获取队列头部的元素，但是不删除该元素。
3. boolean offer(Object e):将指定元素加入此队列的尾部。当使用有容量限制的队列时，此方法通常比 add(Object e)方法更好。
4. Object peek():获取队列头部的元素，但是不删除该元素。如果此队列为空，则返回null。
5. Object poll():获取队列头部的元素，并删除该元素。如果此队列为空，则返回null。
6. Object remove():获取队列头部的元素，并删除该元素。

Queue接口有一个PriorityQueue实现类。

Queue还有一个Deque接口，Deque代表一个“双端队列”，双端队列可以同时从两端来添加、删除元素，因此 Deque 的实现类既可当成队列使用，也可当成栈使用。

Java为 Deque提供了ArrayDeque和 LinkedList两个实现类。

### PriorityQueue（优先队列）实现类

#### **推荐Blog**

1. https://www.cnblogs.com/guanghe/p/13450971.html
2. https://blog.csdn.net/ohwang/article/details/116934308
3. [(87条消息) Java PriorityQueue（优先队列）_javaZhong的博客-CSDN博客](https://blog.csdn.net/u010675669/article/details/86503464)

1. PriorityQueue不是绝对标准的队列，PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是**按队列元素的大小进行重新排序**。

2. **当调用peek()方法或者poll)方法取出队列中的元素时，并不是取出最先进入队列的元素，而是取出队列中最小的元素。违反了队列先进先出(FIFO)的基本规则。**

#### **普通使用**

```java
public class PriorityQueueTest
{
	public static void main(String[] args)
	{
		PriorityQueue pq = new PriorityQueue();
		// 下面代码依次向pq中加入四个元素
		pq.offer(6);
		pq.offer(-3);
		pq.offer(20);
		pq.offer(18);
		// 输出pq队列，并不是按元素的加入顺序排列
		System.out.println(pq); // 输出[-3, 6, 20, 18]
		// 访问队列第一个元素，其实就是队列中最小的元素：-3
		System.out.println(pq.poll());
	}
}
```

问题：

1. 直接输出集合，发现并没有按照大小排序，但是取出集合中的元素时，是从小到大取出的。
   1. 了解优先队列的底层。

PriorityQueue的元素有两种排序方式。
自然排序:采用自然顺序的 PriorityQueue集合中的元素必须实现了Comparable接口，而且应该是同一个类的多个实例，否则可能导致ClassCastException异常。

定制排序:创建PriorityQueue队列时，传入一个Comparator对象，该对象负责对队列中的所有元素进行排序。采用定制排序时不要求队列元素实现 Comparable接口。

#### **使用Comparator**

**创建Employee类**

```java
public class Employee {

    private Long id;

    private String name;

    private LocalDate dob;

    public Employee(Long id, String name, LocalDate dob) {

        super();

        this.id = id;

        this.name = name;

        this.dob = dob;

    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Override

    public String toString() {

        return "Employee [id=" + id + ", name=" + name + ", dob=" + dob + "]";

    }

    public static void main(String[] args) {
        Comparator<Employee> nameSorter = Comparator.comparing(Employee::getId);
        PriorityQueue<Employee> priorityQueue = new PriorityQueue<>(nameSorter);
        priorityQueue.add(new Employee(1l, "AAA", LocalDate.now()));
        priorityQueue.add(new Employee(4l, "CCC", LocalDate.now()));
        priorityQueue.add(new Employee(5l, "BBB", LocalDate.now()));
        priorityQueue.add(new Employee(2l, "FFF", LocalDate.now()));
        priorityQueue.add(new Employee(3l, "DDD", LocalDate.now()));
        priorityQueue.add(new Employee(6l, "EEE", LocalDate.now()));
        while(true) {
            Employee e = priorityQueue.poll();
            System.out.println(e);
            if(e == null) break;
        }
    }
}
```

#### **使用Comparable**

```java
public class Employees implements Comparable<Employees> {
    private Long id;

    private String name;

    private LocalDate dob;

    public Long getId() {
        return id;
    }

    public Employees(Long id, String name, LocalDate dob) {
        super();
        this.id = id;
        this.name = name;
        this.dob = dob;
    }
    @Override
    public int compareTo(Employees emp) {
        return this.getId().compareTo(emp.getId());
    }
    //Getters and setters
    @Override
    public String toString() {
        return "Employee [id=" + id + ", name=" + name + ", dob=" + dob + "]";
    }

    public static void main(String[] args) {
        PriorityQueue<Employees> priorityQueue = new PriorityQueue<>();
        priorityQueue.add(new Employees(1l, "AAA", LocalDate.now()));
        priorityQueue.add(new Employees(4l, "CCC", LocalDate.now()));
        priorityQueue.add(new Employees(5l, "BBB", LocalDate.now()));
        priorityQueue.add(new Employees(2l, "FFF", LocalDate.now()));
        priorityQueue.add(new Employees(3l, "DDD", LocalDate.now()));
        priorityQueue.add(new Employees(6l, "EEE", LocalDate.now()));
        while(true) {
            Employees e = priorityQueue.poll();
            System.out.println(e);
            if(e == null) break;
        }
    }

}
```

### Deque口与ArrayDeque 实现类

Deque接口是Queue接口的子接口，它代表一个双端队列，Deque接口里定义了一些双端队列的方法，这些方法允许从两端来操作队列的元素。

Deque接口的实现类: ArrayDeque，一个基于数组实现的双端队列，创建Deque时同样可指定一个numElements参数，该参数用于指定Object[]数组的长度;如果不指定numElements参数，Deque底层数组的长度为16。

1. ArrayDeque可以作为栈使用，来代替Stack（老，性能差劲）
2. ArrayDeque可以作为队列使用

ArrayList和ArrayDeque两个集合类的实现机制基本相似,底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出了该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素。

1. void addFirst(Object e):将指定元素插入该双端队列的开头。
2. void addLast(Object e):将指定元素插入该双端队列的末尾。
3. lterator descendingIterator():返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。
4. Object getFirst():获取但不删除双端队列的第一个元素。Object getLast():获取但不删除双端队列的最后一个元素。
5. boolean offerFirst(Object e):将指定元素插入该双端队列的开头。
6. boolean offerLast(Object e):将指定元素插入该双端队列的末尾。
7. Object peekFirst():获取但不删除该双端队列的第一个元素;如果此双端队列为空，则返回null。
8. ObjectpeekLast():获取但不删除该双端队列的最后一个元素;如果此双端队列为空,则返回null。
9. Object pollFirst():获取并删除该双端队列的第一个元素;如果此双端队列为空，则返回null。
10. Object pollLast():获取并删除该双端队列的最后一个元素;如果此双端队列为空，则返回null。
11. Object pop()（栈方法): pop出该双端队列所表示的栈的栈顶元素。相当于removeFirst()。
12. void push(Object e)(栈方法):将一个元素 push进该双端队列所表示的栈的栈顶。相当于addFirst(e)。
13. Object removeFirst():获取并删除该双端队列的第一个元素。
14. Object removeFirstOccurrence(Object o):删除该双端队列的第一次出现的元素o。
15. Object removeLast():获取并删除该双端队列的最后一个元素。
16. boolean removeLastOccurrence(Object o):删除该双端队列的最后一次出现的元素o。

从上面方法中可以看出，Deque不仅可以当成双端队列使用，而且可以被当成栈来使用，包含了pop（出栈)、push（入栈）两个方法。

![image-20211125225508637](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211125225508637.png)

![image-20211125225528886](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211125225528886.png)

#### ArrayDeque的栈使用

```java
public class ArrayDequeStack
{
	public static void main(String[] args)
	{
		ArrayDeque stack = new ArrayDeque();
		// 依次将三个元素push入"栈"
		stack.push("疯狂Java讲义");
		stack.push("轻量级Java EE企业应用实战");
		stack.push("疯狂Android讲义");
		// 输出：[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]
		System.out.println(stack);
		// 访问第一个元素，但并不将其pop出"栈"，输出：疯狂Android讲义
		System.out.println(stack.peek());
		// 依然输出：[疯狂Android讲义, 疯狂Java讲义, 轻量级Java EE企业应用实战]
		System.out.println(stack);
		// pop出第一个元素，输出：疯狂Android讲义
		System.out.println(stack.pop());
		// 输出：[轻量级Java EE企业应用实战, 疯狂Java讲义]
		System.out.println(stack);
	}
}
```

#### ArrayDeque的队列使用

```java
public class ArrayDequeQueue
{
	public static void main(String[] args)
	{
		ArrayDeque queue = new ArrayDeque();
		// 依次将三个元素加入队列
		queue.offer("疯狂Java讲义");
		queue.offer("轻量级Java EE企业应用实战");
		queue.offer("疯狂Android讲义");
		// 输出：[疯狂Java讲义, 轻量级Java EE企业应用实战, 疯狂Android讲义]
		System.out.println(queue);
		// 访问队列头部的元素，但并不将其poll出队列"栈"，输出：疯狂Java讲义
		System.out.println(queue.peek());
		// 依然输出：[疯狂Java讲义, 轻量级Java EE企业应用实战, 疯狂Android讲义]
		System.out.println(queue);
		// poll出第一个元素，输出：疯狂Java讲义
		System.out.println(queue.poll());
		// 输出：[轻量级Java EE企业应用实战, 疯狂Android讲义]
		System.out.println(queue);
	}
}
```

#### LinkedList实现类

**即实现了List接口，又实现了Deque接口，可以通过索引来随机访问集合中的元素**，也可以被当成栈或者队列使用。

```java
public class LinkedListTest
{
	public static void main(String[] args)
	{
		LinkedList books = new LinkedList();
		// 将字符串元素加入队列的尾部
		books.offer("疯狂Java讲义");
		// 将一个字符串元素加入栈的顶部
		books.push("轻量级Java EE企业应用实战");
		// 将字符串元素添加到队列的头部（相当于栈的顶部）
		books.offerFirst("疯狂Android讲义");
		// 以List的方式（按索引访问的方式）来遍历集合元素
		for (int i = 0; i < books.size() ; i++ )
		{
			System.out.println("遍历中：" + books.get(i));
		}
		// 访问、并不删除栈顶的元素
		System.out.println(books.peekFirst());
		// 访问、并不删除队列的最后一个元素
		System.out.println(books.peekLast());
		// 将栈顶的元素弹出“栈”
		System.out.println(books.pop());
		// 下面输出将看到队列中第一个元素被删除
		System.out.println(books);
		// 访问、并删除队列的最后一个元素
		System.out.println(books.pollLast());
		// 下面输出：[轻量级Java EE企业应用实战]
		System.out.println(books);
	}
}
```

### List和Queue的实现类对比

基于数组实现的集合：如：ArrayList，ArrayDeque 

1. 随机访问集合性能较好，但是不适用频繁插入操作。
2. Vector（线程安全的）使用ArrayList代替，线程同步时，使用Collections.synchronizedList (new ArrayList<> ())

基于链表实现的集合：如：LinkedList

1. 使用迭代器进行集合的遍历，适用于频繁的插入，删除场景。正常使用的是ArrayList

## 4. Set集合

Set集合是无序的，Set不允许包含重复元素。与Collection相同，没有提供新的方法。

### HashSet实现类

HashSet是 Set接口的典型实现，按 Hash算法来存储集合中的元素，具有很好的存取和查找性能，大多数时候使用Set集合时使用这个实现类。

**特点：**

1. 不能保证元素的排列顺序，顺序可能与添加顺序不同。
2. HashSet 不是同步的，如果多个线程同时访问一个HashSet，假设有两个或者两个以上线程同时
   修改了HashSet集合时，则必须通过代码来保证其同步。

3. 集合元素值可以是null。

**介绍：**

当向 HashSet集合中存入一个元素时，HashSet会调用该对象的 hashCode()方法来得到该对象的hashCode值,然后根据该hashCode值决定该对象在HashSet中的存储位置。如果有两个元素通过equals()方法比较返回true，但它们的hashCode()方法返回值不相等，HashSet 将会把它们存储在不同的位置，依然可以添加成功。

HashSet集合判断两个元素相等的标准是两个对象通过 equals()方法比较相等，并且两个对象的 hashCode()方法返回值也相等。

**HashSet元素比较的源码：**

![image-20211126155126637](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211126155126637.png)

#### 重写equals和hashCode方法

**注意：**

1. 讲对象放入HashSet方法时，需要重写equals方法和hashcode方法，重写原则：equals返回true，hashcode为true。
2. 如果两个对象equals相等，但是hashcode不相等，这两个对象会存在Hash表不同的位置，并且都可以添加成功，违背了set集合的原则
3. 如果两个对象hashcode相等，但是equals不相等，那么这两个对象会存在同一hash表的位置，会导致性能下降。
4. 附：两个对象的hashcode相等，两个对象不一定相等。相等的两个对象的hashcode值一定相等。

```java
// 类A的equals方法总是返回true，但没有重写其hashCode()方法
class A
{
    public boolean equals(Object obj)
    {
        return true;
    }
}
// 类B的hashCode()方法总是返回1，但没有重写其equals()方法
class B
{
    public int hashCode()
    {
        return 1;
    }
}
// 类C的hashCode()方法总是返回2，且重写其equals()方法总是返回true
class C
{
    public int hashCode()
    {
        return 2;
    }
    public boolean equals(Object obj)
    {
        return true;
    }
}
public class HashSetTest
{
    public static void main(String[] args)
    {
        HashSet books = new HashSet();
        // 分别向books集合中添加两个A对象，两个B对象，两个C对象
        books.add(new A());
        books.add(new A());
        books.add(new B());
        books.add(new B());
        books.add(new C());
        books.add(new C());
        System.out.println(books);
    }
}
```

#### HashCode的重写原则

[(87条消息) hashCode()剖析_zhang19903848257的博客-CSDN博客](https://blog.csdn.net/zhang19903848257/article/details/118751574)

![image-20211126160540249](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211126160540249.png)

**重写hashCode()规则**

使用对象内有意义的属性值，计算成hashcode，再将在这有意义的hashcode进行组合后，返回一个int类型的数值。

1. 在程序运行过程中，同一个对象多次调用hashCode()方法应该返回相同的值。
2. 当两个对象通过equals()方法比较返回true时，这两个对象的 hashCode()方法应返回相等的值。
3. 对象中用作equals()方法比较标准的实例变量，都应该用于计算 hashCode值。

#### 添加可变对象

如果向HashSet 中添加一个可变对象后，后面程序修改了该可变对象的实例变量，则可能导致它与集合中的其他元素相同(即两个对象通过equals()方法比较返回true，两个对象的 hashCode值也相等),这就有可能导致HashSet中包含两个相同的对象。

```java
class R
{
	int count;
	public R(int count)
	{
		this.count = count;
	}
	public String toString()
	{
		return "R[count:" + count + "]";
	}
	public boolean equals(Object obj)
	{
		if(this == obj)
			return true;
		if (obj != null && obj.getClass() == R.class)
		{
			R r = (R)obj;
			return this.count == r.count;
		}
		return false;
	}
	public int hashCode()
	{
		return this.count;
	}
}
public class HashSetTest2
{
	public static void main(String[] args)
	{
		HashSet hs = new HashSet();
		hs.add(new R(5));
		hs.add(new R(-3));
		hs.add(new R(9));
		hs.add(new R(-2));
		// 打印HashSet集合，集合元素没有重复
		System.out.println(hs);
		// 取出第一个元素
		Iterator it = hs.iterator();
		R first = (R)it.next();
		// 为第一个元素的count实例变量赋值
		first.count = -3;    
		// 再次输出HashSet集合，集合元素有重复元素
		System.out.println(hs);
		// 删除count为-3的R对象
		hs.remove(new R(-3));  //删除的是hashcode和equals都符合的元素，应该是集合中的第二个元素
		// 可以看到被删除了一个R元素
		System.out.println(hs);
		System.out.println("hs是否包含count为-3的R对象？"
			+ hs.contains(new R(-3))); // 输出false，因为hashcode和equals都符合的元素已经被删除。
		System.out.println("hs是否包含count为-2的R对象？"
			+ hs.contains(new R(-2))); // 输出false   因为hashcode符合元素，equals却不符合。
	}
}
```

1. hs.remove(new R(-3));  
   1. 删除的是hashcode和equals都符合的元素，应该是集合中的第二个元素		
2. System.out.println("hs是否包含count为-3的R对象？"+ hs.contains(new R(-3)));
   1. 输出false，因为hashcode和equals都符合的元素已经被删除。

3. System.out.println("hs是否包含count为-2的R对象？"hs.contains(new R(-2)));
   1.  输出false   因为hashcode符合元素，equals却不符合。

最后：因为我们改变了HashSet集合中的元素的属性值，导致进行集合中的元素hashcode的比较和对象属性值的比较不一样，导致HashSet无法正确操作这些元素。

### LinkedHashSet实现类

HashSet的子类LinkedHashSet，LinkedHashSet集合也是**根据元素的 hashCode值来决定元素的存储位置，同时使用链表维护元素的次序**，这样使得元素看起来是以插入的顺序保存的。当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。注意：HashSet子类，同样不能添加重复元素。

LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。

```java
public class LinkedHashSetTest
{
	public static void main(String[] args)
	{
		LinkedHashSet books = new LinkedHashSet();
		books.add("疯狂Java讲义");
		books.add("轻量级Java EE企业应用实战");
		System.out.println(books);
		// 删除 疯狂Java讲义
		books.remove("疯狂Java讲义");
		// 重新添加 疯狂Java讲义
		books.add("疯狂Java讲义");
		System.out.println(books);
	}
}
运行结果：
[疯狂Java讲义, 轻量级Java EE企业应用实战]
[轻量级Java EE企业应用实战, 疯狂Java讲义]    
```

### TreeSet实现类

TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态(以大小进行排序，并不是插入顺序)。与HashSet集合相比，TreeSet提供了如下几个额外的方法。

**定制规则以及获取前一个，后一个元素**

1. Comparator comparator():如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator;如果TreeSet采用了自然排序，则返回null。
2. Object first():返回集合中的第一个元素。
3. Object last():返回集合中的最后一个元素。
4. Object lower(Object e):返回集合中位于指定元素之前的元素（即小于指定元素的最大元素，参考元素不需要是TreeSet集合里的元素)。
5. Object higher (Object e):返回集合中位于指定元素之后的元素（即大于指定元素的最小元素，参考元素不需要是TreeSet集合里的元素)。

**获取子集**

1. SortedSet subSet(Object fromElement, Object toElement):返回此Set的子集合,范围从fromElement(包含）到toElement（不包含)。
2. SortedSet headSet(Object toElement):返回此Set的子集，由小于toElement的元素组成。
3. SortedSet tailSet(Object fromElement):返回此Set 的子集，由大于或等fromElement 的元素组成

```java
class M
{
	int age;
	public M(int age)
	{
		this.age = age;
	}
	public String toString()
	{
		return "M [age:" + age + "]";
	}
}
public class TreeSetTest4
{
	public static void main(String[] args)
	{
		// 此处Lambda表达式的目标类型是Comparator
		TreeSet ts = new TreeSet((o1 , o2) ->
		{
			M m1 = (M)o1;
			M m2 = (M)o2;
			// 根据M对象的age属性来决定大小，age越大，M对象反而越小
			return m1.age > m2.age ? -1
				: m1.age < m2.age ? 1 : 0;
		});
		ts.add(new M(5));
		ts.add(new M(-3));
		ts.add(new M(9));
		System.out.println(ts);
	}
}

```

![image-20211127105105854](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211127105105854.png)

#### TreeSet的存储和排序

HashSet是采用Hash算法来决定元素存储位置的不同。

TreeSet采用红黑树的数据结构来存储集合元素。

TreeSet支持自然排序和定制排序两种方式。

##### 自然排序

TreeSet 会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按**升序**排列，这种方式就是自然排序。当compareTo返回0时，则认为他们相等，不让元素进入集合。

compareTo方法是Comparable接口提供的一个方法，使用自然排序时，实体类必须要实现Comparable接口。否则往集合中添加元素时，会出现报错。

**如果试图把一个对象添加到TreeSet时，则该对象的类必须实Comparable接口，否则程序将会抛出异常**。如下程序示范了这个错误。

###### 不实现Comparable接口

```java
class M
{
    int age;
    public M(int age)
    {
        this.age = age;
    }
    public String toString()
    {
        return "M [age:" + age + "]";
    }
}
public class TreeSetTest4
{
    public static void main(String[] args)
    {
        // 此处Lambda表达式的目标类型是Comparator
        TreeSet ts = new TreeSet();
        ts.add(new M(5));//运行没有问题
        ts.add(new M(-3));//产生异常。
        ts.add(new M(9));
        System.out.println(ts);
    }
}
```

注意：往集合中添加-3时，报错，因为此时集合中有元素，会调用Compare方法，但是没有实现Comparable接口，没有Compare方法。

添加第一个元素时，不进行比较，因此没有报错。

![image-20211127105737070](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211127105737070.png)

###### 添加字符串和其他类型对象

```java
public class TreeSetTest4 {
    public static void main(String[] args) {
        // 此处Lambda表达式的目标类型是Comparator
        TreeSet ts = new TreeSet();
        ts.add(new String("123456"));
        ts.add(new Date());
    }
}
```

报错：

![image-20211127154747533](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211127154747533.png)

字符串的Comparable接口已经实现，要求比较的是String类型的数据，而不是Object类型

![image-20211127154915175](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211127154915175.png)

在自定义实现Comparable接口的情况下（compareTo(Object obj)的实现没有强制类型转换），TreeSet支持添加多种类型的自定义类型对象，但是迭代集合时，不同类型的元素类型会发生ClassCastException异常。

###### 判断添加元素是否相等

通过compareTo方法，来判断返回值，返回值为0，则认为相等。

```java
class Z implements Comparable
{
    int age;
    public Z(int age)
    {
        this.age = age;
    }
    // 重写equals()方法，总是返回true
    public boolean equals(Object obj)
    {
        return true;
   
    }
    // 重写了compareTo(Object obj)方法，总是返回1,即不相等
    public int compareTo(Object obj)
    {
        return 1;
    }

    public int getAge() {
        return age;
    }
}
public class TreeSetTest2
{
    public static void main(String[] args)
    {
        TreeSet set = new TreeSet();
        Z z1 = new Z(6);
        set.add(z1);
        // 第二次添加同一个对象，输出true，表明添加成功
        System.out.println(set.add(z1));
        // 下面输出set集合，将看到有两个元素
        Iterator iterator = set.stream().iterator();
        int a =1;
        while (iterator.hasNext()){
            Z next =(Z) iterator.next();
            System.out.println("元素"+a+":"+next.getAge());
            a++;
        }
        // 修改set集合的第一个元素的age变量
        ((Z)(set.first())).age = 9;
        // 输出set集合的最后一个元素的age变量，将看到也变成了9
        System.out.println(((Z)(set.last())).age);
    }
}
```

我们向集合中添加了两个一样的对象，虽然equals方法返回true，但是compareTo返回的是1，因此集合认为他们不是同一个对象，因此可以正常添加。但是当compareTo返回0，equals返回false的时候，是可以添加进去的。

至于为什么两个元素同时修改，是因为我们两次添加的是对象z1，是同一个对象。

**注意：**

Comparter比较只关心compareTo的返回值，0则相同，1则不相同，与equals方法无关

规则：

1. compareTo1，equals true   判断不是同一个对象，可以添加
2. compareTo0， equals false  判断是同一个对象，不可以添加
3. 使用自定义对象时，我们要保证，重写的compareTo和equals方法的返回效果要一致。

###### 修改TreeSet中的对象属性

如果向TreeSet 中添加一个可变对象后，并且后面程序修改了该可变对象的实例变量，这将导致它与其他对象的大小顺序发生了改变，但**TreeSet 不会再次调整它们的顺序，甚至可能导致TreeSet 中保存的这两个对象通过compareTo(Object obj)方法比较返回0**。

```java
class S implements Comparable
{
    int count;
    public S(int count)
    {
        this.count = count;
    }
    public String toString()
    {
        return "S[count:" + count + "]";
    }
    // 重写equals方法，根据count来判断是否相等
    public boolean equals(Object obj)
    {
        if (this == obj)
        {
            return true;
        }
        if(obj != null && obj.getClass() == R.class)
        {
            S r = (S)obj;
            return r.count == this.count;
        }
        return false;
    }
    // 重写compareTo方法，根据count来比较大小
    public int compareTo(Object obj)
    {
        S r = (S)obj;
        return count > r.count ? 1 :
                count < r.count ? -1 : 0;
    }
}
public class TreeSetTest3
{
    public static void main(String[] args)
    {
        TreeSet ts = new TreeSet();
        ts.add(new S(5));
        ts.add(new S(-3));
        ts.add(new S(9));
        ts.add(new S(-2));
        // 打印TreeSet集合，集合元素是有序排列的
        System.out.println(ts);    // ①
        // 取出第一个元素
        S first = (S)ts.first();
        // 对第一个元素的count赋值
        first.count = 20;
        // 取出最后一个元素
        S last = (S)ts.last();
        // 对最后一个元素的count赋值，与第二个元素的count相同
        last.count = -2;
        // 再次输出将看到TreeSet里的元素处于无序状态，且有重复元素
        System.out.println(ts);  
        // 删除实例变量被改变的元素，删除失败
        System.out.println(ts.remove(new S(-2)));   // ③
        System.out.println(ts);
        // 删除实例变量没有被改变的元素，删除成功
        System.out.println(ts.remove(new S(5)));    //
        System.out.println(ts);
        System.out.println(ts.remove(new S(20))); //删除失败  因为该元素修改过
    }
}
结果：
[S[count:-3], S[count:-2], S[count:5], S[count:9]]  // 有序
[S[count:20], S[count:-2], S[count:5], S[count:-2]] //  修改后，编程了无序
false        //删除失败，修改后的元素与原集合中的元素重复，无法判断要删除那个元素
[S[count:20], S[count:-2], S[count:5], S[count:-2]]
true  //删除成功
[S[count:20], S[count:-2], S[count:-2]]
```

注意：

1. 修改了Tree集合中的值后，可能会造成与集合中的其他值一样，测试集合不会去重，并且不会重新排序
2. 修改后，如果和集合中其他元素的值重复，是无法进行删除的
3. Tree只能删除**没有修改且没有没有集合中没有重复**的对象
4. 附：测试过程中发现的问题
   1. 在 上述代码最后 System.out.println(ts.remove(new S(20))); 的这个操作，删除失败。
   2. 但是删除-2的操作，可以成功（集合中是有两个-2的），当我再次删除-2时，还是可以删除的。我此时删除20，也是可以删除的。
   3. 看资料，说的是删除成功后，发生了元素索引的重排（之后就可以排序了），但是出现了上述1,2的情况，总之往set里面存储元素时，不要修改元素的属性值。

总之：**往Set集合中添加元素时，不要修改元素的属性值。HashSet会造成地址值一样，而Tree可能造成compareTo返回值一样**

##### 定制排序

TreeSet的自然排序是根据集合元素的大小，将升序排列。如果需要实现定制排序，例如以降序排列，则可以通过Comparator接口。

该接口里包含一个int compare(T ol,T o2)方法，该方法用于比较ol和o2的大小:如果该方法返回正整数，则表明o1大于o2;如果该方法返回0，则表明ol等于o2;如果该方法返回负整数，则表明o1小于o2。

实现定制排序,则需要在创建TreeSet集合对象时,提供一个Comparator 对象与该TreeSet集合关联，由该Comparator对象负责集合元素的排序逻辑。Comparator是一个函数式接口，可使用Lambda表达式来代替Comparator对象。

```java
class M
{
	int age;
	public M(int age)
	{
		this.age = age;
	}
	public String toString()
	{
		return "M [age:" + age + "]";
	}
}
public class TreeSetTest4
{
	public static void main(String[] args)
	{
		// 此处Lambda表达式的目标类型是Comparator
		TreeSet ts = new TreeSet((o1 , o2) ->
		{
			M m1 = (M)o1;
			M m2 = (M)o2;
			// 根据M对象的age属性来决定大小，age越大，M对象反而越小
			return m1.age > m2.age ? -1
				: m1.age < m2.age ? 1 : 0;
		});
		ts.add(new M(5));
		ts.add(new M(-3));
		ts.add(new M(9));
		System.out.println(ts);
	}
}
9   5   -3
```

**注意：**

当通过Comparator对象（或Lambda表达式）来实现TreeSet 的定制排序时，依然不可以向TreeSet中添加类型不同的对象，否则会引发ClassCastException 异常。使用定制排序时，TreeSet对集合元素排序不管集合元素本身的大小，而是由Comparator对象（或Lambda表达式）负责集合元素的排序规则。TreeSet判断两个集合元素相等的标准是:通过Comparator (或Lambda表达式）比较两个元素返回了0，这样TreeSet 不会把第二个元素添加到集合中。

### EnumSet类

EnumSet是为枚举类设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。

**特征：**

1. 所有元素必须枚举类型，否则报错
2. 有序排列，按照枚举在枚举类中定义的顺序
3. EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效，因此EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作（如调用containsAll() 和retainAll()方法)时，如果其参数也是 EnumSet集合，则该批量操作的执行速度也非常快。
4. 不允许加入null元素，添加会报错。判断是否包含null元素不会报异常，删除空的元素会返回false

**构造器**

EnumSet类没有暴露任何构造器来创建该类的实例,程序应该通过它提供的类方法来创建EnumSet对象。

1. **EnumSet allOf(Class elementType):创建一个包含指定枚举类里所有枚举值的EnumSet集合。**
2. EnumSet complementOf(EnumSet s):创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来就是该枚举类的所有枚举值)。
3. EnumSet copyOf(Collection c):使用一个普通集合来创建EnumSet集合。（注意：拷贝的集合中只能是枚举类型的元素，如果有其他类型的元素直接报错）
4. **EnumSet copyOf(EnumSet s):创建一个与指定EnumSet具有相同元素类型、相同集合元素的**
   **EnumSet集合。**
5. **EnumSet noneOf(Class elementType):创建一个元素类型为指定枚举类型的空EnumSet。**
6. **EnumSet of(E first,E... rest):创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举**
   **值必须属于同一个枚举类。**
7. EnumSet range(E from，E to):创建一个包含从from枚举值到 to枚举值范围内所有枚举值的
   EnumSet集合。

```java
enum Season
{
	SPRING,SUMMER,FALL,WINTER
}
public class EnumSetTest
{
	public static void main(String[] args)
	{
		// 创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值
		EnumSet es1 = EnumSet.allOf(Season.class);
		System.out.println(es1); // 输出[SPRING,SUMMER,FALL,WINTER]
		// 创建一个EnumSet空集合，指定其集合元素是Season类的枚举值。
		EnumSet es2 = EnumSet.noneOf(Season.class);
		System.out.println(es2); // 输出[]
		// 手动添加两个元素
		es2.add(Season.WINTER);
		es2.add(Season.SPRING);
		System.out.println(es2); // 输出[SPRING,WINTER]
		// 以指定枚举值创建EnumSet集合
		EnumSet es3 = EnumSet.of(Season.SUMMER , Season.WINTER);
		System.out.println(es3); // 输出[SUMMER,WINTER]
		EnumSet es4 = EnumSet.range(Season.SUMMER , Season.WINTER);
		System.out.println(es4); // 输出[SUMMER,FALL,WINTER]
		// 新创建的EnumSet集合的元素和es4集合的元素有相同类型，
		// es5的集合元素 + es4集合元素 = Season枚举类的全部枚举值
		EnumSet es5 = EnumSet.complementOf(es4);
		System.out.println(es5); // 输出[SPRING]
        
    
        //拷贝集合
        Collection c = new HashSet();
		c.clear();
		c.add(Season.FALL);
		c.add(Season.SPRING);
		// 复制Collection集合中所有元素来创建EnumSet集合
		EnumSet enumSet = EnumSet.copyOf(c); 
		System.out.println(enumSet); // 输出[SPRING,FALL]
		c.add("疯狂Java讲义");
		c.add("轻量级Java EE企业应用实战");
		// 下面代码出现异常：因为c集合里的元素不是全部都为枚举值
		enumSet = EnumSet.copyOf(c);  
	}
}
```

### Set实现类对比

1. HashSet的性能总是比TreeSet好（特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet。

2. HashSet的一个子类:LinkedHashSet，对于普通的插入、删除操作，LinkedHashSet 比 HashSet要略微慢一点，这是由维护链表所带来的额外开销造成的，但由于有了链表，遍历LinkedHashSet 会更快。

3. EnumSet 是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素。

4. Set的三个实现类HashSet、TreeSet和EnumSet都是线程不安全的。如果有多个线程同时访问一个Set集合，并且有超过一个线程修改了该Set集合，则必须手动保证该Set集合的同步性。可以通过Collections 工具类的 synchronizedSortedSet方法来“包装”该Set集合。此操作最好在创建时进行，以防止对Set集合的意外非同步访问。

   1. ```java
              SortedSet<Object> set = Collections.synchronizedSortedSet(new TreeSet<>());
              NavigableSet<Object> objects = Collections.synchronizedNavigableSet(new TreeSet<>());
              Collection<Object> sets = Collections.synchronizedCollection(new LinkedHashSet<>());
      ```

## 5. Map集合

Map用于保存具有**映射关系的数据**,因此Map集合里保存着两组值， key和value，key和 value都
可以是任何引用类型的数据。

**特征：**

1. Map的key不允许重复。
2. Map里的数据分为key数据组，value数据组，key和 value之间存在单向一对一关系，通过指定的key，总能找到唯一的value。从 Map中取出数据时，只要给出指定的key，就可以取出对应的value。
3. 把Map里的所有key放在一起来看，它们就组成了一个Set集合（所有的key没有顺序，key与 key之间不能重复)，Map包含了一个keySet()方法，用于返回Map里所有key组成的Set集合。

4. Map里 key集和Set集合里元素的存储形式很像，Map子类和Set子类在名字上也相似，Set接口下有HashSet、LinkedHashSet、SortedSet(接口)、TreeSet、EnumSet等子接口和实现类， Map接口下有 HashMap、LinkedHashMap、SortedMap(接口)、TreeMap、EnumMap等子接口和实现类。Map 的这些实现类和子接口中 key集的存储形式和对应Set集合中元素的存储形式完全相同。
5. Map的所有值类似于一个List，可以重复，可以根据索引去查。

**Set与Map的关系：**

Set与 Map 之间的关系非常密切。虽然Map中放的元素是key-value对，Set集合中放的元素是单个对象,但如果把key-value对中的value当成key的附庸: key在哪里, value就跟在哪里，这样就可以像对待Set一样来对待Map了。事实上，Map提供了一个Entry内部类来封装key-value对，而计算Entry存储时则只考虑Entry封装的key。Java是先实现了Map，然后通过包装一个所有 value都为null 的 Map就实现了Set集合。

**常用方法：**

1. void clear(:删除该Map对象中的所有key-value对。
2. **boolean containsKey(Object key):查询Map中是否包含指定的 key，如果包含则返回 true。**
3. boolean containsValue(Object value):查询Map中是否包含一个或多个value，如果包含则返回
   true.
4. Set entrySet():返回 Map中包含的 key-value对所组成的Set集合，每个集合元素都是Map.Entry(Entry是 Map 的内部类)对象。
5. **Object put(Object key, Object value):添加一个key-value对，如果当前Map中已有一个与该key**
   **相等的key-value对，则新的key-value对会覆盖原来的key-value对。**
6. **Object get(Object key):返回指定key所对应的value;如果此 Map中不包含该key，则返回null。**
7. **Object remove(Object key):删除指定key所对应的 key-value对,返回被删除key所关联的 value,如果该key不存在，则返回null。**
8. **Set keySet(）:返回该Map中所有key组成的Set集合。**
9. **boolean isEmpty():查询该Map是否为空(即不包含任何key-value对)，如果为空则返回true。**
10. void putAll(Map m):将指定Map中的key-value对复制到本Map 中。
11. **int size():返回该Map里的key-value对的个数。**

13. **Collection values():返回该Map里所有 value组成的Collection。**

**Map接口提供的实现类**

1. HashMap
2.  Hashtable
3. HashMap 的子类LinkedHashMap
4. 还有SortedMap子接口及该接口的实现类TreeMap
5. WeakHashMap 、ldentityHashMap等。

**Map内部类Entry**
该类封装了一个key-value对。Entry包含三个方法。

1. Object getKey():返回该Entry里包含的key值。
2. Object getValue(): 返回该Entry里包含的value值。
3. Object setValue(V value):设置该Entry里包含的value值，并返回新设置的value值。

```java
public class MapTest
{
	public static void main(String[] args)
	{
		Map map = new HashMap();
		// 成对放入多个key-value对
		map.put("疯狂Java讲义" , 109);
		map.put("疯狂iOS讲义" , 10);
		map.put("疯狂Ajax讲义" , 79);
		// 多次放入的key-value对中value可以重复
		map.put("轻量级Java EE企业应用实战" , 99);
		// 放入重复的key时，新的value会覆盖原有的value
		// 如果新的value覆盖了原有的value，该方法返回被覆盖的value
		System.out.println(map.put("疯狂iOS讲义" , 99)); // 输出10
		System.out.println(map); // 输出的Map集合包含4个key-value对
		// 判断是否包含指定key
		System.out.println("是否包含值为 疯狂iOS讲义 key："
			+ map.containsKey("疯狂iOS讲义")); // 输出true
		// 判断是否包含指定value
		System.out.println("是否包含值为 99 value："
			+ map.containsValue(99)); // 输出true
		// 获取Map集合的所有key组成的集合，通过遍历key来实现遍历所有key-value对
		for (Object key : map.keySet() )
		{
			// map.get(key)方法获取指定key对应的value
			System.out.println(key + "-->" + map.get(key));
		}
		map.remove("疯狂Ajax讲义"); // 根据key来删除key-value对。
		System.out.println(map); // 输出结果不再包含 疯狂Ajax讲义=79 的key-value对
	}
}
```

### Java8 为Map新增的方法

1. boolean remove(Object key, Object value):这是Java8新增的方法，删除指定key、value所对应的 key-value对。如果从该Map中成功地删除该key-value对，该方法返回 true，否则返回false。
2. Object compute(Object key,BiFunction remappingFunction):该方法使用remappingFunction根据原key-value对计算一个新value。
   1. 只要新value不为null，就使用新value覆盖原value;
   2. 如果原value不为null，但新value为null，则删除原 key-value对;
   3. 如果原value、新value同时为null,那么该方法不改变任何key-value对，直接返回null。
3. Object computelfAbsent(Object key，Function mappingFunction):如果传给该方法的 key参数在Map中对应的value为 null，则使用mappingFunction根据key计算一个新的结果，如果计算结果不为null，则用计算结果覆盖原有的value。如果原Map原来不包括该key，那么该方法可能会添加一组 key-value对。
4. Object computeIfPresent(Object key, BiFunction remappingFunction):如果传给该方法的 key 参数在Map中对应的value不为null，该方法将使用remappingFunction根据原key、value计算一个新的结果，如果计算结果不为null，则使用该结果覆盖原来的 value;如果计算结果为null，则删除原key-value对。
5. **void forEach(BiConsumer action):该方法是Java 8为Map新增的一个遍历key-value对的方法，通过该方法可以更简洁地遍历Map 的key-value对。**
6. Object getOrDefault(Object key, V defaultValue):获取指定key对应的value。如果该key 不存在，则返回defaultValue。
7. **Object merge(Object key, Object value,BiFunction remappingFunction):该方法会先根据key 参数获取该Map中对应的value。如果获取的value为null，则直接用传入的value覆盖原有的value(在这种情况下，可能要添加一组key-value 对);如果获取的 value不为 null，则使用remappingFunction函数根据原value、新value计算一个新的结果，并用得到的结果去覆盖原有的value。**
8. **Object putIfAbsent(Object key, Object value):该方法会自动检测指定key对应的value是否为null，如果该key对应的 value为null，该方法将会用新value 代替原来的null 值。**
9. **Object replace(Object key, Object value):将Map中指定key对应的value替换成新value。与传统put)方法不同的是，该方法不可能添加新的key-value对。如果尝试替换的key在原Map中不存在，该方法不会添加 key-value对，而是返回null。**
10. boolean replace(K key, V oldValue,V newValue):将Map中指定key-value对的原value替换成新value。如果在 Map中找到指定的 key-value对，则执行替换并返回true，否则返回 false。
11. replaceAll(BiFunction function):该方法使用BiFunction对原 key-value对执行计算，并将计算结果作为该key-value对的value值。

```java
public class MapTest2
{
	public static void main(String[] args)
	{
		Map map = new HashMap();
		// 成对放入多个key-value对
		map.put("疯狂Java讲义" , 109);
		map.put("疯狂iOS讲义" , 99);
		map.put("疯狂Ajax讲义" , 79);
		// 尝试替换key为"疯狂XML讲义"的value，由于原Map中没有对应的key，
		// 因此对Map没有改变，不会添加新的key-value对
		map.replace("疯狂XML讲义" , 66);
		System.out.println(map);
		// 使用原value与参数计算出来的结果覆盖原有的value
		map.merge("疯狂iOS讲义" , 10 ,
			(oldVal , param) -> (Integer)oldVal + (Integer)param);
		System.out.println(map); // "疯狂iOS讲义"的value增大了10
		// 当key为"Java"对应的value为null（或不存在时），使用计算的结果作为新value
		map.computeIfAbsent("Java" , (key)->((String)key).length());
		System.out.println(map); // map中添加了 Java=4 这组key-value对
		// 当key为"Java"对应的value存在时，使用计算的结果作为新value
		map.computeIfPresent("Java",
			(key , value) -> (Integer)value * (Integer)value);
		System.out.println(map); // map中 Java=4 变成 Java=16
	}
}
```



## 扩展：

#### Comparable接口

Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如 obj1.compareTo(obj2)，如果该方法返回0，则表明这两个对象相等;如果该方法返回一个正整数，则表明objl大于obj2;如果该方法返回一个负整数，则表明obj1小于obj2。

Java 的一些常用类已经实现了Comparable接口，并提供了比较大小的标准。下面是实现了Comparable接口的常用类。

BigDecimal、BigInteger 以及所有的数值型对应的包装类:按它们对应的数值大小进行比较。

Character:按字符的UNICODE值进行比较。
Boolean: true对应的包装类实例大于false对应的包装类实例。

String:按字符串中字符的UNICODE值进行比较。

Date、Time:后面的时间、日期比前面的时间、日期大。

#### **Comparable和Comparator区别**

[Java基础系列-Comparable和Comparator - 简书 (jianshu.com)](https://www.jianshu.com/p/f9870fd05958)

[(87条消息) java comparator 升序、降序、倒序从源码角度理解_山鬼谣的专栏-CSDN博客_comparator 倒序](https://blog.csdn.net/u013066244/article/details/78997869)

Comparator的默认升序：

< return -1

 = return 0 

">" return 1

Comparator的默认降序：

< return 1 

= return 0 

"<" return -1

![image-20211127105059154](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211127105059154.png)











