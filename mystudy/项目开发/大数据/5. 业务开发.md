# 1. 主要任务

本次任务是在线编程模块，主要实现代码的在线编程并运行，适配编程语言有python，scala，R语言三种。

一个算法任务有多个文件组成，用户可增删改查，下载这些文件。

用户提交的文件，经后端编译运行后，返回给用户。

# 2 . 难点

1. 文件上传的存储，文件下载打包
2. minio的配置
3. 消息队列的配置
4. k8s的配置
5. 用户提交代码时，代码的编译运行需要放在k8s的pod中执行，通过消息队列，排队创建pod

# 3. 业务场景

开发算法编程模块，涉及接口：

1. 新增算法任务
2. 编辑算法任务
   1. 获取算法详情（获取所有文件）
   2. 保存文件
   3. 编辑文件
   4. 删除文件
   5. 重命名文件
   6. 下载文件
3. 提交运行
4. 删除算法任务
5. 获取算法任务列表

# 4. 业务实现

## 1. 总体思路

**任务状态：**0. 未提交 1. 排队中 2. 执行中 3. 已完成 4. 失败 5.  已终止

**总流程：**

![image-20220802202012686](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220802202012686.png)

任务创建后，提交任务，创建任务消息实体，交给消息队列排队，消费时，先确定服务器中job的数量，如果job的数量小于服务器的最大承受限制，则消费该消息，并异步创建job实体，如果消息有误或超过数量限制，则拒绝该消息消费，让消息重新入队，此时会产生一个问题，被拒绝的消息还会排在队列的队头位置，造成该消息在短时间内一直被重复的消费拒绝，因此，在此可以设置一段休眠时间。创建pod的时候，需要配置pod的关键信息，详细在具体之后的业务编写中会写到。

**表关系：**

![image-20220802211532083](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220802211532083.png)

## 2. 创建任务

### 功能分析

**实现效果：**

![image-20220802204945529](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220802204945529.png)

**主要功能：**

1. 一个任务有多个文件和文件夹，可以增删改查这些文件（文件都是文本文件）
2. 必须有一个主文件
3. 有文件总大小限制，不可超过1G

**实现思路：**

1. 使用数据库保存文件名路径和文件内容，如上面图中的file.py，在数据库存储时，存储的文件名路径是：code/file.py
2. 不保存文件夹的名称，回显时，通过文件名路径推出文件名称
3. 如果只创建了文件夹，文件夹中没有任何文件，是不保存文件夹的信息的，也没有必要保存。

### 核心代码

#### 文件大小

1. 文件大小获取：file.setFileSize(file.getContent().getBytes(StandardCharsets.UTF_8).length);

   ```java
     public void fileSize() throws IOException {
           //方式一：通过文件获取
           String filePath = "file/code/python/Hello.python";
           File file = new File("file/code/python/Hello.python").getCanonicalFile();
           if (!file.getParentFile().exists()){
               file.getParentFile().mkdirs();
           }
           try (Writer writer = new FileWriter(filePath)){
               writer.write("1111111111111111111111111111111111111111111111111111");
           }catch (Exception e){
               e.printStackTrace();
               System.out.println(e);
           }
           FileInputStream fis = new FileInputStream(file);
           FileChannel fc = fis.getChannel();
           long size = fc.size();
           System.out.println("fileSize"+size);
           byte[] buffer = new byte[1024];
           int hasRead;
           StringBuffer stringBuffer = new StringBuffer();
           while ((hasRead = fis.read(buffer))>0){
               String s = new String(buffer, 0, hasRead);
               stringBuffer.append(s);
           }
           //方式二：通过字符串的字节长度获取
           int length = stringBuffer.toString().getBytes(StandardCharsets.UTF_8).length;
           System.out.println("length:"+length);
       }
   ```

2. 两种方式计算出的大小相差不大，问题是使用fc.size返回的类型是long，而第二种方式返回的是int，受限于长度，使用第二种方式，返回的类型是int，int的话存储的最大容量是2G，也就是说，使用int类型时，你的文件最大容量不能超过2G，不过正常情况下，一个文件也不会这么长。

#### 创建默认文件

每次创建新任务时，都会创建run.py和run.sh两个默认文件

this.getClass().getResourceAsStream(runFilePath);文件是在resource目录下。

![image-20220803104857053](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220803104857053.png)

```java
    private String runFileName = "run.python";
    private String shFileName = "run.sh";
    private String runFilePath = "/file/code/python/run.py";
    private String shFilePath = "/file/code/python/run.sh";    

    @Override
    public List<TaskFiles> createDefaultFiles(Long recordId) throws IOException {
        InputStream runStream = this.getClass().getResourceAsStream(runFilePath);
        InputStream shStream = this.getClass().getResourceAsStream(shFilePath);
        String runCon = readStream(runStream);
        String shCon = readStream(shStream);
        TaskFiles runFile = new TaskFiles();
        runFile.setTaskRecordId(recordId)
                .setFileName(runFileName)
                .setFileSize(runCon.getBytes(StandardCharsets.UTF_8).length)
                .setMain(true)
                .setContent(runCon);
        TaskFiles shFile = new TaskFiles();
        shFile.setTaskRecordId(recordId)
                .setFileName(shFileName)
                .setFileSize(shCon.getBytes(StandardCharsets.UTF_8).length)
                .setMain(false)
                .setContent(shCon);
        List<TaskFiles> taskFiles = new ArrayList<>();
        taskFiles.add(runFile);
        taskFiles.add(shFile);
        return taskFiles;
    }


    default String readStream(InputStream fileStream) throws IOException {
        int readLen;
        byte[] bytes = new byte[1024];
        StringBuffer conBuf = new StringBuffer();
        while ((readLen = fileStream.read(bytes)) > 0) {
            String text = new String(bytes, 0, readLen);
            conBuf.append(text);
        }
        return conBuf.toString();
    }
```



#### 获取任务文件详情

**返回格式：**

```java
public class TaskFilesDetailDTO {

    @ApiModelProperty(value = "id")
    private Long id;

    @ApiModelProperty(value = "文件名")
    private String name;

    @ApiModelProperty(value = "文件内容")
    private String content;
    
    @ApiModelProperty(value = "文件类型")
    private String fileType;
    

    @ApiModelProperty(value = "文件大小")
    private Integer fileSize;

    @ApiModelProperty(value = "是否是文件夹")
    private Boolean isLeaf;

    @ApiModelProperty(value = "是否是主文件(默认不是)")
    private Boolean main;

    @ApiModelProperty(value = "子文件")
    private List<TaskFilesDetailDTO> children;

}
```

1. 将所有文件记录记载进内存，筛选出所有的文件路径，以树状的形式返回给前端。
2. 入参`List<TaskFiles> taskFiles`即为数据库中查出来的记录
3. 使用` Map<String, TaskFilesDetailDTO> taskNode = new HashMap<>();`来筛选出所有文件夹和文件。key为子路径，如果路径为train/file/code.fie，那么map中会有三个key，分别是：train       train/file         train/file/code.file ,这样就可以删选唯一的路径和文件。
4. 根路径为""，因此最后返回前端时，只需要返回根的子文件即可。

```java
private List<TaskFilesDetailDTO> getCodeDirectory(List<TaskFiles> taskFiles, boolean needContent) {
        if (taskFiles == null || taskFiles.size() == 0) {
            return new ArrayList<>();
        }
        //存储文件路径及对应的文件
        Map<String, TaskFilesDetailDTO> taskNode = new HashMap<>();
        //默认以""为根
        TaskFilesDetailDTO root = new TaskFilesDetailDTO()
                .setName("")
                .setChildren(new ArrayList<>());
        taskNode.put(root.getName(), root);
        //生成文件和文件夹
        for (TaskFiles file : taskFiles) {
            String[] split = file.getFileName().split("/");
            //当前文件的前缀，不管是哪一级文件，一定有一个前缀。
            String prefix = root.getName();
            for (String path : split) {
                //判断map中是否已存在该文件或文件夹，存在跳过，不存在就插入.注意：此处的  prefix=prefix+path+"/" 还用于下一个文件的前缀。
                TaskFilesDetailDTO curNode = taskNode.get(prefix + path + "/");
                if (curNode != null) {
                    prefix = prefix + path + "/";
                    continue;
                }
                TaskFilesDetailDTO subNode = new TaskFilesDetailDTO();
                subNode.setId(file.getId());
                subNode.setChildren(new ArrayList<>());
                if (path.contains(".")) {
                    //文件
                    subNode.setName(path);
                    if (needContent) {
                        subNode.setContent(file.getContent());
                    }
                    subNode.setFileType(path.substring(path.indexOf(".")));
                    subNode.setFileSize(file.getFileSize());
                    subNode.setMain(file.getMain());
                    subNode.setIsLeaf(true);

                } else {
                    //文件夹
                    subNode.setName(path);
//                    subNode.setContent("");
                    subNode.setFileType("");
                    subNode.setFileSize(0);
                    subNode.setMain(false);
                    subNode.setIsLeaf(false);
                }
                //获取前缀对象, 默认前缀为""，因此前缀不可能为null
                TaskFilesDetailDTO perNode = taskNode.get(prefix);
                perNode.getChildren().add(subNode);
                //将进的文件/文件夹路径放入map
                prefix = prefix + path + "/";
                taskNode.put(prefix, subNode);
            }
        }
        return root.getChildren();
    }
```

## 3. 提交任务

1. 生成文件到minio服务器
2. 发送消息到队列
3. 创建k8s对象

### 1. 提交文件

1. 之前文件的内容都是在数据库中存储，提交任务时，需要将这些文件记录变为真实的文件输出到服务器上。
2. 文件创建时，直接通过nfs创建到minio上，方便之后文件下载，创建完成之后，创建自定义的k8s参数对象，并发送到消息队列，排队创建k8s实体。
3. 创建pod的时候，需要挂载代码文件，数据集文件，日志文件，脚本文件等，最后运行pod
4. 生成文件的时候，因为不同语言的代码的配置有些不同，因此采用工厂设置模式。
5. 用户每次提交时，都会生成一个uuid作为一个用户的唯一路径在minio中，用于任务

**整体逻辑**

```java
@Override
    public void submitTask(TaskFileSaveVO taskFileSaveVO) throws IOException {
        //校验
        Task task = judgeTask(taskFileSaveVO.getTaskId());
        judgeDataScope(task.getUserId());
        //一个任务，一个人只能有一条正在执行的任务记录
        int i = recordService.selectUnExecTaskRecord(taskFileSaveVO.getTaskId());
        if (i > 0) {
            throw new ServiceException("当前已有正在运行的记录,运行完成后即可再次提交");
        }
        TaskRecord record = judgeUncommitTaskRecord(taskFileSaveVO.getTaskId());
        if (StringUtils.isNotBlank(taskFileSaveVO.getRemarks())) {
            record.setRemarks(taskFileSaveVO.getRemarks());
        }
        if (StringUtils.isNotBlank(taskFileSaveVO.getExecCommand())) {
            record.setExecCommand(taskFileSaveVO.getExecCommand());
        }
        recordService.updateById(record);
        List<TaskFiles> taskFiles = taskFilesMapper.selectList(Wrappers.<TaskFiles>lambdaQuery().eq(TaskFiles::getTaskRecordId, record.getId()));
        //文件在服务器存储路径
        String dirPath = "";
        String fileUid = UUID.randomUUID().toString().replace("-", "").toLowerCase();
        switch (CodeLanguageEnum.getCodeLanguage(task.getCodeLanguage())) {
            case PYTHON:
                CodeFactory pythonCodeFactory = new PythonCodeFactory();
                Code python = pythonCodeFactory.product();
                dirPath = python.submitFiles(taskFiles, nfsBasePath, fileUid);
                break;
            case SCALA:
                CodeFactory scalaCodeFactory = new ScalaCodeFactory();
                Code scala = scalaCodeFactory.product();
                dirPath = scala.submitFiles(taskFiles, nfsBasePath, fileUid);
                break;
            case R:
                CodeFactory rCodeFactory = new RCodeFactory();
                Code r = rCodeFactory.product();
                dirPath = r.submitFiles(taskFiles, nfsBasePath, fileUid);
                break;
            default:
                throw new ServerException("创建默认文件失败");
        }
        //文件在服务器存储的绝对路径
        record.setJobUid(fileUid);
        record.setDirPath(dirPath);
        String s = dirPath + "/log/" + fileUid + ".log";
        String substring = s.substring(1, s.length());
        record.setResLogPath(substring);
        record.setSubmitTime(LocalDateTime.now());
        record.setTaskStatus(TaskStatusEnum.NEW_COMMIT.getStatus());
        record.setDownloadPath(dirPath);
        if (!recordService.updateById(record)) {
            throw new ServerException("提交失败，请重试");
        }
        //消息入队列
        sendMessageToQueue(record);
    }
```

**生成文件的代码**

其中dirPath即为minio中该任务所有文件存储的基本路径

注意：dirPath如果以/开头，在windows中是不生成文件目录的，在linux中是以根目录为起始目录创建文件的（这里是以/开头）

如果是以非/开头，在windows中是在项目的根目录下创建文件的。

![image-20220803105154001](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220803105154001.png)

```java
  default String createFile(List<TaskFiles> taskFiles, String nfsPath, String basePath, String fileUid) {
        String dirPath = nfsPath + basePath + fileUid;
        //创建数据集文件夹
        String dataPath = dirPath + "/data";  //数据集文件
        String logPath = dirPath + "/log/" + fileUid + ".log"; //日志文件
        String codePath = dirPath + "/code";  //代码文件
        makeDir(dataPath);
        makeDir(codePath);
        makeFile(logPath, "");
        //创建代码文件
        for (TaskFiles taskFile : taskFiles) {
            String fileName = taskFile.getFileName();
            if (fileName != null && fileName != "") {
                String filePath = codePath + "/" + fileName;
                makeFile(filePath, taskFile.getContent());
            }
        }
        return dirPath;
    }

    default void makeDir(String filePath) {
        File file = null;
        try {
            file = new File(filePath).getCanonicalFile();
            if (!file.getCanonicalFile().exists()) {
                file.mkdirs();
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    default void makeFile(String filePath, String content) {
        try {
            File file = new File(filePath).getCanonicalFile();
            if (!file.getParentFile().exists()) {
                file.getParentFile().mkdirs();
            }
            try (Writer writer = new FileWriter(filePath)) {
                writer.write(content);
            }
        } catch (IOException e) {
            throw new ServiceException("提交失败,请重新尝试");
        }
    }
```

### 2. 消息队列设置

目的：削峰，避免短时间内大量任务提交，搞垮服务器

总体流程图：

![image-20220803143924157](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220803143924157.png)

细节：

![image-20220803153145154](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220803153145154.png)

消费者设定为一次消费一条记录，采取手动的发布确认机制，如果接受过来的消息无误，则同意消费，如果接受过来的数据有问题，则拒绝消费，消费直接进入死信队列，在死信队列中修改运行状态。（注意，死信队列中也需要手动确认）如果是服务器资源不够，则拒绝消费，并让消费重返队列，此时一个问题是消息会回到队头，消费者又一直在监听当前队列，如果短时间内该信息没有被确认掉，该消息会被一直的重复调用，因此在此可以设置一段休眠时间。

#### 1. 安装及基本应用

**rabbitmq服务搭建以及基本配置：**https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/%E5%A4%A7%E6%95%B0%E6%8D%AE/k8s/10.%20rabbitmq%E5%AE%89%E8%A3%85.md

#### 2. 基本配置

1. 引入依赖

   ```xml
           <!--消息队列-->
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-amqp</artifactId>
           </dependency>
   ```

2. 创建基本配置

   ```java
   spring: 
     rabbitmq:
       host: 192.168.41.34
       port: 31382
       username: coder
       password: train@coder
       virtual-host: compile-code
       publisher-confirm-type: correlated   # 表示消息成功到达Broker后触发ConfirmCalllBack回调
       publisher-returns: true    # true表示开启失败回调，开启后当消息无法路由到指定队列时会触发ReturnCallback回调。
       template:
         mandatory: true
       listener:
         simple:
           concurrency: 1 # 并发数
           max-concurrency: 1  # 最大并发数
           prefetch: 1 # 预处理个数，即消费者所能保持最大未确认消费的数量
           acknowledge-mode: manual   # 手动后ack
           default-requeue-rejected: false   # 被拒绝的消息是否重新入队。   如果手动ack，设置的requeue的信息大于在此设置的优先级
   ```

3. 队列，交换机，路由key等信息

   ```java
   @Configuration
   public class CompileCodeConfig {
       //springboot 会为我们自动初始化这个CachingConnectionFactory，默认情况下，消费者监听的为此工厂的配置，也可以自定义。
       //队列信息
       public static final String COMPILE_CODE_EXCHANGE = "compile.code.direct";
       public static final String COMPILE_CODE_QUEUE = "compile.code.queue";
       public static final String COMPILE_CODE_ROUTEKEY = "compile.code.routekey";
       //死信队列信息
       public static final String COMPILE_CODE_DEAD_EXCHANGE = "compile.code.dead.direct";
       public static final String COMPILE_CODE_DEAD_QUEUE = "compile.code.dead.queue";
       public static final String COMPILE_CODE_DEAD_KEY = "compile.code.dead.key";
   
       @Autowired
       private CachingConnectionFactory connectionFactory;
   
       //普通交换机
       @Bean
       public DirectExchange CompileCodeExchange() {
           //1.交换机名称
           //2.交换机的类型
           //3.是否需要持久化
           //4.是否需要自动删除
           //5.其他参数
           return ExchangeBuilder.directExchange(CompileCodeConfig.COMPILE_CODE_EXCHANGE).durable(true).build();
       }
   
       //普通队列,普通队列绑定死信交换机
       @Bean
       public Queue CompileCodeQueue() {
           Map<String, Object> args = new HashMap<>(2);
           //声明当前队列绑定的死信交换机
           args.put("x-dead-letter-exchange", CompileCodeConfig.COMPILE_CODE_DEAD_EXCHANGE);
           //声明当前队列的死信路由 key
           args.put("x-dead-letter-routing-key", CompileCodeConfig.COMPILE_CODE_DEAD_KEY);
           //druable 持久化  后面输入队列的名称
           return QueueBuilder
                   .durable(CompileCodeConfig.COMPILE_CODE_QUEUE)
                   .withArguments(args).build();
       }
   
       //普通队列绑定普通交换机
       @Bean
       public Binding bindingCompileCodeQueueToExchange() {
           return BindingBuilder
                   .bind(CompileCodeQueue())
                   .to(CompileCodeExchange())
                   .with(CompileCodeConfig.COMPILE_CODE_ROUTEKEY);
       }
   
   
       //死信交换机
       @Bean("compileCodeDeadDirect")
       public DirectExchange compileCodeDeadDirect() {
           System.out.println("创建交换机");
           return (DirectExchange) ExchangeBuilder
                   .directExchange(CompileCodeConfig.COMPILE_CODE_DEAD_EXCHANGE)
                   .durable(true)
                   .build();
       }
   
   
       //死信队列
       @Bean("compileCodeDeadQueue")
       public Queue compileCodeDeadQueue() {
           return new Queue(CompileCodeConfig.COMPILE_CODE_DEAD_QUEUE);
       }
   
   
       //死信队列与死信交换机进行绑定
       @Bean
       public Binding bindingExamProcessQueueToExchange(@Qualifier("compileCodeDeadQueue") Queue queue, @Qualifier("compileCodeDeadDirect") DirectExchange customExchange) {
           return BindingBuilder
                   .bind(queue)
                   .to(customExchange)
                   .with(CompileCodeConfig.COMPILE_CODE_DEAD_KEY);
       }
   }
   ```

#### 3. ConfirmCalllBack和ReturnCallback回调

```java
@Component
@Slf4j
public class CompileCodeCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;


    //将创建的消息接收的回调对象添加到rabbitTemplate中。
    @PostConstruct
    public void init() {
        rabbitTemplate.setConfirmCallback(this);
        //设置当消息灭有路由到指定队列时的处理方案。   //true：重回生产者   //false：丢失（默认） 返回的消息可以从ReturnCallback回调中获取
        //rabbitTemplate.setMandatory(true);
        rabbitTemplate.setReturnsCallback(this);
    }

    /**
     * 交换机确定是否收到消息的回调方法
     * 1.发消息  交换机成功接受到了  回调
     * 1.1CorrelationData保存回调消息的ID及相关信息
     * 1.2交换机收到消息   ack：true
     * 1.3cause 失败的原因  cause：null
     * 2.发消息  交换机没有成功接收   回调
     * 2.1CorrelationData保存回调消息的ID及相关信息
     * 2.2交换机收到消息   ack：false
     * 2.3 cause：失败的原因
     */

    //消息未到达交换机
    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        System.out.println(correlationData);
        String id = correlationData == null ? "" : correlationData.getId();
        if (ack) {
            log.info("交换机已经收到 id 为:{}的消息", id);
        } else {
            log.info("交换机还未收到 id 为:{}消息,由于原因:{}", id, cause);
        }
    }



    //消息到达交换机，但是没有对应的队列。
    @Override
    public void returnedMessage(ReturnedMessage returned) {
        Message message = returned.getMessage();
        String replyText = returned.getReplyText();
        String routingKey = returned.getRoutingKey();
        String exchange = returned.getExchange();
        log.error(" 消 息 {}, 被 交 换 机 {} 退 回 ， 退 回 原 因 :{}, 路 由 key:{}", new
                String(message.getBody()), exchange, replyText, routingKey);
    }
}
```

#### 4. 生产者配置

```java
@Component
@Slf4j
@AllArgsConstructor
public class CompileCodeSender {

    private final RabbitTemplate rabbitTemplate;


    public void sendMessage(CreateCodeJobDto jobDto) {
        log.info("发送消息到队列"+jobDto);
        rabbitTemplate.convertAndSend(CompileCodeConfig.COMPILE_CODE_EXCHANGE, CompileCodeConfig.COMPILE_CODE_ROUTEKEY, JSON.toJSONString(jobDto), new MessagePostProcessor() {
            @Override
            public Message postProcessMessage(Message message) throws AmqpException {
                MessageProperties messageProperties = message.getMessageProperties();
                //设置持久化
                messageProperties.setDeliveryMode(MessageProperties.DEFAULT_DELIVERY_MODE);
                //优先级
                messageProperties.setPriority(2);
                //过期时间,默认设置为一天
                final int expireTime = 3600000;
                messageProperties.setExpiration(String.valueOf(expireTime));
                return message;
            }
        }, new CorrelationData(UUID.randomUUID().toString()));
    }


}
```

#### 5. 消费者配置

```java
@Component
@Slf4j
@AllArgsConstructor
public class CompileCodeCustomer {


    private final TaskRecordMapper recordMapper;
    private final CompileCodeSubmit codeSubmit;
    private final K8sService k8sService;
    private final K8sRunCodeConfig runCodeConfig;
    private final RedisService redisService;


    @RabbitListener(queues = CompileCodeConfig.COMPILE_CODE_QUEUE)
    public void handleCode(Message message, Channel channel) {
        //服务器可承受的最大job数量
        int jobMaxNum = runCodeConfig.getJobMaxNum();
        TaskRecord taskRecord = null;
        try {
            String mes = new String(message.getBody(), "UTF-8");
            log.info("收到消息:{}", mes);
            CreateCodeJobDto createCodeJobDto = JSONObject.parseObject(mes, CreateCodeJobDto.class);
            taskRecord = recordMapper.selectOne(Wrappers.<TaskRecord>lambdaQuery().eq(TaskRecord::getJobUid, createCodeJobDto.getJobUid()).last("LIMIT 1"));
            log.info("消息记录：{}",taskRecord.getId());
            //判断任务是否手动终止，如果手动终止，则直接同意
            {
                String key = CacheKeyEnum.STOP_TASK.getKey() + taskRecord.getId();
                Object delMes = redisService.getCacheObject(key);
                if (ObjectUtil.isNotNull(delMes)) {
                    log.info("终止任务:任务记录{}", taskRecord.getId());
                    //任务已被删除，直接确认消费
                    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
                    redisService.deleteObject(key);
                    return;
                }
            }
            //获取pod的数量 或者内存占用情况
           V1PodList jobList = k8sService.listNamespacesPod(runCodeConfig.getNamespace(), runCodeConfig.getJobLabel());
            if (jobList == null || jobList.getItems().size() <= jobMaxNum) {
                log.info("同意消费,任务记录：{}", taskRecord.getId());
                //消费成功
                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
                //异步执行提交代码
                codeSubmit.submitCode(createCodeJobDto);
            } else {
                log.info("任务已满，拒绝消费,任务记录：{}", taskRecord.getId());
                //拒绝消费，重新入队（此处的入队表示进入队头），此时消费者会持续接收该消息，直到允许消费。
                //睡眠五秒，不然的话消费者会一直消费该消息，并一直拒绝。
                Thread.sleep(5000L);
                channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);
            }
        } catch (Exception e) {
            log.info("消费失败,失败原因：{},失败记录id：{}", e.getMessage(),taskRecord.getId());
            //如果代码逻辑产生了异常，拒绝消息，入死信队列
            try {
                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false);
            } catch (Exception ex) {
                log.info("信道异常");
                throw new RuntimeException(ex);
            }
        }
    }

    //死信队列，存储过期或者消费失败的消息   考虑之后做短信通知
    @RabbitListener(queues = CompileCodeConfig.COMPILE_CODE_DEAD_QUEUE)
    public void handleDeadMessage(Message message, Channel channel) {
        try {
            String mes = new String(message.getBody(), "UTF-8");
            log.info("死信队列:收到消息:{}", mes);
            CreateCodeJobDto createCodeJobDto = JSONObject.parseObject(mes, CreateCodeJobDto.class);
            TaskRecord taskRecord = recordMapper.selectOne(Wrappers.<TaskRecord>lambdaQuery().eq(TaskRecord::getJobUid, createCodeJobDto.getJobUid()).last("LIMIT 1"));
            taskRecord.setTaskStatus(TaskStatusEnum.TASK_FAIL.getStatus());
            recordMapper.updateById(taskRecord);
            log.info("死信队列：消费失败,任务记录:{}", taskRecord);
            try {
                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
            } catch (IOException e) {
                log.info("死信队列：消费失败，信道已关闭");
                throw new RuntimeException(e);
            }
        } catch (UnsupportedEncodingException e) {
            try {
                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
            } catch (IOException ex) {
                log.info("死信队列：消费失败，信道已关闭");
                throw new RuntimeException(ex);
            }
        }
    }

}
```

#### 6. 异步创建job

```java
@Component
@Slf4j
@AllArgsConstructor
public class CompileCodeSubmit {
    private final K8sService k8sService;

    @Async
    public void submitCode(CreateCodeJobDto createCodeJobDto) {
        log.info("开始消费任务:{}", createCodeJobDto);
        //创建pod，执行任务
        k8sService.createCodeJob(createCodeJobDto);
        log.info("消费完成");
    }
}
```

### 3. k8sjob的设置

![image-20220803154823555](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220803154823555.png)











