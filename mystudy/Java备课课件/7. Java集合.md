# Java集合

集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象(实际上保存的是对象的引用变量)。

集合里只能保存对象（实际上只是保存对象的引用变量，但通常习惯上认为集合里保存的是对象)。

Java的集合类主要由两个接口派生而出:Collection和 Map，Collection和 Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。

**集合体系**

![image-20211123210129611](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123210129611.png)

![image-20211123210754568](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123210754568.png)

**Map体系**

![image-20211123211125145](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123211125145.png)

## Collection和Iterator接口

### Collection介绍

Collection接口是List、Set和 Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和 Queue集合。

1. boolean **add**(Object o):该方法用于向集合里添加一个元素。如果集合对象被添加操作改变了，则返回true。
2. boolean **addAll**(Collection c):该方法把集合c里的所有元素添加到指定集合里。如果集合对象被添加操作改变了，则返回true。
3. void **clear**():清除集合里的所有元素,将集合长度变为0。
4. boolean **contains**(Object o):返回集合里是否包含指定元素
5. boolean **containsAll**(Collection c):返回集合里是否包含集合c里的所有元素。
6. boolean **isEmpty()**:返回集合是否为空。当集合长度为О时返回true，否则返回false。
7. Iterator **iterator()**:返回一个Iterator对象，用于遍历集合里的元素。
8. boolean **remove(Object o)**:删除集合中的指定元素o，当集合中包含了一个或多个元素o时，该方法**只删除第一个符合条件的元素**，该方法将返回true。
9. boolean **removeAll(Collection c)**:**从集合中删除集合c里包含的所有元素**（相当于用调用该方法的集合减集合c)，如果删除了一个或一个以上的元素，则该方法返回true。
10. boolean **retainAll(Collection c)**:从集合中**删除集合c里不包含的元素**(相当于把调用该方法的集合变成该集合和集合c的交集)，如果该操作改变了调用该方法的集合，则该方法返回true。
11. int **size()**:该方法返回集合里元素的个数。
12. Object [] **toArray()**:该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。
13. 详情查看api文档

**集合练习**

```java
public class CollectionTest
{
	public static void main(String[] args)
	{
		Collection c = new ArrayList();
		// 添加元素
		c.add("孙悟空");
		// 虽然集合里不能放基本类型的值，但Java支持自动装箱
		c.add(6);
		System.out.println("c集合的元素个数为:" + c.size()); // 输出2
		// 删除指定元素
		c.remove(6);
		System.out.println("c集合的元素个数为:" + c.size()); // 输出1
		// 判断是否包含指定字符串
		System.out.println("c集合的是否包含\"孙悟空\"字符串:"
			+ c.contains("孙悟空")); // 输出true
		c.add("轻量级Java EE企业应用实战");
		System.out.println("c集合的元素：" + c);
		Collection books = new HashSet();
		books.add("轻量级Java EE企业应用实战");
		books.add("疯狂Java讲义");
		System.out.println("c集合是否完全包含books集合？"
			+ c.containsAll(books)); // 输出false
		// 用c集合减去books集合里的元素
		c.removeAll(books);
		System.out.println("c集合的元素：" + c);
		// 删除c集合里所有元素
		c.clear();
		System.out.println("c集合的元素：" + c);
		// 控制books集合里只剩下c集合里也包含的元素
		books.retainAll(c);
		System.out.println("books集合的元素:" + books);
	}
}
```

当使用System.out的printIn()方法来输出集合对象时，将输出[ele1,ele2...].[的形式，这显然是因为**所有的Collection实现类都重写了toString()方法**，该方法可以一次性地输出集合中的所有元素。

注意：如果不为集合设置泛型，那么默认情况下，集合存储的数据类型为Object类型

### 遍历集合

#### 1. 使用Lambda遍历集合

Java 8为Iterable接口新增了**一个forEach(Consumer action)默认方法**，该方法所需参数的类型是一
个函数式接口，而Iterable接口是Collection接口的父接口，因此Collection集合也可直接调用该方法。

当程序调用Iterable 的forEach(Consumer action)遍历集合 元素时，**程序会依次将集合元素传给**
**Consumer的accept(T t)方法(该接口中唯一的抽象方法)。** 正因为Consumer是函数式接口，因此可以
使用Lambda表达式来遍历集合元素。

如下程序示范了使用Lambda表达式来遍历集合元素。

```java
public class CollectionEach
{
	public static void main(String[] args)
	{
		// 创建一个集合
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 调用forEach()方法遍历集合
		books.forEach(obj -> System.out.println("迭代集合元素：" + obj));
	}
}
```

#### 2. 使用Iterator遍历集合元素

Collection系列集合、Map系列集合主要用于盛装其他对象，而 Iterator则主要用于遍历〈即迭代访问)Collection集合中的元素，Iterator对象也被称为迭代器。

Iterator接口隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口。

**定义的方法：**

1. boolean hasNext():如果被迭代的集合元素还没有被遍历完，则返回true。

2. Object next():返回集合里的下一个元素。

3. void remove(）:删除集合里上一次next方法返回的元素。

4. void forEachRemaining(Consumer action)，这是Java 8为lterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。

```java
public class IteratorTest
{
	public static void main(String[] args)
	{
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		while(it.hasNext())
		{
			// it.next()方法返回的数据类型是Object类型，因此需要强制类型转换
			String book = (String)it.next();
			System.out.println(book);
			if (book.equals("Java"))
			{
				// 从集合中删除上一次next方法返回的元素
				it.remove();
			}
			// 对book变量赋值，不会改变集合元素本身
			book = "测试字符串";   //无效
		}
		System.out.println(books);
	}
}
```

1. Iterator必须依附于Collection对象，若有一个Iterator对象，则必然有一个与之关联的Collection对象。Iterator提供了两个方法来迭代访问Collection集合里的元素，并可通过remove()方法来删除集合中上一次next()方法返回的集合元素。
2. 对迭代变量book进行赋值，但当再次输出books 集合时，会看到集合里的元素没有任何改变。当使用Iterator对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量，所以修改迭代变量的值对集合元素本身没有任何影响。
3. 当使用Iterator 迭代访问Collection 集合元素时，Collection 集合里的元素不能被改变，只有通过
   Iterator的remove0方法删除上一次next0方法返回的集合元素才可以;否则将会引发java.util.Concurrent
   ModificationException异常。

```java
public class IteratorErrorTest
{
	public static void main(String[] args)
	{
        Collection books = new HashSet();
		// 创建集合、添加元素的代码与前一个程序相同
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		while(it.hasNext())
		{
			String book = (String)it.next();
			System.out.println(book);
			if (book.equals("Java"))
			{
				// 使用Iterator迭代过程中，不可修改集合元素,下面代码引发异常
				books.remove(book);
			}
		}
	}
}
```

![image-20211123214335887](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123214335887.png)

注意：当我们进行集合迭代时，删除元素会导致错误。

#### 3. 使用Lambda表达式遍历Iterator

Java 8为Iterator新增了一个forEachRemaining(Consumer action)方法，该方法所需的Consumer参
数同样也是函数式接口。当程序调用Iterator的forEachRemaining(Consumer action)遍历集合元素时，程序会**依次**将集合元素传给Consumer的accept(T t)方法( 该接口中唯一的抽象方法)。

```java
public class IteratorEach
{
	public static void main(String[] args)
	{
		// 创建集合、添加元素的代码与前一个程序相同
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		// 使用Lambda表达式（目标类型是Comsumer）来遍历集合元素
		it.forEachRemaining(obj -> System.out.println("迭代集合元素：" + obj));
	}
}
```

#### 4. 使用foreach循环遍历集合元素

```java
public class ForeachTest
{
	public static void main(String[] args)
	{
		// 创建集合、添加元素的代码与前一个程序相同
		Collection books = new HashSet();
		books.add("Java");
		books.add("Js");
		books.add("C++");
		for (Object obj : books)
		{
			// 此处的book变量也不是集合元素本身
			String book = (String)obj;
			System.out.println(book);
			if (book.equals("疯狂Android讲义"))
			{
				// 下面代码会引发ConcurrentModificationException异常
				books.remove(book);     //①
			}
		}
		System.out.println(books);
	}
}
```

#### 5. 使用Predicate操作集合

Java 8为Collection集合新增了一个个removelf(Predicate filter)方法，该方法将会批量删除符合filter
条件的所有元素。该方法需要一个Predicate (谓词)对象作为参数，Predicate 也是函数式接口，因此可
使用Lambda表达式作为参数。

removeIf，删除符合条件的数据，条件通过实现Predicate 的方法来创造。

![image-20211123220954780](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123220954780.png)

Predicate ：类似筛选条件。

![image-20211123221143697](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211123221143697.png)

如下程序示范了使用Predicate 来过滤集合。

```java
public class PredicateTest
{
	public static void main(String[] args)
	{
		// 创建一个集合
		Collection books = new HashSet();
		books.add(new String("Java EE"));
		books.add(new String("Java"));
		books.add(new String("iOS"));
		books.add(new String("Ajax"));
		books.add(new String("Android"));
		// 使用Lambda表达式（目标类型是Predicate）过滤集合
		books.removeIf(ele -> ((String)ele).length() < 5);
		System.out.println(books);
	}
}
```

需求：

1. 统计书名中出现“疯狂”字符串的图书数量。
2. 统计书名中出现“Java”字符串的图书数量。
3. 统计书名长度大于10的图书数量。

```java
public class PredicateTest2
{
	public static void main(String[] args)
	{
		// 创建books集合、为books集合添加元素的代码与前一个程序相同。
		Collection books = new HashSet();
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂iOS讲义"));
		books.add(new String("疯狂Ajax讲义"));
		books.add(new String("疯狂Android讲义"));
		// 统计书名包含“疯狂”子串的图书数量
		System.out.println(calAll(books , ele->((String)ele).contains("疯狂")));
		// 统计书名包含“Java”子串的图书数量
		System.out.println(calAll(books , ele->((String)ele).contains("Java")));
		// 统计书名字符串长度大于10的图书数量
		System.out.println(calAll(books , ele->((String)ele).length() > 10));
	}
	public static int calAll(Collection books , Predicate p)
	{
		int total = 0;
		for (Object obj : books)
		{
			// 使用Predicate的test()方法判断该对象是否满足Predicate指定的条件
			if (p.test(obj))
			{
				total ++;
			}
		}
		return total;
	}
}
```

#### 6. 使用Stream流

Java 8新增了Stream、IntStream、 LongStream、 DoubleStream 等流式API,这些API代表多个支持串行和并行聚集操作的元素。

上面4个接口中，Stream是一个通用的流接口,而IntStream、LongStream、DoubleStream则代表元素类型为int、long、 double 的流。

每个流式API有对应的Builder, 例如Stream.Builder、 IntStream.Builder、LongStream.Builder、DoubleStream. Builder,开发者可以通过这些Builder来创建对应的流。

**使用Stream的步骤如下:**

1. 使用Stream或XxxStream的builder(）类方法创建该Stream对应的Builder。
2. 重复调用Builder的add（）方法向该流中添加多个元素。
3. 调用Builder的build（）方法获取对应的Stream。
4. 调用Stream的聚集方法。

```java
public class IntStreamTest
{
	public static void main(String[] args)
	{
		IntStream is = IntStream.builder()
			.add(20)
			.add(13)
			.add(-2)
			.add(18)
			.build();
		// 下面调用聚集方法的代码每次只能执行一个
		System.out.println("is所有元素的最大值：" + is.max().getAsInt());
		System.out.println("is所有元素的最小值：" + is.min().getAsInt());
		System.out.println("is所有元素的总和：" + is.sum());
		System.out.println("is所有元素的总数：" + is.count());
		System.out.println("is所有元素的平均值：" + is.average());
		System.out.println("is所有元素的平方是否都大于20:"
			+ is.allMatch(ele -> ele * ele > 20));
		System.out.println("is是否包含任何元素的平方大于20:"
			+ is.anyMatch(ele -> ele * ele > 20));
		// 将is映射成一个新Stream，新Stream的每个元素是原Stream元素的2倍+1
		IntStream newIs = is.map(ele -> ele * 2 + 1);
		// 使用方法引用的方式来遍历集合元素
		newIs.forEach(System.out::println); // 输出41 27 -3 37
	}
}
```

上面程序先创建了一个IntStream,接下来调用IntStream的聚集方法执行操作，这样即可获取该流的相关信息。

注意：一个IntStream调用一次聚集方法后，流就进行了关闭，不能调用其他的方法。

![image-20211124141450401](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211124141450401.png)Stream提供了大量的方法进行聚集操作，这些方法既可以是“中间的”(intermediate)，也可以是“末端的”(terminal)。

1. 中间方法:中间操作允许流保持打开状态，并允许直接调用后续方法。上面程序中的map()方法就是中间方法。中间方法的返回值是另外一个流。
2. 末端方法:末端方法是对流的最终操作。当对某个Stream执行末端方法后,该流将会被“消耗”且不再可用。上面程序中的sum()、count()、 averageO等 方法都是末端方法。

**流的方法还有如下两个特征。**

1. 有状态的方法:这种方法会给流增加一些新的属性，比如元素的唯一性、元素的最大数量、保证元素以排序的方式被处理等。有状态的方法往往需要更大的性能开销。
2. 短路方法:短路方法可以尽早结束对流的操作，不必检查所有的元素。

**常用的中间方法**

1. filter(Predicate predicate):过滤Stream中所有不符合predicate 的元素
2. mapToXxx(ToXxxFunction mapper):使用ToXxxFunction对流中的元素执行一对一的转换，该方法返回的新流中包含了ToXxxFunction转换生成的所有元素。
3. peek(Consumer action):依次对每个元素执行一些操作， 该方法返回的流与原有流包含相同的元素。该方法主要用于调试。
4. distinct(): 该方法用于排序流中所有重复的元素(判断元素重复的标准是使用equals)比较返回true。这是一个有状态的方法。
5. sorted(): 该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。
6. limit(long maxSize):该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个有状态的、短路方法。

**常用的末端方法**

1. forEach(Consumer action):遍历流中所有元素，对每个元素执行action。
2. toArray(): 将流中所有元素转换为一个数组。
3. reduce(): 该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。
4. min(): 返回流中所有元素的最小值。
5. max(): 返回流中所有元素的最大值。
6. count():返回流中所有元素的数量。
7. anyMatch(Predicate predicate):判断流中是否至少包含一个元素符合Predicate条件。
8. allMatch(Predicate predicate):判断流中是否每个元素都符合Predicate条件。
9. noneMatch(Predicate predicate):判断流中是否所有元素都不符合Predicate条件。
10. findFirst():返回流中的第一个元素。
11. findAny():返回流中的任意一个元素。

```java
public class CollectionStream
{
	public static void main(String[] args)
	{
		// 创建books集合、为books集合添加元素的代码与8.2.5小节的程序相同。
		Collection books = new HashSet();
		books.add(new String("轻量级Java EE企业应用实战"));
		books.add(new String("疯狂Java讲义"));
		books.add(new String("疯狂iOS讲义"));
		books.add(new String("疯狂Ajax讲义"));
		books.add(new String("疯狂Android讲义"));
		// 统计书名包含“疯狂”子串的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele).contains("疯狂"))
			.count()); // 输出4
		// 统计书名包含“Java”子串的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele).contains("Java") )
			.count()); // 输出2
		// 统计书名字符串长度大于10的图书数量
		System.out.println(books.stream()
			.filter(ele->((String)ele).length() > 10)
			.count()); // 输出2
		// 先调用Collection对象的stream()方法将集合转换为Stream,
		// 再调用Stream的mapToInt()方法获取原有的Stream对应的IntStream
		books.stream().mapToInt(ele -> ((String)ele).length())
			// 调用forEach()方法遍历IntStream中每个元素
			.forEach(System.out::println);// 输出8  11  16  7  8
	}
}
```

程序只要调用Collection的 stream()方法即可返回该集合对应的Stream，接下来就可通过Stream提供的方法对所有集合元素进行处理，这样大大地简化了集合编程的代码，这也是 Stream编程带来的优势。

```java
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
```

mapToInt()方法就是一个中间方法，因此程序可继续调用IntStream的 forEach()方法来遍历流中的元素。



### 流的概念

```java
class Dish {
    private final String name;
    private final boolean vegetarian;
    private final int calories;
    private final Type type;

    public Dish(String name, boolean vegetarian, int calories, Type type) {
        this.name = name;
        this.vegetarian = vegetarian;
        this.calories = calories;
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public int getCalories() {
        return calories;
    }

    public Type getType() {
        return type;
    }

    @Override
    public String toString() {
        return name;
    }

    public enum Type {MEAT, FISH, OTHER}
}

public class StreamTest {
    public static void main(String[] args) {
        List<Dish> menu = Arrays.asList(
                new Dish("pork", false, 800, Dish.Type.MEAT),
                new Dish("beef", false, 700, Dish.Type.MEAT),
                new Dish("chicken", false, 400, Dish.Type.MEAT),
                new Dish("french fries", true, 530, Dish.Type.OTHER),
                new Dish("rice", true, 350, Dish.Type.OTHER),
                new Dish("season fruit", true, 120, Dish.Type.OTHER),
                new Dish("pizza", true, 550, Dish.Type.OTHER),
                new Dish("prawns", false, 300, Dish.Type.FISH),
                new Dish("salmon", false, 450, Dish.Type.FISH));
        /*要求：
         *1. 删选出calories小于400的Dish
         *2. 通过calories进行从小到大排序
         *3. 获取符合以上两种条件的name集合。
         */
        System.out.println("Java7");
        //Java7遍历
        List<Dish> lowCaloricDishes = new ArrayList<>();
        for (Dish d : menu) {
            if (d.getCalories() < 400) {
                lowCaloricDishes.add(d);
            }
        }
        Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
            public int compare(Dish d1, Dish d2) {
                return Integer.compare(d1.getCalories(), d2.getCalories());
            }
        });
        List<String> lowCaloricDishesName = new ArrayList<>();
        for (Dish d : lowCaloricDishes) {
            lowCaloricDishesName.add(d.getName());
        }
        lowCaloricDishes.forEach(System.out::println);
        System.out.println("Java8");
        //Java8
        lowCaloricDishes.stream()
                .filter(item->item.getCalories()<400)
                .sorted(Comparator.comparing(Dish::getCalories))
                .map(Dish::getName)
                .collect(Collectors.toList());
        lowCaloricDishes.forEach(System.out::println);
    }
}
```

![image-20211124113135709](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211124113135709.png)

将流操作链接起来构成流的流水线.



