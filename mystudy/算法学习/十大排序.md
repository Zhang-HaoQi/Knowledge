# 算法十大排序

# 学习资料

[1.0 十大经典排序算法 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

[(59条消息) ❤️五万字《十大排序算法》动图讲解❤️(建议收藏)_英雄哪里出来-CSDN博客](https://blog.csdn.net/WhereIsHeroFrom/article/details/119976287)

# 相关思想

在设计一个算法的过程中同时考虑时间复杂度和空间复杂度，并且在这两者中找到一个平衡点的过程我们把它称作**时空权衡**（**time and space trade-off**）。

**在通常情况下，我们都认为时间更宝贵，而空间相对廉价**。因此在大多数情况下，**我们都是以牺牲空间的方式来减少运行时间。**

# 1.1 插入排序 

## 介绍

插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

## 图示

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/insertionSort.gif)

## 算法步骤

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

**解析思路：**

1. 从第二个元素开始。
2. 设置一个变量，记录当前节点的位置。
3. 设置一个变量，记录当前节点的值。
4. 使当前节点的值与之前的节点一个个比较，如果当前节点大于之前的节点，则不进行移动。如果小于之前的节点，则将之前的节点后移一个位置，再与之前的节点进行比较。如果发现之前的节点小于当前节点，说明要在此节点的后面插入当前节点。终止while循环，终止后进行插入。

## Java代码实现

``` java
    public static void main(String[] args) {
        int[] sourceArray = {2,27,36,3,4,78,38,44,46,48,50,5,15,19,26,};
        int[] arr = Demo.sortOne(sourceArray);
//        int[] arr = Demo.sortTwo(sourceArray);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + ",");
        }
    }
```

### 方法一：我的

原则上，方法一并没有使用到插入排序，表达更多的是替换。发现比本身大的元素后，进行替换，替换后再依次比较替换。

```java
//方法一:如果当前元素小于前一个元素，则将二者替换。再使用当前元素与之前的元素比较，小于替换。
public static  int[] sortOne(int[] sourceArray){
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
    for (int i=1;i<arr.length;i++){
        int now = arr[i];
        int index = i;
        while (index>=1&&now<arr[index-1]){
            int temp = arr[index-1];
            arr[index-1]=now;
            arr[index] = temp;
            index--;
        }
    }
    return  arr;
}
```

### 方法二：优化

插入排序的标准算法。

```java
    //方法二:使用当前元素和列表中的元素进行对比，如果发现比当前元素小的元素，则使小的元素向后移一位。让当前元素继续对比，当没有元素时，则进行替换。
    public static  int[] sortTwo(int[] sourceArray){
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        for (int i=1;i<arr.length;i++){
            int now = arr[i];
            int index = i;
            while (index>=1&&now<arr[index-1]){
                arr[index]=arr[index-1];
                index--;
            }
            //列表存在比当前这个数更大的元素，进行替换。
            if (index!=i){
                arr[index]=now;
            }

        }
        return  arr;
    }
}
```

# 1.2 冒泡排序

## 介绍

冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。

## 个人理解

开始进行两个数的对比，大的那一个数作为泡冒出来，之后遇到比它更大的数时，它就下去，比它更大的那个数就冒出来进行之后的比较，依此类推。

## 图示

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/bubbleSort.gif)

## 算法步骤

通过不断比较相邻的元素，如果**「左边的元素」** 大于 **「右边的元素」**，则进行**「交换」**，直到所有相邻元素都保持升序，则算法结束。

**什么时候最快**

当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

**什么时候最慢**

当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢？）。

**解题思路**

1. 根据算法步骤，我们可知，最坏的情况下，有几个元素，我们就需要排序几次。因此，第一层for循环就用来控制排序次数。
2. 每轮排序时，我们都是从第一个元素开始，一直比较到最后一个元素。如果中途出现后一个元素小于前一个元素，则进行位置交换。交换后以最新的元素向后比较。
3. length-1的目的是，最后一个元素直接和前一个元素比较了，其后面无元素可比。
4. length-i的目的是，每一轮比较完，我们都可以获取一个最大的元素。这个最大元素之后的序列是已经排好的，不需要再进行排列了。

## Java代码实现

``` java
    public static void main(String[] args) {
        int[] sourceArray = {2,27,36,3,4,78,38,44,46,48,50,5,15,19,26,};
        int[] arr = Demo.sortOne(sourceArray);
//        int[] arr = Demo.sortTwo(sourceArray);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + ",");
        }
    }
```

### 方法一：我的

如果当前数小于前一个数，则进行位置交换。用最新的当前数在和后面的数进行对比，如果小了再交换。这样一轮下来，能获取最大的那个数字。

```java
 //方法一：如果当前数小于前一个数，则进行位置交换。用最新的当前数在和后面的数进行对比，如果小了再交换。这样一轮下来，能获取最大的那个数字。
    public static int[] sortOne(int[] sourceArray) {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        for (int i = 0; i < arr.length; i++) {
            for (int m =0;m<arr.length-i-1;m++){
                if (arr[m]>arr[m+1]){
                    int temp =arr[m];
                    arr[m]=arr[m+1];
                    arr[m+1]=temp;
                }
            }
        }
        return arr;
    }

```

### 方法二：优化

建立flag，如果某一轮没有一个顺序交换，说明序列已经排好。

```java
    //方法二：如果当前数走了一轮，都没有发生位置交换，说明当前数都大于之前的数，说明序列都已经排好。则可以中断。
    public static int[] sortTwo(int[] sourceArray) {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        for (int i = 0; i < arr.length; i++) {
            boolean flag= true;
            for (int m =0;m<arr.length-i-1;m++){
                if (arr[m]>arr[m+1]){
                    int temp =arr[m];
                    arr[m]=arr[m+1];
                    arr[m+1]=temp;
                    flag=false;
                }
            }
            if (flag) break;
        }
        return arr;
    }
```

# 1.3 选择排序

## 介绍

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

每次都是**「选择」** 出一个最小的元素，故此命名 **「 选择排序 」** 。

## 个人理解

先随便选一个数默认它为最小的数，遍历整个集合，如果没有比它还小的，那就选它做第一个数，如果有比它还小的，替换掉它，继续遍历集合，取最小的那个数。

## 图示

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/selectionSort.gif)

## 算法步骤

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。

**解题思路：**

1. 根据选择排序的规则，我们知道，每一轮循环我们都能定出最小的那个元素。所以我们就要将一个元素作为最小元素的参照。因为每一轮都会产生最小的元素，所以我们就以每一轮最开始的那个元素作为参照。
2. 第一轮确定后，那么第一个最小的元素已经选出，我们直接可以从第二个元素开始，之后的都是这样。我们一共需要length-1层。
3. 每一轮遍历时，我们都需要找出这一轮最小的元素的索引index，并记录
4. 遍历结束后，将这个最小的元素的值，与我们对照元素的值进行交换，即可产生最终从小到大的排序

## Java代码实现

```java
    public static void main(String[] args) {
        int[] sourceArray = {2,27,36,3,4,78,38,44,46,48,50,5,15,19,26,};
        int[] arr = Demo.sortOne(sourceArray);
//        int[] arr = Demo.sortTwo(sourceArray);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + ",");
        }
    }
```

### 方法一：我的

``` java
    public static int[] sortOne(int[] sourceArray) {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        for (int i = 0; i <arr.length-1; i++) {
            int index=i;
            int min = arr[index];
            for (int m=i+1;m<arr.length;m++){
                if (arr[m]<min){
                    min=arr[m];
                    index=m;
                }
            }
            //找到最小值，进行交换。
            if (i!=index){
                int temp =arr[i];
                arr[i]=min;
                arr[index]=temp;
            }

        }
        return arr;
    }
```

问题：

1. length多计算一次
2. 我是每一轮获取到比对比元素小的元素后，记录了这个元素，并拿着这个元素与之后的比较，其实没有必要将整个元素记录下来，只需要记录索引即可。

### 方法二：优化

```java
    public static int[] sortTwo(int[] sourceArray) {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        for (int i = 0; i <arr.length ; i++) {
            int index=i;
            for (int m=i+1;m<arr.length;m++){
                if (arr[m]<arr[index]){
                    index=m;
                }
            }
            //找到最小值，进行交换。
            if (i!=index){
                int temp =arr[i];
                arr[i] = arr[index];
                arr[index]=temp;
            }

        }
        return arr;
    }
```



# 1.4 希尔排序



## 介绍

## 个人理解

## 图示

## 算法步骤

## Java代码实现

### 方法一：我的

### 方法二：优化

# 1.5 计数排序

## 介绍

**计数排序**（**counting sort**）是一种牺牲内存空间来换取低时间复杂度的排序算法，同时它也是一种**不基于比较的算法**。这里的不基于比较指的是**数组元素之间不存在比较大小**的排序算法，我们知道，用分治法来解决排序问题**最快也只能使算法的时间复杂度接近** ![[公式]](https://www.zhihu.com/equation?tex=Θ(n\log+n)) ，即**基于比较的时间复杂度存在下界** ![[公式]](https://www.zhihu.com/equation?tex=Ω(n\log+n)) ，而不基于比较的排序算法可以突破这一下界。

## 个人理解

根据相关排序规则，将相同的元素放入到指定数组的某一个位置（越大的元素，在数组中的排列越靠后），数组中记录该元素出现的个数。最后按照顺序遍历这个指定数组，排出的顺序就是最终的顺序。

### 





