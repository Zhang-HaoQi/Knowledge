# Mysql进阶

## 索引

### 1. 什么是索引

1. Mysql索引是一种数据结构，类似目录，协助快速查询和更新表中的数据，索引的实现有B树和B+树。
2. 索引是一个文件，占据物理空间，索引可以大大提高Mysql的检索速度。

### 2. 索引的优缺点

优点：

1. 大大提高Mysql的检索速度
2. 通过使用索引，在查询过程中，使用优化隐藏器，提高系统性能。

缺点：

1. 时间方面：创建索引和维护索引要耗费时间，对表中数据进行增删改时，索引也要动态维护，降低增删改的执行效率。
2. 空间方面：占用物理内存

### 3. MySQL有哪几种索引类型？

1. 存储结构上：BTree，B+Tree，Hash索引，full-index全文索引，R-Tree索引
2. 应用层次：（除了主键索引，其余都是二级索引）
   1. 主键索引：设置为主键后数据库会自动建立索引，innodb为聚簇索引，主键所有列的值不能为null
   2. 唯一索引：索引列的值必须唯一，但允许有空值。
   3. 普通索引：一个索引只有一个列，一张表可以包含多个单列索引，查询时如果使用多个索引，会进行索引合并。
   4. 复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
      1. 索引合并：使用多个索引完成一次查询的执行方法
   5. 全文索引（5.7之前，只能用于MYISAM引擎）（很少用到）
      1. 全文索引类型为FULL TEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值或者空值。全文索引可以在CHAR，VARCHAR，TEXT类型列上创建。MYSQL只有MYISAM存储引擎支持全文索引。
      2. 在MySQL 5.6版本以前,只有MyISAM存储引擎支持全文引擎.在5.6版本中,InnoDB加入了对全文索引的支持,但是不支持中文全文索引.在5.7.6版本,MySQL内置了ngram全文解析器,用来支持亚洲语种的分词

### 4. 索引的底层实现

1. Hash索引:基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。数据没有顺序，IO复杂度高

   ![image-20221031180855594](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031180855594.png)

2. B-Tree索引:B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。

   数据都保存在非叶子节点，数据量大时，树的高度高，IO操作变多，性能变低

   ![image-20221031181511690](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031181511690.png)

3. B+树索引:数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

   ![image-20221031184903551](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031184903551.png)

### 5. 为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？

1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 IO读写次数就降低 了。

2. 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以**B+树更加适合在 区间查询 的情况**，所以通常B+树用于数据库索引。

**B-tree：**因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；

**Hash：**虽然可以快速定位，但是没有顺序，IO复杂度高。如果有大量重复键值，会产生Hash碰撞，效率变低。适合等值查询，不适合范围查询。

**二叉树：**树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

**红黑树：**树的高度随着数据量增加而增加，IO代价高。

### 6. 聚簇索引与非聚簇索引

##### 聚簇索引

1. 聚集索引：**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**

   在 MySQL 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，**对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。**

   ![image-20221031175027576](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031175027576.png)

   ![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031184903551.png)

##### 非聚簇索引

非聚集索引：**非聚集索引即索引结构和数据分开存放的索引。**

**二级索引属于非聚集索引。**

非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

![image-20221031175317334](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031175317334.png)

![image-20221031180106827](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031180106827.png)

##### 二者区别

1. 聚簇索引的非叶子节点存储的是主键索引，叶子节点存储数据。非聚簇索引的所有节点存储的都是主键索引，查找数据时，先在非聚簇索引中查询主键，再根据主键去聚簇索引中查找。

2. 对于InnoDB来说，非聚集索引查找数据时，还需要去聚集索引中查找，这个再根据聚集索引查找数据的过程称为回表。

   第一次索引一般是顺序IO，获取主键key，回表操作是随机IO。回表次数越多，IO次数越多，越接近全表扫描。

注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。

##### 非聚簇索引查询一定回表吗

不一定，如果查询的字段刚好是索引字段，那么就不会进行回表操作。

如Select age from users where age = 35;这个索引的 key 本身就是 age，查到对应的 age直接返回就行了，无需回表查询。

### 7. 联合索引是什么，为什么需要注意联合索引中的顺序

联合索引：使用多个字段建立一个索引，联合索引中，如果想命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

#### 8. Mysql的最左前缀



## 问题：

### 索引合并

![image-20221031114943720](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031114943720.png)



使用多个索引完成一次查询的执行方法。

索引合并的方法：

1. **Intersection索引合并**

   1. 分析：

      1. Select * From single_table where key1='a' and key2 = 'b'

      2. 搜索方式：

         1. 全表扫描：使用key1索引查到范围在[a,a]之间的数据id，对于获取的每条二级索引记录（已按照主键排好序），**进行回表操作**获取完整的记录，筛选出记录中key2=b的记录
         2. Intersection索引合并：同时使用key1和key2进行查询，取二者查询结果即二级索引记录的交集（各自二级索引记录已按照主键排好序），**进行回表**操作，获取完整的记录。

         intersection索引合并的索引记录要比全表扫描少的多，因此需要回表的数据少，剩下很多回表操作带来的开销。方式二就是Intersection索引合并。

   2. 条件：二级索引的索引记录值，必须按照主键已经排好序

   3. 为什么要索引记录已排好序？

      1. 有序集合取交集比无序集合取交集容易
      2. id有序排列时，根据id值进行回表操作时不再是进行单纯的随机IO，因为这些值是有序的，能提高效率。

   4. 索引合并失效

      1. 使用二级索引执行查询时，如果从对应的扫描区间读取出的记录不是按照主键排序的，则不能使用Intersection

         1. Select * From single_table where key1> 'a' and key2 = 'b'

            key1的扫描区间是（‘a’，+oo），获取的记录不是按照主键值索引，不能使用intersection索引。

         2. Select * From single_table where key1> 'a' and key_part1= 'a'

            二级索引记录是先按照key_part1列的值进行排序，在key_part1值相等的情况下，在通过key_part2进行排序，之后再根据key_part3进行排序，因为key_part1是一个符合索引，所以形成的二级索引记录不是排序的，不能使用intersection索引。

   5. 聚簇索引和二级索引

      1. Select * From single_table where key1= 'a' and id>9000

         key1获取的二级索引记录是排好序的，但是在sql语句执行时，并不会生成id>9000的主键并与key1生成的二级索引取交集，因为聚簇索引本身就是排好序的，获取key1=‘a’的索引记录后，沿着链表往后判断记录的id值是否>9000即可，符合则进行回表取记录即可。整个过程中不需要取id>9000区间的数据。

   2. **Union索引合并**

      1. 分析：
         1. Select * From single_table where key1= 'a' or key3='b'
         2. 搜索方式：
            1. 直接使用or，不走索引，扫描区间是（-00，+00）
            2. **Union合并**：key1的扫描区间['a','a'],key3的扫描区间['b','b'],获取二者的二级索引记录后，通过二级索引id进行去重，去重后进行回表操作。
      2. 条件：二级索引的索引记录值，必须按照主键已经排好序，原因同上。
      3. 其他情况和Intersection索引情况一致。

   3. Sort-Union索引合并

      1. 分析：

         1. Select * From single_table where key1< 'a' or key3> 'b'

            因为key1和key3生成的区间分别是（-00，a），（b,+00），生成的二级索引记录的主键是不排序的，**所以不能走Union索引合并**

            如果将二者生成的区间的索引记录按照主键排序后，**就可以走Union索引合并了**，这就是Union索引合并

         2. 主要就是解决Union索引合并条件太苛刻的问题（二级索引记录主键必须排序）

      2. 为什么没有Intersection-sort？
         1.  Sort-Union针对场景是单独根据搜索条件从某个二级索引记录中获取记录较少，对于Sort-Union相对来说，单个条件生成的二级索引记录较少，通过排序能够增加性能。
         2. Intersection是针对场景是单独根据搜索条件从某个二级索引记录中获取记录较多，对于Intersection来说，单个条件生成的二级索引记录较多，需要为大量的二级索引记录按照主键值进行排序，这个成本可能比使用单个二级索引执行查询的成本更高。



1. Union索引合并
2. Sort-Union索引合并

### 索引数据页

mysql的记录存储在数据页中，一个数据页能存储多条数据。

记录与记录之间，是一个单向链表，即上一条记录存储这下一条记录的位置。

数据页之间是一个双向链表，里面存放着本数据页和下一数据页的页号。

![image-20221031185505947](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031185505947.png)

![image-20221031185815877](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031185815877.png)

### B+树

[B+树及插入和删除操作详解 (biancheng.net)](http://data.biancheng.net/view/61.html)



