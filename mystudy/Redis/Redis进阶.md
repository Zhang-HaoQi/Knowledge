# Redis进阶

## 基础

### 1. Redis是什么，优缺点

Redis是一个存储KV类型数据的内存数据库，整个数据库加载在内存中操作，定期通过异步操作将数据flush到磁盘上保存。

Redis是纯内存操作，性能好，每秒可以处理超过10万次读写操作，目前性能最快的kv数据库。

优点：

1. 读写性能极高， Redis能读的速度是110000次/s，写的速度是81000次/s。

2. 支持数据持久化，支持AOF和RDB两种持久化方式。

3. 支持事务， Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。

4. 数据结构丰富，除了支持string类型的value外，还支持hash、set、zset、list等数据结构。

5. 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

6. 支持发布订阅， 通知， key 过期等特性。

缺点：

1. 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。

2. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。

### 2. Redis为什么快

1. 基于内存存储：数据操作都基于内存，没有IO开销，数据都已KV形式保存，查找和操作数据的复杂度是O（1）

2. 单线程实现：

   Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。

   Redis 6 引入多线程IO，但多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。

3. 非阻塞IO

   Redis使用多路复用IO技术，将epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

   ![image-20221129111317896](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221129111317896.png)

4. 优化的数据结构

   Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。

5. 底层模型不同

   Redis实现了自己的虚拟内存机制（VM），因为一般的系统调用系统函数的话，会浪费一定的时间与移动和请求。

   > Redis的VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。
   >
   > 通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。
   >
   > 
   >
   > Redis提高数据库容量的办法有两种：一种是可以将数据分割到多个RedisServer上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。需要特别注意的是**Redis**并没有使用**OS**提供的**Swap**，而是自己实现。

### 3. Redis相比Memcached优势

1. 数据类型：redis提供了字符串，list，set，map，zset等数据结构，memcached所有值都是简单字符串
2. 持久化：redis支持AOF和RDB持久化存储，memcache不支持
3. 集群模式：Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
4. 性能：redis速度比memcached快
5. 网络IO：redis单线程实现多路复用的IO模型，memcached使用多线程实现非阻塞IO
6. 支持服务端操作：redis可以在服务端直接进行操作，而memcached必须先通过客户端获取，再Set回去。

### 4.为什么使用Redis做缓存

 数据库的并发能力和读写速度是有限的，使用Redis可以大大降低数据库压力，并且操作Redis直接操作缓存中的数据，比操作磁盘中的数据快很多。

### 5. 为什么用Redis而不用本地做缓存。

Java提供的本地缓存轻量，快速，但是随着JVM的销毁而结束，在多实例下，缓存会产生不一致性。

redis是分布式缓存，多实例可以共用一份缓存，缓存具有一致性。

1. Redis是分布式缓存，多个实例可以共享一份缓存数据，本地缓存不能共享。
2. Redis提供了持久化，本地缓存程序重启即消失。
3. Redis可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；
4. Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；
5. Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；
6. Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；

### 6. Redis使用场景

1. 缓存
2. 排行榜，使用zset数据类型
3. 计数器，使用incr命令
4. 分布式会话，存储token或session信息
5. 分布式锁，应用高并发下可能产生不一致的问题。如：全局ID，减库存，秒杀等。
6. 朋友圈点赞，关注等
7. 消息系统 ，使用list或者stream可以实现队列功能

### 7. Redis数据结构

**基本数据类型**:string,hash,set,list,sortset

**其他数据结构：**

1、Bitmap：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1。签到，统计，布隆过滤器。

2、Hyperloglog。HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。场景：统计网页的UV（不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。

要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。

3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。

## 持久化

持久化原理查看：[mystudy/Redis/深度历险.md · Zhang-HaoQi/Knowledge - 码云 - 开源中国 (gitee.com)](https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/Redis/深度历险.md#2-持久化)

### 1. Redis持久化

将Redis内存数据写入磁盘，防止Redis意外宕机数据丢失和做Redis集群，数据备份。

**RDB**

指定间隔将内存快照写入磁盘，恢复时直接将快照文件数据读入内存。

优点：数据大规模恢复快

缺点：隔断时间备份，备份期间如果Redis宕机，会丢失最后一次快照后的所有修改。

**AOF**

追加写命令的形式备份数据，Redis重启时会读取该文件重新构建数据。

AOF使用追加写的方式，文件会越来越大，AOF有重写机制，当AOF文件的大小超过所设定的阈值时， Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.。

优点：支持3种同步时机，每次发生数据修改持久化；每秒同步；从不同步。可以根据程序要求选择合适的同步时机

缺点：aof文件大小远大于rdb，aof的运行效率不如rdb

**混合持久化**

两次RDB之间，使用AOF，减少RDB次数和AOF文件大小。

优点：即使用了RDB快速恢复的特性，又发挥AOF记录数据不丢失。

缺点：兼容性差，redis4.0之后版本才支持。日志可读性较差。

### 2. 如何选择合适的持久化方式

1. 数据不敏感，容易重新补回：关闭持久化
2. 数据比较重要，但可以容忍一段时间的数据丢失，如缓存，可以只是用RDB
3. 如果做内存数据库，要使用持久化，RDB和AOF都开启，RDB做数据备份，AOF保证数据不丢失。

### 3. Redis持久化数据和缓存怎么做扩容

## 过期键的删除/淘汰策略

### 1. Redis过期键的删除策略

**惰性删除：**不主动删除key，查询时判断是否过期，过期的话删除返回null。优点：不需要对过期数据做额外处理。缺点：删除不及时，浪费内存空间。

**定期删除：**周期性的随机测试一批设置过期时间的key并进行处理。优点：控制key的删除频率，减少对CPU的影响，减少内存占用。缺点：key已过期，但是没有删除，对业务产生影响。

**定时删除：**为key设置过期时间，到时自动删除。redis内部创建了一个定时器，过期时间到来时执行。优点：节约内存，及时清理无效key。缺点：对CPU不好，过期key较多时，删除过期key会占用一部分CPU时间，对服务器的响应时间和吞吐量造成影响

### 2. Redis内存淘汰策略

如果key没有设置过期时间，redis中的数据越来越多，当超出最大的允许内存后，Redis会触发淘汰策略，删除不常用数据，保证Redis服务器正常运行。

通过：maxmemory-policy配置，默认 noeviction

六种淘汰策略：

**noeviction** ：拒绝写，可以删。线上业务不能继续运行，默认的淘汰策略。

**volatile-ttl：** 根据key 的剩余寿命 ttl 的值进行淘汰，ttl 越小越优先被淘汰。

**volatile-lru**：使用LRU算法，尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。

**allkeys-lru：**使用LRU算法，淘汰所有key，这意味着没有设置过期时间的 key 也会被淘汰。

**volatile-random**：淘汰的 key 是过期 key 集合中随机的 key。

**allkeys-random:** 不论是否设置过期时间，都随机淘汰

总结：volatile策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的key 进行淘汰。

如果你只拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法汰。

redis4.0之后，新增两种：

1. volatile-lfu:设置已过期的key中，淘汰最不经常使用的key
2. allkeys-lfu：不论是否设置过期时间，都随机淘汰

## 缓存异常

缓存异常有四种类型，数据库的数据不一致、缓存雪崩、缓存击穿和缓存穿透。

### 1. 如何保证缓存与数据库双写时的数据一致性？

1. **先更新数据库，再更新缓存。  问题：并发更新，将脏数据刷新到缓存**
   1. ![image-20221129094459270](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221129094459270.png)

2. 先更新缓存，在更新数据库。 问题：数据库回滚
3. 先删除缓存，后更新数据库。 问题：删除后，有查询的话会再次建立缓存，造成脏数据
4. **先更新数据库，后删除缓存。  问题：删除失败**

### 2. 先删除缓存，后更新数据库产生的问题

问题：

1. 请求A删除缓存后，请求B发送新的请求，缓存不存在，将旧值更新进缓存，请求A更新数据库。如果数据没有设置失效时间，那么脏数据会一直存在。

   解决方式：使用延时双删，更新前删除一次，更新后，休眠1S后再删除一次。

2. 如果是主从分离，进行更新时，先将缓存中数据删除后，此时如果从库发生了读操作，此时缓存中没有，那么会从从库中获取数据返回，此时从库的数据还不是最新，又造成脏数据。

   解决方式：查询时，如果redis中数据为null，直接到主库进行查询。

使用读写异步的方式去解决：

请求A删除缓存后，更新数据库时，将请求A的更新信息发送到队列，此时如果信息B进行查询，如果redis为Null，并且更新队列中有数据，将查询B入队列。（思考：入队列后不是需要排队执行吗？如果排队的话那么需要等待程序响应，时间长的话用户体验就不是很好）

另外，读操作可以做去重处理，因为多个读操作在缓存中是没有意义的，这个方案自我感觉有一些问题。

### 3. 先更新数据库，再删除缓存产生的问题

问题：

删除缓存时，删除失败

解决：可以删除缓存时，如果删除失败，将删除缓存信息发送到队列（不可靠，容易造成误删，可以通过加UUID解决）

### 4. 双写模式和失效模式和最终方案

双写模式：先更新数据库，再更新redis。会造成写并发，导致旧的缓存把新的缓存覆盖

![image-20221129100636639](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221129100636639.png)

失效模式：先更新数据库，再删除redis。会造成删除缓存失败，再次读取脏数据。

![image-20221129100646785](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221129100646785.png)

最终方案：

![image-20221129100854223](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221129100854223.png)

两个模式，如果对数据的实时性要求不高，那么添加过期时间即可。一段时间后，肯定能获取最新的数据。

如果不能容忍缓存数据不一致，可以通过加读写锁保证并发读写或写写的时候按顺序排好队，读读的时候相当于无锁。

也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。

**使用cannal订阅更新缓存：**

![image-20221129100915912](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221129100915912.png)

canal更新缓存：可以通过监听mysql的binlog日志来更新redis，不好的是需要多维护一个canal服务。

canal解决数据异构：商城中，每个人推荐的内容可能都不一样，通过canal收集用户数据后，生成用户推荐表，为不同的用户推荐不同的数据。

### 5. 击穿

某一热点key失效，大量请求同时打入数据库，导致Mysql压力剧增。

解决方案：

1. 加互斥锁或者分布式锁，一次只允许一个请求进入数据库查询，其它请求等待。
2. 缓存永不过期
   1. 物理不过期，针对热点key不设置过期时间
   2. 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建（定时续期）

### 6. 穿透

恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大。

解决：

前提是做好无效参数的校验，如id必须大于0，小于XX等。

1. 不存在的key放入redis，并设置过期时间。适合：key数量有限，重复率较高。
2. 使用布隆过滤器，如果判断不存在，则一定不存在，判断存在，则可能存在（有误判率）。将数据存入redis前，先存入过滤器。适合：key重复率较低，数量较多等。可以应用于恶意请求过滤。

### 7. 雪崩

某一时刻，大量key同时失效，大量的请求打在了数据库上面，造成数据库压力过大。

原因：1. redis宕机。2. redis设置的缓存时间一样。

解决方案：

1. 事前
   1. 设置不同的过期时间
   2. 分级缓存
   3. 热点key永不过期
      1. 物理不过期，针对热点key不设置过期时间
      2. 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建（定时续期）
   4. redis集群
      1. 可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况
2. 事中
   1. 互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
   2. 使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。
3. 事后
   1. 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。

### 8. 什么是缓存预热

缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。

如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。

缓存预热解决方案：

1. 数据量不大的时候，工程启动的时候进行加载缓存动作；

2. 数据量大的时候，设置一个定时任务，进行缓存的刷新；

3. 数据量太大的时候，优先保证热点数据进行提前加载到缓存。

### 9. 什么是缓存降级

缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；

警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；

错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；

严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

## 线程模型

### 1. Redis为何选择单线程？

在Redis 6.0以前，Redis的核心网络模型选择用单线程来实现。

解答：redis是一个DB，大多数请求都不是CPU密集型，而是IO密集型，如果不考虑 RDB/AOF 等持久化方案，Redis是完全的纯内存操作，执

行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis选择了单线程的 I/O 多路复用来实现它的核心网络模型。

具体原因:

1. 避免多线程切换带来的开销：线程之前的调度
2. 避免同步机制的开销：加锁
3. 简单可维护：如果使用多线程，底层数据结构必须是线程安全的，让redis的实现更复杂

### 2. Redis的多线程

 Redisv4.0（引入多线程处理异步任务）

 Redis 6.0（在网络模型中实现多线程 I/O ）

Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程。Redis6.0引入多线程**I/O**，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。

> Redis在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。(持久化)
>
> 在 Redisv4.0 之后增加了一些的非阻塞命令如 UNLINK 、 FLUSHALL ASYNC 、 FLUSHDB ASYNC 。

### 3. 为什么引入多线程

 Redis的网络 I/O 瓶颈已经越来越明显。

互联网业务系统所要处理的线上流量越来越大，Redis的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，要提升 Redis的性能有两个方向：

1. 优化网络 I/O 模块
2. 提高机器内存读写的速度

内存和读写速度依赖于硬件，优化网络IO的方向：

1. 零拷贝技术或者 DPDK 技术 ： 复杂，难度高，依赖硬件
2. 利用多核优势：目前主线程只能利用一个核

Redis支持多线程主要就是两个原因：

1. 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核
2. 多线程任务可以分摊 Redis 同步 IO 读写负荷

引入多线程后，提升有1倍以上。

### 4. Redis的线程模型

**6.0之前**

Redis 是基于 reactor 模式开发了网络事件处理器，这个处理器叫做文件事件处理器,由于这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。

采用 IO 多路复用机制同时监听多个 Socket，根据 socket 上的事件来选择对应的事件处理器来处理这个事件。

多路指的是多个 Socket 连接，复用指的是复用一个线程。多路复用主要有三种技术：Select，Poll，Epoll,Epoll 是最新的也是目前最好的多路复用技术。

![image-20221129160200764](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221129160200764.png)

文件事件处理器结构：

1. 多个Scoket

   Socket 会产生 AE_READABLE 和 AE_WRITABLE 事件：

   当 socket 变得**可读时或者有新的可以应答的 socket 出现时**，socket 就会产生一个AE_READABLE 事件

   当 socket 变得可写时，socket 就会产生一个 AE_WRITABLE 事件

2. IO多路复用程序

3. 文件事件分派器

4. 事件处理器

   1. 包含：连接应答处理器，命令请求处理器，命令回复处理器

   2. 如果是客户端要连接 Redis，那么会为 socket 关联连接应答处理器

      如果是客户端要写数据到 Redis（读、写请求命令），那么会为 socket 关联命令请求处理器

      如果是客户端要从 Redis 读数据，那么会为 socket 关联命令回复处理器













## 问题：

1. redis的单线程和多线程
