# 泛型

## 1. 泛型入门

### 集合缺点

集合缺点：将元素添加到集合中，集合忘记元素的数据类型。取出元素时，编译时类型为Object，运行时类型为实际类型。

```java
 		List list  =  new ArrayList();
        list.add(new Student());
        Object student = list.get(0);
```

原因：不知道集合要存储什么类型的对象，设计成能保存任何类型，有很好的的通用性。

缺点：

1. 集合对元素类型没有任何限制，引发一些问题。例如，想创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，数据处理可能引发异常。
2. 由于把对象“丢进”集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。

```java
public class ListErr
{
	public static void main(String[] args)
	{
		// 创建一个只想保存字符串的List集合
		List strList = new ArrayList();
		strList.add("疯狂Java讲义");
		strList.add("疯狂Android讲义");
		// "不小心"把一个Integer对象"丢进"了集合
		strList.add(5);     
		strList.forEach(str -> System.out.println(((String)str).length())); 
	}
}
```

我们存储的有字符串，有integer类型的数据，但是我们打印时将所有数据强转成了String类型，出现报错。

### 泛型初使用

Java7之前泛型写法

```java
		List<String> strList = new ArrayList<String>();  
```

因为new ArrayList<String>();中的<String> 没有什么意义，所以Java7之后可以去掉。

```java
		List<String> strList = new ArrayList<>();  
```

修改上述程序

```java
public class GenericList
{
	public static void main(String[] args)
	{
		// 创建一个只想保存字符串的List集合
		List<String> strList = new ArrayList<>();  
		strList.add("疯狂Java讲义");
		strList.add("疯狂Android讲义");
		// 下面代码将引起编译错误
//		strList.add(5);    
		strList.forEach(str -> System.out.println(str.length())); 
	}
}

```

我们创建集合时，通过泛型规定了数据存储的数据类型为String，这样当我们存储非String类型的数据时，就会引起编译错误。

## 2. 使用泛型

### 常见Java集合的定义

当我们传递一个类型是，类中或方法中定义的K，V等都会被我们传递进去的参数类型所替代。

**Map接口**

```java
public interface Map<K,V> {
    public static <K, V> Comparator<Map.Entry<K, V>> comparingByKey(Comparator<? super K> cmp) {
            Objects.requireNonNull(cmp);
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> cmp.compare(c1.getKey(), c2.getKey());
        }
}   
```

**List接口**

```java
public interface List<E> extends Collection<E> {
        Iterator<E> iterator();
    
        <T> T[] toArray(T[] a);
    
        default void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final ListIterator<E> li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
}
```

### 泛型类和接口

当创建带泛型声明的自定义类，为该类定义构造器时，**构造器名还是原来的类名，不要增加泛型声明。**例如，为 Apple<T>类定义构造器，其构造器名依然是Apple，而不是Apple<T>!**调用该构造器时却可以使用Apple<T>的形式，当然应该为T形参传入实际的类型参数（Java7提供了<>，可以不传类型）。**

```java
public class Apple<T>
{
	// 使用T类型定义实例变量
	private T info;
	public Apple(){}
	// 下面方法中使用T类型来定义构造器
	public Apple(T info)
	{
		this.info = info;
	}
	public void setInfo(T info)
	{
		this.info = info;
	}
	public T getInfo()
	{
		return this.info;
	}
	public static void main(String[] args)
	{
		// 由于传给T形参的是String，所以构造器参数只能是String
		Apple<String> a1 = new Apple<>("苹果");
		System.out.println(a1.getInfo());
		// 由于传给T形参的是Double，所以构造器参数只能是Double或double
		Apple<Double> a2 = new Apple<>(5.67);
		System.out.println(a2.getInfo());
	}
}
```

#### 泛型类派生子类

当我们在类上使用泛型时，子类实现或者继承它时，我们需要进行类型的传递<类型>获取不写<类型>。不能只写<>或者传递一个明确的类型。

**写法一：**

```java
interface Offer<T>{
    
}
class Fruit<T> {

}
public class Apple<T> extends Fruit<T> implements Offer<T>
{
    
}
```

**写法二：**

```java
interface Offer<T>{
    
}
class Fruit<T> {

}
public class Apple<T> extends Fruit<String> implements Offer<String>
{
    
}
```

**写法三**

```java
interface Offer<T>{

}
class Fruit<T> {

}
public class Apple<T> extends Fruit implements Offer{
    
}
```

**错误写法：**

使用了泛型，但是并没有明确要传的泛型类型。

![image-20211129151939751](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211129151939751.png)

#### 不存在的泛型类



