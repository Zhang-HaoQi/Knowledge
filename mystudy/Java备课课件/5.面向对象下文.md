​    

## **包装类**

java提供了8种数据类型，但是这八种数据类型不支持面向对象的编程机制。

制约：所有引用类型的变量都继承了Object类，可以当成Object类型的变量使用。但是基本数据类型的变量不可以，如果某个方法需要Object类型的参数，但实际需要的时2，3这样的数值，就比较难处理。

为了解决这八种数据类型不能当成Object类型变量使用的问题，java提供了包装类。为八种基本类型都提供了相应的引用类型，称之为基本数据类型的包装类。

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/6d0a01d3f96f7f0b4899cb89184f62cb/0?w=1210&h=379)        

### **自动装箱拆箱**

jdk1.5提供了自动装箱和自动拆箱的功能，允许把基本类型值直接赋给对应的包装类引用变量，也允许把包装类对象直接赋给对应的基本类型变量。

```java
package baozhuanglei;

public class TestOne {
	public static void main(String[] args) {
		Integer inObj =5;
		Object boolObj = true;
	    int it =inObj;
	    if(boolObj instanceof Boolean) {
	    	boolean b = (Boolean) boolObj;
	    	System.out.println(b);
	    }
	}

}
```

自动装箱与自动拆箱大大简化了基本类型变量和包装类对象之间的转换过程。

注意：

- 自动装箱和自动拆箱一定要注意类型匹配
- Integer只能自动拆箱成int，int只能自动装箱成Integer（即使赋值给Objecct对象，也是利用了java的自动向上转型特性），不要试装箱成Boolean对象。

通过包装类，可以将基本数据类型变量当成对象使用，也可以将包装类当成基本数据类型变量使用。

### **基本类型与字符串类型的转换**

包装类还可以实现j基本类型变量和字符串之间的转换。把字符串类型转换为基本数据类型的两种方式。

1. 包装类提供的parseXXX（String s）静态方法（除Character之外的所有包装类都提供了此方法）。
2. 利用包装类提供的valueOf（String s）静态方法



**方法一：**

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/4a0f0a98246aa7b5ca56fe7aadc63ef8/0?w=522&h=342)        

```java
package baozhuanglei;

public class TestTwo {
	public static void main(String[] args) {
		String intStr = "123";
		System.out.println(Integer.parseInt("12365"));
		// 把一个特定字符串转换为int变量
		int it1 = Integer.parseInt(intStr);
		int it2 = Integer.valueOf(intStr);
		System.out.println(it1);
		System.out.println(it2);
		String floatStr ="4.56";
		//把一个特定字符串转换成float变量
		float ft1 = Float.parseFloat(floatStr);
		float ft2 = Float.valueOf(floatStr);
		System.out.println(ft1);
		System.out.println(ft2);
		//把一个float变量转换成String变量
		String fsStr = String.valueOf(2.456f);
		System.out.println(fsStr);
		String sdStr = String.valueOf(3.344);
		System.out.println(sdStr);
		//把一个boolean变量转换成String变量
		String boolStr = String.valueOf(true);
		System.out.println(boolStr.toUpperCase());
        // 把一个char变量转换为String变量
		char a = 100;
		String s = String.valueOf(a);
		System.out.println(s);
	}

}
```



**方法二：**

**將基本数据类型转换为字符串类型最简单的方法**

**在变量末尾加双引号。**

```
String a = 123+"";
```



### **包装类的比较**

#### **与数值类型的值进行比较**

虽然包装类是引用数据类型，但是包装类的实例可以与数值类型的值进行比较，这种比较是直接取出包装类实例所包装的数值进行比较的。

```java
		Integer n = Integer.valueOf(6);
		if(n>=5) {
			System.out.println("n大于5");
		}
```



#### **包装类与包装类的比较**

包装类实例的实际是引用数据类型，只有两个包装类指向同一个对象时才会返回true

```java
		//比较两个包装类的实例是否相等
		System.out.println(Integer.valueOf(2)==Integer.valueOf(6));//false
```



#### **通过自动装箱比较**



```java
	    Integer ita = 2;
		Integer itb = 2;
		Integer ite = 3;
		Integer itc = 128;
		Integer itd = 128;
	1.	System.out.println(ita==itb);//true
		System.out.println(ita==itc);//false
	3.	System.out.println(itc==itd);//false
```



从上面代码我们可以看出，1和3比较的都是相等的一个数字，但是却出现了不一样的结果，这是为何呢？

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/fdc22892e9f7531f1681130ab0722e0f/0?w=1278&h=327)        

从系统代码中可以看出，系统把一个-128 ~ 127的整数自动装箱成一个Integer实例，实际上是直接指向对应的数组，因此-128 ~ 127之间的同一个整数自动装箱成Integer实例，永远是引用cache数组的同一个数组，所以他们全部相等，但每次把一个不在-128~127之间的整数自动装箱成Integer实例时，系统会重新创建一个Integer实例，所以不相等。

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/4aadb6c4232acd34b12359f0b080c71f/0?w=1235&h=522)        

#### **compare比较包装类**

java7



包装类.compare(a,b)

a>b  返回1

a=b  返回0

a<b  返回-1



true>false



```java
System.out.println(Integer.compare(1, 100));//-1
System.out.println(Integer.compare(400,20));//1
System.out.println(Integer.compare(1,1));//0
System.out.println(Boolean.compare(true, false));//1
System.out.println(Boolean.compare(true, true));//0
System.out.println(Boolean.compare(false, true));//-1
布尔类型进行比较时true>false
```





不仅如此，Java 7还为Character 包装类增加了大量的工具方法来对一个字符进行判断。关于Character中可用的方法请参考Character的API文档。



java8

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/16673f7d552e360975bfecf893dff6f5/0?w=1444&h=852)        





```
package baozhuanglei;

public class TestThree {
	public static void main(String[] args) {
		byte b=-3;
		//将byte类型转换成无符号的整数
		System.out.println(Byte.toUnsignedInt(b));//253
		System.out.println(String.valueOf(b));//-3
		//指定使用十六进制解析无符号整数
		int val = Integer.parseUnsignedInt("ab",16);
		System.out.println(val);//171
		//将-12转换为无符号int类型，然后转换为16进制的字符串
		System.out.println(Integer.toUnsignedString(-12,16));//fffffff4
		//将两个数转换为无符号整数后相除
		System.out.println(Integer.divideUnsigned(-2, 3));//1431655764
		//将两个数转换为无符号整数相除后求余
		System.out.println(Integer.remainderUnsigned(-2, 7));//2
				
	}

}
```





​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/8ff9fd918d3ab13d30ad55aaeb30a6e4/0?w=1463&h=280)        

## **处理对象**

java都是Object类的实例，都可以使用该类中定义的方法，这些方法提供了处理Java对象通用的一些方法。

### **打印对象和toString方法**

toString()方法是Object类里的一个实例方法,所有的Java类都是Object类的子类,因此所有的Java对象都具有toString()方法。

```java
package dayinduixiang;
class Person{
	private String name;
	public Person(String name) {
		this.name=name;
	}
}

public class TestOne {
	public static void main(String[] args) {
		Person p = new  Person("张三");
		System.out.println(p);//dayinduixiang.Person@15db9742
		System.out.println(p.toString());//dayinduixiang.Person@15db9742
        //当直接打印对象的实例时，返回的是对象的toString方法的返回值，所以上面结果一样
		
	}

}
```

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/402cf6943ffbcf7e19e5874688483b27/0?w=1456&h=158)        

toString()方法是一个自我描述的方法。功能：程序员打印该对象时，系统输出对象的自我信息。

Object提供的toString方法总是返回该对象实现类的“类名+@+hashCode”值，这个返回值并不是真正的“自我描述的功能”，必须重写Object类的toString()方法。

```java
package dayinduixiang;

class Apple{
	private String color;
	private double weight;
	public Apple(String color,double weight) {
		this.color=color;
		this.weight=weight;
	}
	//重写toString()方法
	public String toString() {
		return "苹果的颜色是"+color+"苹果的重量是"+weight;
	}
	
	
}

public class TestTwo {

	public static void main(String[] args) {
		Apple p = new Apple("黄色",2.14);
		System.out.println(p);//苹果的颜色是黄色苹果的重量是2.14
		System.out.println(p.toString());//苹果的颜色是黄色苹果的重量是2.14
	}
	

}
```

通常toString的返回格式，运用字符串拼接

类名[field1=值1，field2=值2]；

```java
	//通常的返回格式
	public String toString() {
		return "Apple[color="+color+",weight="+weight+"]";
	}
```

### **==和equals（）方法**

判断两个变量相等的两种方式

1. 使用==
2. 使用equals()方法。

##### **用法对比**

- 如果两个变量时基本数据类型，且都是数值类型（数据类型不一定相同），两个变量相等，返回true。
- 两个引用类型的变量，只有他们指向同一个对象时，==判断才会true。==不可用于比较类型上没有父子关系的两个对象。

```java
package bijiao;

public class Son {
	
public static void main(String[] args) {
    //基本数据类型比较
	int it =65;
	float fl = 65.0f;
	System.out.println("65和65.0f是否相等"+(it==fl));//true
	char  ch ='A';
	System.out.println("65和'A'是否相等"+(it==ch));//true
	//引用数据类型比较
     由于str1和str2属于两个不同的对象，所以==比较时不相等。
	String str1 = new String("123");
	String str2 = new String("123");
	System.out.println(str1==str2);//false
	System.out.println(str1.equals(str2));//true
	System.out.println("hello".equals(new String("hello")));//true
	System.out.println(str1==new String("123"));//false

    
//	由于java.lang.String和Son类没有继承关系，所以下面代码报错
//	System.out.println("hello"==new Son());
	
}
}
```

##### **“hello”和new String("hello")**

当java直接使用"hello"的字符串直接量（包括在编译时就计算出来的字符串值）时，jvm将会使用**常量池**来管理这些字符串；

当使用new String("hello")时，JVM会先使用常量池来管理“hello”直接量，再调用String构造器创造一个新的String对象。新创建的对象保存在堆内存中。相当于new String(“hello”)长生了两个字符串对象。![img](https://qqadapt.qpic.cn/txdocpic/0/1d24cedc55e971e5c79004bd6e7218f0/0?w=1160&h=136)        

```java
package bijiao;

public class One {
	public static void main(String[] args) {
		String s1 = "疯狂Java";
		String s2 = "疯狂";
		String s3 = "Java";
		//s4后面的字符串值在编译时已经确定下来，
		//s4直接饮用变量池中的“疯狂Java”;
		String s4 = "疯狂"+"Java";
		//s5后面的字符串值在编译时已经确定下来，
		//s5直接饮用变量池中的“疯狂Java”;
		String s5 = "疯"+"狂"+"Java";
		//s6后面的字符串不能在编译时就确定下来
		//不能引用常量池中的字符串
		String s6 = s2+s3;
		//使用构造器创建一个String对象
		//s7引用堆内存中新创建的String对象
		String s7 = new String("疯狂Java");
		System.out.println(s1==s4);//true
		System.out.println(s1==s5);//true
		System.out.println(s1==s6);//false
		System.out.println(s1==s7);//false
		System.out.println(s1.equals(s4));//true
		System.out.println(s1.equals(s5));//true
		System.out.println(s1.equals(s6));//true
		System.out.println(s1.equals(s7));//true
	}

}
```

JVM常量池保证相同字符串的直接量只有一个，不会产生多个副本。例如s1，s2，s3，s4在编译时期就能确定下来，因此他们都将引用常量池中的同一个字符串对象。

使用new String()创建的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存），不会放入常量池中。

在很多时候，程序判断两个引用变量是否相等时，希望“值相等”，并不严格要求两个引用变量指向同一个对象。例如两个字符串变量，只要求引用字符串对象中保存的值相等即可认为相等。此时就可以使用equals()方法判断

##### **equals()方法**

equals()方法是Object提供的实例方法，可供所有类使用，但是正常情况下equals()方法和==相同，没有任何差别，所以需要时需要重写equals()方法。

注：String()类已经重写了equal()方法，所以当比较两个值相同的字符串时，返回true。

例如：

```java
	String ss1 = new String("123");
		String ss2 = new String("123");
		System.out.println(ss1.equals(ss2));//true
		System.out.println(ss1==ss2);//false
```

![img](https://qqadapt.qpic.cn/txdocpic/0/7ca88ed4b7fd0449f8de592fb3cc06ed/0?w=1160&h=219)        

```java
package bijiao;
class Person{
	public boolean equals(Object obj) {
		//不加判断，总是返回true
		//即任何对象都和Person实例相等
		return true;
	}
	
}
  //定义一个Dog的空类
class Dog{}

public class Two {
	public static void main(String[] args) {
		Person p = new Person();
		Dog d = new Dog();
	
		System.out.println(p.equals(d));//true
		System.out.println(p.equals(new String("123")));//true
				}

	

}
```

从上面代码中我们可以看出，equals()的用法我们可以随意的修改。

###### 重写equals（）方法

大部分时候，并不希望看到Person对象和Dog对象相等的“荒唐局面”,还是希望两个类型相同的对象才可能相等，并且关键的成员变量相等才能相等。

```java
package bijiao;

class Person {
	private String name;
	private String idStr;

	public Person(String name, String idStr) {
		this.name = name;
		this.idStr = idStr;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return this.name;
	}

	public void setIdStr(String idStr) {
		this.idStr = idStr;
	}

	public String getIdStr() {
		return this.idStr;
	}

	public boolean equals(Object obj) {
		// 如果两个对象为一个对象，返回true
		if (this == obj) {
			return true;
		}
		//判断obj所属的类是否是Person类的实例
		if(obj!=null&&obj.getClass()==Person.class) {
			Person personObj = (Person)obj;
			//并且当当前对象的idStr与obj对象的idStr相等时才可判断俩对象相等
			if(this.getIdStr().equals(personObj.getIdStr())) {
				return true;
			}
		}
		return false;
	}

}

// 定义一个Dog的空类
class Dog {
}

public class Two {
	public static void main(String[] args) {
	Person p1 = new Person("孙悟空","12343433433");
	Person p2 = new Person("孙行者","12343433433");
	Person p3 = new Person("孙悟饭","99933466");
	System.out.println(p1.equals(p2));//true
	System.out.println(p1.equals(p3));//false
	
	
	//Person.class  Person类的实例
	System.out.println(Person.class);  //class bijiao.Person
	//查看p1的所属类
	System.out.println(p1.getClass());//class bijiao.Person
	}

}
```

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/eefefa1e8529670c78a150a23db5ab45/0?w=1213&h=348)        

###### **重写equals（）方法的要求**

![img](https://qqadapt.qpic.cn/txdocpic/0/c85b56109b2fa7481fd68f16b4300960/0?w=1204&h=380)        

## **类成员**

### **类成员的基本介绍**

**static修饰**

static修饰的成员为类成员，类成员有类变量，类方法，静态初始化块。static不能修饰构造器。static修饰的成员属于整个类，不属于单个实例

在java类里面只能包含成员变量，方法，构造器，初始化块，内部类（包括接口、枚举）5种成员。

其中static可以修饰成员变量，方法，初始化块，内部类（包括接口、枚举）

**类的生存**

​       类变量属于整个类，当系统第一次准备使用该类时，系统会为该类变量分配内存空间，类变量开始生效，直到该类被卸载，该类的类变量所占有的内存才被系统的垃圾回收机制回收。类变量生存范围几乎等同于该类的生存范围。当类初始化完成后，类变量也被初始化完成。        

**类的访问**

类变量可以通过类访问，也可以通过类的实例访问，但是通过实例访问是一种假象，对象根本不拥有类变量。当系统通过类的实例访问类变量时，java底层自动把类的实例转换为类来访问。![img](https://qqadapt.qpic.cn/txdocpic/0/0bb5fea0a914725f760eb63fadde2e57/0?w=1159&h=112)        

类方法同类变量一样，也可以通过类的实例访问。所以即使类的实例为空，也可以通过实力访问，因为java底层自动把类的实例转换为类来访问。





```java
package lei;

public class One {
	
	public static void eat() {
		System.out.println("吃");
	}
	public static void main(String[] args) {
		One o = null;
		o.eat(); //吃
	}
}
```

可以访问，说明空对象可以访问它的类成员

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/e68004ba48be78f169e1a0d413c1cc13/0?w=1175&h=151)        



​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/5ba9f2593c0cc1a56e5074dc13710177/0?w=1148&h=129)        

### **单例类**

正常情况下，类构造器权限为public，允许其他类自由创建该类实例。在某些情况下，不允许自由创建该类的对象，而只允许该类创建一个对象。为避免其他类创建该类的实例，把该类的构造器设置成private。这样的类被称为单例类

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/063750ac76be9e608470616f4ec9e418/0?w=1155&h=200)        

```java
package lei;

class Singleton{
	//创建一个类变量来缓存曾经创建的实例
	private static  Singleton instance;
	//使用private修饰构造器，隐藏
	private Singleton() {
		
	}
	//提供一个静态方法，返回Singleton()实例
	//该方法可加入自定义控制，保证只产生一个Singleton对象
	public static Singleton getInstance() {
		//如果instance为null，说明没有Singleton实例
		//如果instance不为null，说明已经创造了一个Singleton实例
		//将不会再创造instance实例
		if(instance==null) {
			
			return instance = new Singleton();
		}
		return instance;
		
		
		
	}

}
public class Two{
	public static void main(String[] args) {
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		System.out.println(s1==s2);//true  说明s1和s2指向同一个对象
		
	}
}
```





​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/f87648e2e297f0ec8d73b436f94db3f2/0?w=1230&h=141)        

### **final修饰符**

final关键字可用于修饰类，变量和方法。类似于c#中的sealed关键字，用于修饰的类，变量，方法不可改变。



#### **final变量**

final修饰变量时，表示该变量一旦赋值，就不可改变。final可修饰成员变量（类变量，实例变量），局部变量，形参。

final修饰的变量不可改变改变。一旦获得初始值，该final变量的值就不能被重新赋值。（有的书上说不能赋值，这种说法不准确）

##### **final成员变量**

final修饰的变量必须由程序员显示的指定初始值。



final修饰的类变量、实例变量能指定初始值的地方如下。

类变量：必须在静态初始化块中指定初始值或声明该类型变量时指定初始值。而且只能在其一指定。

实例变量：必须在非静态初始化块、声明该实例变量或构造器中指定初始值。而且只能在其一指定。

```java
package lei;

public class Three {
	final int a = 1;
	//在构造器或者初始化块中赋值
	final String str;
	final int c;
	final static double d;
	//final int e;

	
	{
		//在非静态代码块中赋值，允许
		str ="Hello";
		//a声明变量时已经有了默认值，不能重新赋值
		//a=5;
	}
	static {
		//静态初始化块
		d=3.14;
	}
	//构造器
	public Three() {
		c=100;
	}
	public void change() {
		//方法中不允许给final类型的变量赋值
		//e=100;
	}
}
```

如果打算在初始化块或者构造方法中为final成员变量赋值，则不要在赋值之前访问final成员变量。

如：

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/5a720572f5e74ea9b39630cb358af16d/0?w=852&h=186)        

##### **final局部变量**

final修饰的变量必须由程序员显示的指定初始值。

final局部变量可以在声明数据类型时赋值，也可以在之后的代码中赋值。但只能赋值一次





```
package lei;

public class Four {
	public void test(final int a) {
		//产生实例对象时，会为a赋值，所以a不能够再次赋值
		//a=100;报错
		System.out.println(a);
	}
	public static void main(String[] args) {
		Four f = new Four();
	    f.test(50);
	    
	 final   String a = "100";
	 //a="200"; 非法
	 final int b;
	 b=100;
	 //b=1000;非法
	}

}
```

##### **final修饰基本变量和引用变量区别**

修饰基本类型变量：基本类型变量赋值后不能重新赋值，因此基本类型变量不能够改变。

修饰引用类型变量：引用类型变量，他保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生变化。

```
package lei;
import java.util.Arrays;
class Person{
	private int age;
	public Person(int age) {
		this.age=age;
	}
	public void setAge(int age) {
		this.age=age;
	}
	public int getAge() {
		return this.age;
	}
}
public class Six {
	public static void main(String[] args) {
		//final修饰数组变量  iArr是一个引用变量
		final int[] iArr = {5,7,6,8};
		System.out.println(Arrays.toString(iArr));
	    //对数组元素进行排序，合法
		Arrays.sort(iArr);
		System.out.println(Arrays.toString(iArr));
		//对数组元素重新赋值，合法
		iArr[2]=100;
		System.out.println(Arrays.toString(iArr));
		//对iArr重新赋值 不合法
		//iArr = null;
		
		

	final	Person a = new Person(18);
		System.out.println(a.getAge());
		//对实例对象a的age变量重新赋值，合法
		a.setAge(20);
		System.out.println(a.getAge());
		//对 a重新赋值  不合法
		//a=null;
	}

}
```





从上面可以看出，final修饰的引用类型的变量不能重新赋值，但是可以修改引用对象的值。

##### **可执行宏替换的final变量**

对一个final修饰的变量来说，不管他是类变量、实例变量、还是局部变量，只要满足三个条件就不再是一个变量，而是一个直接量。即常量

1. 使用final修饰
2. 在定义fianl时制定了初始值
3. 该初始值在编译时就被确定下来，不能更改。



```
package lei;

public class Seven {
	public static void main(String[] args) {
		//定义一个普通局部变量
		final int  a = 4;
		System.out.println(a);
		
	}
}
```







定义了一个初始值为5的final局部变量。对于这个程序来说，变量a其实根本不存在，

当程序执行System.out.println(a);时，相当于执行System.out.println(5);

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/ac48ad79e1ee9815ba2b57accf7f3617/0?w=1152&h=171)        



如果被赋的表达式只是基本的算术表达式或字符串链接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成“宏变量”处理。





```java
package finalshiyong;

public class One {
	public static void main(String[] args) {
		final int a = 5+2;
		final double b = 1.2/3;
		final String str = "疯狂"+"Java";
		final String book = "疯狂Java讲义："+99.0;
		//下面的book2变量的值因为调用了方法，所以无法在编译时被确定下来
		final String book2 ="疯狂Java讲义："+String.valueOf(99.0);
		System.out.println(book=="疯狂Java讲义：99.0");//true
		System.out.println(book2=="疯狂Java讲义：+99.0");//false
		System.out.println(book);
		System.out.println("疯狂Java讲义：+99.0");
	}

}
```





a、b、str、book在编译时都可以确定，所以都是宏变量

book和book2的区别：book隐式转换为字符串，book2显式转换为字符串。由于book2的值需要调用String的方法，因此编译时无法确定book2的值，book2不会当成宏变量处理。

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/4b065422c35055c1a6600b8ac37c1df9/0?w=1259&h=116)        

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/036bb2a253a52a554c552b1f7bd1408a/0?w=1263&h=156)        

###### **深入宏替换**

```java
package finalshiyong;

public class Two {
	public static void main(String[] args) {
		String s1="疯狂Java";
		// s2变量引用的字符串可以在编译时就确定下来
		//因此s2直接引用常量池中已有的"疯狂Java"字符串
		String s2="疯狂"+"Java";
		System.out.println(s1==s2);//true
		String str1 ="疯狂";
		String str2 = "Java";
		//将str1和str2链接起来
		String s3 = str1+str2;
		System.out.println(s1==s3);//false
		
	}

}
```

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/c07175dc2fb520ac26124e09bf4b890b/0?w=1288&h=401)        

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/2f66572be7ef174ea5011fcd05e795dd/0?w=1198&h=177)        

#### **final方法**

final修饰的方法不可被重写

Java提供的Object类里就有一一个final 方法: getClass(),因为java不想让其他类重写此方法

注意：final修饰的方法仅仅不能够重写，但是可以重载

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/43d9b6fb5f5dd6c4a393c987182b303d/0?w=496&h=317)        



如果父类方法的权限是private，那么子类就无法重写，此时子类如果创建一个和父类一样的方法，不是父类方法的重写，而是新创建了一个方法。

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/f2952add75d27d6c3c69bb308b651dbe/0?w=547&h=337)        

#### **final类**

final修饰的类不可以有子类，例如java.lang.Math类就是一一个final 类，它不可以有子类。



当子类继承父类时，可以获取父类的信息，可以通过重写父类方法获取父类的细节，这样不安全。为了保证类不可继承，可以使用final修饰这个类。

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/c7c18dcbb429a6b342626bfaf626fc5a/0?w=516&h=93)        

#### **不可变类**

##### **介绍**

即创建该类的实例后，该实例的实例变量是不可改变的

java的八个包装类和String类都是不可改变类。创建实例后，实例的实例变量不能改变

如：





```
        Double d = new Double(3.14);
		String s = new String("张三");
```





作为参数Double类和String类肯定需要提供实例变量来保存这两个参数，但程序无法修改这两个实例变量的值，因此Double类和String类没有提供修改它们的方法。

##### **创建规则**

1. 使用private和final修饰符来修饰该类的成员变量。
2. 提供带参数构造器，用于根据传入参数来初始化类里的成员变量。
3. 仅为该类的成员变量提供getter方法，不要为该类的成员变量提供setter方法，因为普通方法无法修改final修饰的成员变量。
4. 如果有必要，重写Object类的hashCode()和equals()方法。equals()方法根据关键成员变量来作为两个对象是否相等的标准，除此之外，还应该保证两个用equals(方法判断 为相等的对象的hashCode()也相等。





```
public class Three {
	public static void main(String[] args) {
	String str1 = new String("Hello");
	String str2 = new String("Hello");
	System.out.println(str1==str2);//false
	System.out.println(str1.equals(str2));//true
	
	System.out.println(str1.hashCode());//69609650
	System.out.println(str2.hashCode());//69609650
		
	}

}
```





​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/45c8872cfc9fba18d76723bf2a13e207/0?w=1219&h=111)        





```
    String str1 = new String("Hello");
	String str2 = new String("Hello");
	System.out.println(str1==str2);//false
	System.out.println(str1.equals(str2));//true
	
	System.out.println(str1.hashCode());//69609650
	System.out.println(str2.hashCode());//69609650
```





不可变类的实例在整个生命周期中永远处于初始化状态，它的实例变量不可改变。



前面介绍final关键字时提到，当使用final修饰引用类型变量时，仅表示这个引用类型变量不可被重新赋值，但引用类型变量所指向的对象依然可改变。这就产生了一个问题:当创建不可变类时，如果它包含成员变量的类型是可变的,那么其对象的成员变量的值依然是可改变的一这个不可变类其实是失败的。





```
package finalshiyong;
class Name{
	private String firstName;
	private String lastName;
	public Name() {
		}
	public Name(String firstName,String lastName) {
	this.firstName=firstName;
	this.lastName=lastName;
	}
	public String getFirstName() {
		return this.firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName=firstName;
	}
	public String getLastName() {
		return this.lastName;
	}
	public void setLastName(String lastName) {
		this.lastName=lastName;
	}
	
	}
public class Person {
	private final Name name;
	public Person(Name name) {
		this.name=name;
	}
	public Name getName() {
		return name;
	}
	public static void main(String[] args) {
		Name n = new Name("悟空","孙");
		Person p = new Person(n);
		System.out.println(p.getName().getFirstName());//悟空
		n.setFirstName("八戒");
		System.out.println(p.getName().getFirstName());//八戒
		
	}

}
```







上述代码n.setFirstName("八戒");修改了Name对象firstName的值，但由于Person类的name实例引用了Name对象，就导致了Person对象的name的firstName会被改变，破坏了Person类设计的初衷。



为了保持Person的不可变性，可以采用以下封装。。





```
public class Person {
	private final Name name;
	public Person(Name name) {
        //
		this.name=new Name(name.getFirstName(),name.getLastName());
	}
	public Name getName() {
		return new Name(name.getFirstName(),name.getLastName());
	}
	public static void main(String[] args) {

		Person p = new Person(new Name("张","浩琦"));
		System.out.println(p.getName().getFirstName());
		
	}

}
```





​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/ba7631b716c893370b38e8bbaf395dd4/0?w=1265&h=223)        

此时，Person对象的name的firstName不会被修改。

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/32ef1872b44dbd5b1fbaecaac184c011/0?w=1238&h=107)        



##### **缓存实例的不可改变类**

（疯狂讲义）213页

## **抽象类**

### **为什么用抽象类？**

假如父类animal有一个方法move(),指的是小动物的运动方式，但是不同的动物的运动方式是不一样的，有游的，又跑的。此时父类的代码中move（）的方法体没有一个具体的方法体。

我们完全可以不用管move（）这个方法，但是假如有一个animal的引用变量，该变量实际引用的是子类的实例，那么我们想调用父类的move（）方法，必须通过强制类型转换，这降低了程序的灵活性。

### **抽象方法和抽象类**

- 抽象方法和抽象类必须使用abstract修饰，如果一个类含有抽象方法，他一定是抽象类，抽象类不一定含有抽象方法。
- 抽象类不能被实例化
- 抽象类可以有成员变量，初始化块，构造方法，方法（普通方法和抽象方法都ok），内部类（接口，枚举）5种。
- 抽象类的构造方法不能创建实例，只能被子类的实例调用
- 含有抽象方法的类（直接定义了一个抽象方法，或者继承了一个抽象类，里面含有抽象方法，或者是实现了一个接口，接口中的抽象方法没有实现）指定被定义成抽象类

### **抽象类举例**

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/d84f380ec2a4ad382bbe15f7d70206a8/0?w=672&h=346)        

### **abstract和其他修饰符的爱恨情仇**

**final**

abstract修饰的类只能被继承，fianl修饰的类为最终类，不能被继承，所以二者不能同时使用。

**static**

static是修饰类成员的，abstract修饰的方法没有方法体，不可能调用一个没有方法体的方法，所以二者不能同时使用。

**变量和构造器：**

abstract不能用于修饰变量和构造器，抽象类里面定义的构造器只是普通构造器

```java
package jiekou;

abstract class Father {

    String name;
    String profession;
    String from;
    {
    	from ="中国";
    }
	public Father(String name,String profession) {
		this.name=name;
		this.profession=profession;
		
	}
	public void drink() {
		System.out.println("都喜欢和牛奶");
	}

		public abstract void eat();

}
public class Son extends Father{
	public Son() {
		super("张情","程序员");
		
	}

	@Override
	public void eat() {
	System.out.println("吃苹果");
		
	}
	public static void main(String[] args) {
	    Son son = new Son();
	    son.eat();
	    son.drink();
	    System.out.println(son.from);
	    ;
	}
	
	
}
```







## **接口**

针对于java8

### **定义**



```
【修饰符】 interface 接口名  extends 接口1，接口2{
         类常量
  类方法
  默认方法（default修饰的方法）
  抽象实例方法
  内部类，接口，枚举定义
}
```





- 接口没有代码块和构造方法
- 修饰符只能是public 或者是空。空表示只能在本包使用
- 接口中定义的普通方法默认都是使用public abstract修饰
- 接口种定义的变量默认都是 public static final修饰。并且都得有默认值。
- 接口只能继承接口，不能继承类。可以一次继承多个接口
- 子类实现了接口，如果这个接口继承了多个接口，那么这个类就需要把这些接口的方法全部实现。





```
package riviewjiekou;
 interface Native {
	void eat();
	default void drink() {
		System.out.println("喝");
	}
	static void move() {
		System.out.println("玩");
	};

}
public class Animal implements Native {

	@Override
	public void eat() {
		// TODO Auto-generated method stub
		System.out.println("我会吃");
		
	}
	public static void main(String[] args) {
	
		Native a = new Animal();
		a.drink();  喝
		a.eat();   我会吃
		Native.move();  玩
	}

}
```





- **如果编译时类型是接口，运行时类型是接口的实现类，那么这个变量只能调用接口中定义的方法，不能调用实现类中定义，接口中未定义的方法**
- **如果我们想在接口的实现类中定义非接口或者父类中的方法，我们不能使用@Override关键字，否则会产生报错。**

接口：                                                                                    

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/f2ac7be58741f1affe3fc21ba582e921/0?w=381&h=146)        

  实现类

​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/6e25d64254ba2cabed00123eae4c5547/0?w=714&h=355)        

## **遗留问题**

### **缓存实例的不可改变类**

（疯狂讲义）213页

### **抽象类**

### **接口**