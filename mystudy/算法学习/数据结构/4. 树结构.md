# 树结构



![image-20220124164810364](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124164810364.png)

![image-20220124164851345](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124164851345.png)



![image-20220124164908039](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124164908039.png)



特点：高效

树的数据结构：

![image-20220124165113307](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124165113307.png)



## 1. 二叉树概念

1. 和链表一样，动态数据结构
2. 二叉树具有唯一根节点
3. 二叉树中，每个节点最多有两个孩子
4. **如果一个节点一个孩子都没有，称为叶子节点**
5. 每个节点最多有一个父亲节点，根节点没有父亲节点

![image-20220124165630592](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220124165630592.png)

6. **二叉树具有天然的递归结构**

   1. 每个节点的左子树也是二叉树
   2. 每个节点的右子树也是二叉树

   ![image-20220124165718658](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124165718658.png)

7. 二叉树不一定是“满”的

   1. 情况一：没有左孩子或者又孩子

   ![image-20220124165851862](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124165851862.png)

   2. 情况二：根节点只有左子树，没有右子树

      ![image-20220124165952984](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124165952984.png)

      3. 情况三：只有一个根节点

   ![image-20220124170030787](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124170030787.png)

   4. 空本身也是一种树。



## 2. 二分搜索树

### 定义

1. 二分搜索树也是二叉树

2. **二分搜索树的每个节点的值：**

   1. 大于其左子树的所有节点的值
   2. 小于其右子树的所有节点的值

3. 每一颗子树也是二分搜索树

   ![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220124170341037.png)

   4. 存储的元素必须有可比较性

      二分搜索树可以快速的帮助我们查找，但是我们存储的数据一定要有一定的可比较性

### 代码实现

#### 1. 初始化二分搜索树

1. 限制存储的数据，必须具有可比较性的数据。
2. 定义内部节点，当前节点的值以及左右子孩子。
3. 定义树，根节点，默认情况下，根节点为null。

```java
//存储的数据必须是有可比较性的数据。
public class BST<E extends Comparable<E>> {

    //定义内部节点类
    private class Node {
        public E e;
        public Node left, right;

        public Node(E e) {
            this.e = e;
            left = null;
            right = null;
        }
    }

    //定义根节点
    private Node root;
    //定义节点的数量
    private int size;


    //构造器
    public BST() {
        //默认情况下，根节点为Null
        root = null;
        size = 0;
    }

    //获取节点数量
    public int size() {
        return size;
    }

    //判断树是否为null
    public boolean isEmpty() {
        return size == 0;
    }
}
```

#### 2.添加数据（重复数据不添加，递归实现）

1. 默认情况下，root为null，第一个添加元素为根元素41
2. 再添加一个元素22，从根节点开始比较，比根节点小，插入到根节点的左子树，否则插入到右子树
3. 如果我再添加一个元素22，此时这个元素的存储有两种情况
   1. 如果树中已有22这个元素，不进行添加。因为我们定义的二叉树左侧比当前节点小，右侧比当前节点大，没有考虑重复元素的情况。（本文实现）
   2. 修改我们定义树的概念。如：左侧存储小于等于当前节点的元素，或右侧存储大于等于当前节点的元素。
4. 二分搜索树的添加元素的实现方式
   1. 递归实现（本文实现）
   2. 非递归实现：类似链表

##### **方式一：对根节点特殊处理**

对根节点特殊处理，每次添加的时候，添加的都还子节点。

临界值的判断：

1. 如果插入的值每个节点已存在，直接返回
2. 如果插入的值小于父节点，并且父节点的左孩子为null，则将此节点插入到左侧
3. 如果插入的值大于父节点，并且父节点的右孩子为null，则将此节点插入到右侧

递归的调用：

1. 左右孩子都不是null，如果插入的值大于父节点，则将父节点的右孩子入递归，否则左孩子。

```java
    //添加节点
    public void add(E v) {
        //当树为null时，添加根节点
        if (root == null) {
            root = new Node(v);
            size++;
        } else
            add(root, v);
    }

    //向以node为根的二分搜索树中插入元素e，递归算法
    private void add(Node node, E e) {
        //终止条件
        if (e.equals(node.e)) {
            return;
        } else if (e.compareTo(node.e) < 0 && node.left == null) {
            node.left = new Node(e);
            size++;
            return;
        } else if (e.compareTo(node.e) > 0 && node.right == null) {
            node.right = new Node(e);
            size++;
            return;
        }
        //递归
        if (e.compareTo(node.e) < 0)
            add(node.left, e);
        else add(node.right, e);
    }

```

##### 方式二：根节点不做特殊处理

1. 临界值考虑：
   1. 如果一棵树，某个节点为null，那我们直接创建一个新的节点返回
   2. 如果是根节点为null，我们也可以直接适配使用。
2. 递归调用：
   1. 如果插入的元素，大于父节点，那么当前元素在父节点的右侧，将父节点的右侧进行递归调用。
   2. 如果插入的元素，小于父节点，那么当前元素在父节点的左侧，将父节点的左侧进行递归调用。
   3. 对于递归的元素，我们判断它是否为null，如果是null，则新创建元素返回。（对应临界值的考虑）

```java
//添加元素方式二：所有的元素都一视同仁。

    //添加节点
    public void add(E e) {
        root = add(root, e);
    }

    //向以node为根的二分搜索树中插入元素e，递归算法
    private Node add(Node node, E e) {
        //临界值判断，如果要添加元素的节点为null，则直接返回一个新的元素
        if (node == null) {
            size++;
            return new Node(e);
        }
        //判断要添加的元素与当前节点的大小
        if (e.compareTo(node.e) > 0) {
            //说明在当前节点的右侧添加
            node.right = add(node.right, e);
        } else if (e.compareTo(node.e) < 0) {
            //说明在当前节点的左侧添加
            node.left = add(node.left, e);
        }
        //如果与当前节点相等，则不需要处理，直接返回即可。
        return node;
    }
```

#### 3. 搜索元素（递归）

和添加的思想差不多。

临界值判断：

1. 当元素为null的时候，返回false

递归调用：

1. 如果元素，大于父节点，那么当前元素在父节点的右侧，将父节点的右侧进行递归调用。
2. 如果元素，小于父节点，那么当前元素在父节点的左侧，将父节点的左侧进行递归调用。

```java
    //看二分搜索树中是否包含元素e
    public boolean contains(E e) {
        return contains(root, e);
    }

    private boolean contains(Node node, E e) {
        if (node == null) return false;

        if (e.compareTo(node.e) > 0)
            return contains(node.right, e);
        else if (e.compareTo(node.e) < 0)
            return contains(node.left, e);
        //相等的情况下。
        else return true;
    }
```

#### 4. 遍历

即把所有的节点都访问一遍

比如说，我存的是学生的分数，此时我需要把所有学生的分数加20分，就需要遍历添加。

对于遍历操作，两棵子树都要顾及。

遍历方式

1. 前序遍历：根左右
2. 中序遍历：左根右
3. 后续遍历：左右根

##### 前序遍历

![image-20220125221016538](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220125221016538.png)

最自然，最常用的遍历方式。

先访问节点，再访问左子树，再访问右子树

```java
 //前序遍历
    public void preOrder() {
        preOrder(root);
    }

    private void preOrder(Node node) {

        //方法一：
        //递归终止条件
        if (node == null) return;
         //父节点
        System.out.println(node.e);
        //遍历左子树
        preOrder(node.left);
        //遍历右子树
        preOrder(node.right);

        //方法二：
        if (node!=null){
            //父节点
            System.out.println(node.e);
            //遍历左子树
            preOrder(node.left);
            //遍历右子树
            preOrder(node.right);
        }
    }

```

**测试案例**

```java
public class Main {
    public static void main(String[] args) {
        BST bst = new BST();
        int[] arr = {5,3,6,8,4,2};
        for (int item: arr
             ) {
            bst.add(item);
        }
        bst.preOrder();
    }
}
```

**结果**

![image-20220125220703246](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220125220703246.png)

##### 中序遍历

特点:遍历完成后，数据是有序的。

![image-20220125221943964](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220125221943964.png)

```java
    //中序遍历
    public void inOrder() {
        inOrder(root);
    }

    private void inOrder(Node node) {
        //递归终止条件
        if (node == null) return;
        //遍历左子树
        inOrder(node.left);
        //父节点
        System.out.println(node.e);
        //遍历右子树
        inOrder(node.right);

    }
```

![image-20220125222554512](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220125222554512.png)

##### 后续遍历

![image-20220125222537037](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220125222537037.png)

```java
    //后序遍历
    public void postOrder() {
        postOrder(root);
    }

    private void postOrder(Node node) {
        //递归终止条件
        if (node == null) return;
        //遍历左子树
        postOrder(node.left);
        //遍历右子树
        postOrder(node.right);
        //父节点
        System.out.println(node.e);
    }

```

![image-20220125222603492](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220125222603492.png)



# 算法



