# Mysql进阶

[MySQL实战45讲 (gitee.io)](https://funnylog.gitee.io/mysql45/)

[MySQL索引与查询优化 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903818056974350#heading-21)

## 基础

### 1. 三大范式

范式程度越高，数据粒度越小。性能上也会降低。

**建表原则**

符合一范式的基础上，建立二范式。三范式根据实际要求，不一定必须符合

**第一范式**

要求：每个属性都不可以再分

![image-20211210161546003](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211210161546003.png)

例子：
![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211210161616854.png)
存在问题：
1、 数据沉余：如姓名，系名，系主任，重复了很多次
2、 插入异常：如果我新建一个计算机系，系主任是小张，学生还没入学，那么id，姓名，课名等字段无法设置
3、 删除异常：假如小明毕业，删除小明的信息，那么小明所在系也会被删除。
4、 修改异常：如果小明转专业，那么我得把小明的系名和系主任都改了，并且得多次修改，因为小明出现了三次

**第二范式**

要求：在一范式的基础上，消除了非主属性对码的部分函数依赖。
码：在一个表中，可以决定一个元素的属性集合（id和课名一旦确定，那么所有的属性都可以确定）
![image-20211210161709517](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211210161709517.png)
主属性：码就是主属性
非主属性：除主属性之外的属性
函数依赖：y=f(x);x的值决定y，y依赖x。如：1、id确定之后，姓名，系别，系主任都可以确定了。2、系名确定了，系主任就确定。
完全函数依赖：x1，x2等决定y。如：id和课名可以决定分数。那么分数就是完全依赖于id和课名。
部分函数依赖：y依赖于x，但是y不完全依赖于x。如用id和课名去决定姓名。姓名由id就直接确定了，所以姓名不完全依赖与id和课名这两个字段

**判断是否为二范式**

数据表中是否存在非主属性对码的部分函数依赖。若存在，则数据表最高只符合一范式，若不存在，则符合二范式。
步骤;

1. 找出数据表中所有的码（id,课名）;
2. 根据第一步所得到的码，找出所有的主属性。id和课名
3. 数据表中，除去所有的主属性，剩下的就是非主属性。
4. 查看是否存在非主属性对码的部分函数依赖。
   例子：![image-20211210161736378](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211210161736378.png)
   存在问题：

5. 数据沉余：***解决***
6. 插入异常：如果我新建一个计算机系，系主任是小张，学生还没入学，那么id，姓名，课名等字段无法设置
7. 删除异常：假如小明毕业，删除小明的信息，那么小明所在系也会被删除。
8. 修改异常：如果小明转专业，那么我得把小明的系名和系主任都改了，并且得多次修改，因为小明出现了三次。***解决***

**第三范式**

在二范式的基础上，消除了非主属性对码的传递函数依赖。

![image-20211210161832266](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211210161832266.png)

传递函数依赖：y依赖于x，z又依赖于y，那么z依赖于x。如：系别依赖于学号，系主任依赖于系别，那么系主任也依赖于学号。
例子：

![image-20211210161800979](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211210161800979.png)



问题：

1. 插入异常：如果我新建一个计算机系，系主任是小张，学生还没入学，那么id，姓名，课名等字段无法设置 ***解决***
2. 删除异常：假如小明毕业，删除小明的信息，那么小明所在系也会被删除。 ***解决***

### 2. **MySQL** 支持哪些存储引擎?

![image-20221110095230795](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221110095230795.png)

MySQL 支持多种存储引擎,比如 InnoDB,MyISAM,Memory,Archive 等等.在大多数的情况下,直接选择使用 InnoDB 引擎都是最合适的,InnoDB 也是 MySQL 的默认存储引擎。

MyISAM 和 InnoDB 的区别有哪些：

1. InnoDB 支持事务，MyISAM 不支持
2. InnoDB 支持外键，而 MyISAM 不支持
3. InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；
4. MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。
5. Innodb 不支持全文索引（5.6之后支持了），而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；
6. InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。
7. MyISAM 采用表级锁(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

### 3. 超键、候选键、主键、外键分别是什么？

超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。

候选键：没有冗余元素的超键。

主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键不能为空值（Null）。

外键：在一个表中存在的另一个表的主键称此表的外键。

**栗子：**

学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）

超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！

候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！

主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了！

外键：宿舍号就是学生信息表的外键

### 4. SQL 约束有哪几种？

NOT NULL: 用于控制字段的内容一定不能为空（NULL）。

UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。

PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。

FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。

CHECK: 用于控制字段的值范围。

default：默认值

[mystudy/Mysql/基础/1. Mysql的基本使用.md · Zhang-HaoQi/Knowledge - 码云 - 开源中国 (gitee.com)](https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/Mysql/基础/1. Mysql的基本使用.md#6-mysql约束)

### 5. MySQL 中的 varchar 和 char 有什么区别？

char 是一个定长字段,假如申请了 char(10) 的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说**申请的只是最大长度,占用的空间为实际字符长度+1**,最后一个字符存储使用了多长的空间.如：存储Java，则使用4个字符，实际使用了五个字符，最后一个字符存储的是4，即实际内容占用的空间大小。

在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码,则应该使用 char。

[关于MySQL中的char与varchar的区别 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1866370)

### 6. MySQL中 in 和 exists 区别

MySQL中的in语句是把外表和内表作hash 连接，就是先将子查询条件的记录全都查出来，假设结果集为B，共有m条记录，然后再将子查询条件的结果集分解成m个，再进行m次查询。

exists语句是对外表作loop循环，每次loop循环再对内表进行查询。

如果查询的两个表大小相当，那么用in和exists差别不大。

如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。(外小里大用exists，外大里小用in)

not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。

[(136条消息) MySQL中In与Exists的区别_lzcWHUT的博客-CSDN博客_mysql中in和exists的区别](https://blog.csdn.net/jinjiniao1/article/details/92666614)

### 7. drop、delete与truncate的区别

![image-20221101161234901](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101161234901.png)

### 8. 什么是存储过程？有哪些优缺点？

存储过程是一些预编译的 SQL 语句。

1、更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 TSQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。

2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量 T-SQL 语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全

[存储过程的优缺点 - 章为忠 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhangweizhong/p/3871785.html#:~:text=可以说被存储过程伤的很深啊，所以今天就来总结下存储过程的优缺点。 1. 运行速度：对于很简单的sql，存储过程没有什么优势。 对于复杂的业务逻辑，因为在存储过程创建的时候，数据库已经对其进行了一次解析和优化。,存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接调用，所以执行速度会比普通s ql 快。 2.)

### **9. MySQL** 执行查询的过程

[一条查询sql的执行过程)](https://funnylog.gitee.io/mysql45/01讲基础架构：一条SQL查询语句是如何执行的.html)

1. 客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配

2. 查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）
3. 语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。

4. 优化。是否使用索引，生成执行计划。

5. 交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。

![image-20221101161703495](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101161703495.png)

更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。

执行器执行过程：

1. 根据执行计划判断是否走索引，如果是主键为搜索条件，则在页目录上使用二分法快速定位到对应的槽，然后遍历槽对应分组中的记录，即可快速定位到记录。
2. 如果使用未走索引的条件，那么从Infimum记录开始，依次向单链表遍历每条记录，判断是否符合条件。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

### 10. MySQL 执行更新的过程

```sql
update T set c=c+1 where ID=2;
```

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。

![image-20221101202948374](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101202948374.png)

将redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。

### 11. Mysql日志

#### redo log

个人描述：

redolog是一个用于Mysql持久化以及提高Mysql性能的一个日志。当数据库执行更新操作时，执行器将要更新的记录加载进内存后，在内存中完成更新，此时并不会将更新的内容立即写入磁盘，而是先写入BufferPool的一个缓冲区，里面记录的修改的记录列信息，记录所在页等信息，等到合适的时间点，再将更新内容刷新到磁盘中。因为在内存中，因此如果出现数据库宕机，可能造成缓冲区数据丢失，因此引入了redolog做BufferPoll数据的持久化。BufferPoll中的数据并不会立即写入redolog中，而是先写入redologbuffer中，redologbuffer中的数据根据不同策略将数据持久化到redolog日志中。策略有Mysql关闭，后台线程每隔1s刷一次，超过redologbuffer空间一半刷新，事务提交时，通过配置innodb_flush_log_at_trx_commit 来决定是否刷盘。0：表示事务提交，不立即刷盘。1：表示事务提交，写入磁盘。2：表示事务提交，数据写入操作系统内存，但并不刷新到磁盘中。因为redo写入数据到磁盘，是顺序写，因此效率较高，而更新的记录刷新到磁盘，是随机写，有一个查找过程，比较耗时。另外，Mysql是以页为单位来操作记录的，修改一条记录，可能改的信息只有只bit，但是一个页16k，更新一条数据就将整个页的数据写入，比较浪费性能。

深入原理：[(152条消息) redo log —— MySQL宕机时数据不丢失的原理_天堂2013的博客-CSDN博客_如果刷完buffer但是写redolog宕机了会怎么样](https://blog.csdn.net/qq_34436819/article/details/105664256)

当有一条记录需要更新的时候，InnoDB引擎并不会直接把数据更新到磁盘中，而是先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写。

![image-20221101201644583](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101201644583.png)

write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。**如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。（即将日志中的文件写入磁盘中）**

有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

#### binlog

MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。

redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。

binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
- 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。
- 实际操作：[(166条消息) Myql数据备份_See you !的博客-CSDN博客](https://blog.csdn.net/zhang19903848257/article/details/124873057?spm=1001.2014.3001.5501)

注意：Binlog有三种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。mixed： 混合模式，根据语句来选用是 statement 还是 row 模式。

#### redo log和binlog二者区别

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

#### SQL更新流程

```sql
update T set c=c+1 where ID=2;
```

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。

![image-20221101202948374](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101202948374.png)

**将redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。**

#### 为什么日志需要“两阶段提交”

由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。

```sql
update T set c=c+1 where ID=2;
```

![image-20221101205120627](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101205120627.png)

不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。

简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

## 索引

### 1. 什么是索引

Mysql索引是一种数据结构，以文件的形式存储，类似目录，可以大大提高Mysql的检索速度，索引的实现有B树和B+树。

### 2. 索引的优缺点

优点：

1. 大大提高Mysql的检索速度
2. 通过使用索引，在查询过程中，使用优化隐藏器，提高系统性能。

缺点：

1. 时间方面：创建索引和维护索引要耗费时间，对表中数据进行增删改时，索引也要动态维护，降低增删改的执行效率。
2. 空间方面：占用物理内存

### 3. MySQL有哪几种索引类型？

1. 存储结构上：BTree，B+Tree，Hash索引，full-index全文索引，R-Tree索引
2. 应用层次：（除了主键索引，其余都是二级索引）
   1. 主键索引：设置为主键后数据库会自动建立索引，innodb为聚簇索引，主键所有列的值不能为null
   2. 唯一索引：索引列的值必须唯一，但允许有空值。
   3. 普通索引：一个索引只有一个列，一张表可以包含多个单列索引，查询时如果使用多个索引，会进行索引合并。
   4. 复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
      1. 索引合并：使用多个索引完成一次查询的执行方法
   5. 全文索引（5.7之前，只能用于MYISAM引擎）（很少用到）
      1. 全文索引类型为FULL TEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值或者空值。全文索引可以在CHAR，VARCHAR，TEXT类型列上创建。MYSQL只有MYISAM存储引擎支持全文索引。
      2. 在MySQL 5.6版本以前,只有MyISAM存储引擎支持全文引擎.在5.6版本中,InnoDB加入了对全文索引的支持,但是不支持中文全文索引.在5.7.6版本,MySQL内置了ngram全文解析器,用来支持亚洲语种的分词

### 4. 索引的底层实现

1. Hash索引:基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。数据没有顺序，IO复杂度高

   ![image-20221031180855594](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031180855594.png)

2. B-Tree索引:B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。

   数据都保存在非叶子节点，数据量大时，树的高度高，IO操作变多，性能变低

   ![image-20221031181511690](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031181511690.png)

3. B+树索引:数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

   记录与记录之间是单向链表，数据页与数据页之间是双向链表。

   ![image-20221031184903551](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031184903551.png)

### 5. 为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？

1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 IO读写次数就降低 了。

2. 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以**B+树更加适合在 区间查询 的情况**，所以通常B+树用于数据库索引。

**B-tree：**因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；

**Hash：**虽然可以快速定位，但是没有顺序，IO复杂度高。如果有大量重复键值，会产生Hash碰撞，效率变低。适合等值查询，不适合范围查询。

**二叉树：**树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

**红黑树：**树的高度随着数据量增加而增加，IO代价高。

### 6. 聚簇索引与非聚簇索引

##### 聚簇索引

1. 聚集索引：**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**

   在 MySQL 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，**对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。**

   **优点：**

   1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。
   
   2.聚簇索引对于主键的排序查找和范围查找速度非常快。
   
   3.查找数据时，以页的形式返回，如果下次再查找，如果页中有，就可以立即返回。
   
   **缺点：**
   
   1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。
   
   2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
   
   3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。
   
   ![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031184903551.png)

聚簇索引注意事项

```text
问题：聚簇索引需要注意什么?

1.当使用主键为聚簇索引时，主键最好不要使用uid，因为uuid的值太过离散，不适合排序且可能出线新抓增加记录的uid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。

2.建议使用int类型的自增，方便排序并且默认会在索引树的末尾增加主键值，对索引树的结构影响最小。而且，键值占用的存储空间越大，辅的索引中保存的主键值
也会跟着变大，占用存储空间,也会影响到Io操作读取到的数据量。
```

##### 非聚簇索引

非聚集索引：**非聚集索引即索引结构和数据分开存放的索引。**

**二级索引属于非聚集索引。**

非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

![image-20221031175317334](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031175317334.png)

![image-20221031180106827](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031180106827.png)

##### 二者区别

1. 聚簇索引的非叶子节点存储的是主键索引，叶子节点存储数据。非聚簇索引的所有节点存储的都是主键索引，查找数据时，先在非聚簇索引中查询主键，再根据主键去聚簇索引中查找。

2. 对于InnoDB来说，非聚集索引查找数据时，还需要去聚集索引中查找，这个再根据聚集索引查找数据的过程称为回表。

   第一次索引一般是顺序IO，获取主键key，回表操作是随机IO。回表次数越多，IO次数越多，越接近全表扫描。

注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。

##### 非聚簇索引查询一定回表吗

不一定，如果查询的字段刚好是索引字段，那么就不会进行回表操作。

如Select age from users where age = 35;这个索引的 key 本身就是 age，查到对应的 age直接返回就行了，无需回表查询。

### 7. 联合索引是什么，为什么需要注意联合索引中的顺序

联合索引：使用多个字段建立一个索引，联合索引中，如果想命中索引**，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引**。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，**一般情况下，将查询需求频繁或者字段选择性高的列放在前面。**此外可以根据特例的查询或者表结构进行单独的调整。

### 8. Mysql的最左前缀

最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

### 9. 覆盖索引

利用索引查询字段时，如果所需的字段二级索引表上已有，不需要再进行回表获取数据，已经满足了我们的查询需求，即索引覆盖。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

案例：

![image-20221101103753756](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101103753756.png)

```sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

实战：

如果业务中，需求根据人的身份证号查询name，那么我们就可以将二者建立一个联合索引，查询时可以减少回表操作，提高效率。但是，添加索引是否真正的起到优化作用，还需要进行测试，因为索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

### 10. 前缀索引

索引的字段非常长，占内存空间，不利于维护。前缀索引即把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。

注意：选择字段数据长度时，要尽量保证数据的前几个字符的重复的概率比较小，如果字段前几个字符的重复率比较大，索引值重复率就比较高，查询效率比较低。

![image-20221101093236832](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101093236832.png)

[什么是前缀索引、为什么要用前缀使用、用在什么场景下？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/400901940)

### 11. 索引下推

MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch =‘index_condition_pushdown=off’;可以将其关闭。

有了索引下推优化，可以在减少回表次数在InnoDB中只针对二级索引有效，仅在Select语句中有效。

tuser表中有两个复合索引 （name，age）

```java
select * from tuser where name like '张%' and age=10;
```

1. 无索引下推： like后的索引失效，因此 name like '张%'即返回二级索引数据到mysql服务端，mysql服务端拿着二级索引数据id进行回表操作获取完整的数据，之后判断age是否=10。
2. 索引下推：like后的索引失效，因此 name like '张%'即返回二级索引数据，从二级索引数据中判断age是否=10（因为name和age是联合索引，所以二级索引数据就包含了name和age属性），之后再进行回表操作，这样可以大大减少回表次数

[五分钟搞懂MySQL索引下推 - 掘金 (juejin.cn)](https://juejin.cn/post/7005794550862053412)

### 12. 怎么查看**MySQL**语句有没有用到索引？

![image-20221101095353030](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101095353030.png)

1. id：在⼀个⼤的查询语句中每个**SELECT**关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = 'egon1');第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。

2. select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。

3. table：每个查询对应的表名 。

4. partitiONs：分区https://www.jianshu.com/p/b17b62057499

5. type： type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。

   通常来说, 不同的 type 类型的性能关系如下:

   ALL < index < range < index_merge < ref < eq_ref < const < system

   ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.

   index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.

   **一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。**

5. possible_key：查询中可能用到的索引*(*可以把用不到的删掉，降低优化器的优化时间*)* 。
6. **key：此字段是 MySQL 在当前查询时所真正使用到的索引。**如果没有选择索引，键是NULL
7. filtered：查询器预测满足下一次查询条件的百分比 。
8. rows：MySQL 查询优化器根据统计信息, 显示**MySQL认为它执行查询时必须检查的行数**。这个值非常直观显示 SQL 的效率好坏, 原则上 **rows 越少越好。**
9. extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。

### **13.** 为什么官方建议使用自增长主键作为索引？

主键自增，插入过程减少也分裂。每次插入到最后，减少数据的移动。

自增，插入数据是按照顺序，不需要mysql再在索引树上排序。

聚簇索引数据的物理存放顺序与索引顺序是一致的，即:只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

索引合并时，排好序的数据取交集比无序集合取交集容易，提升查询效率。

id有序排列时，根据id值进行回表操作时不再是进行单纯的随机IO，因为这些值是有序的，能提高效率。

### 14. 创建索引的方式

1. **查看索引**：SHOW INDEX FROM 表名

2. **创建索引 **

   1. **主键索引**

      ```sql
      # 创建表时创建
      CREATE TABLE t_user (id VARCHAR(20) PRIMARY KEY ,NAME VARCHAR(20))
      ```

   2. **单值索引**

      ```sql
      # 1.建表时创建   不能为索引起名
      CREATE TABLE t_user2(id VARCHAR(20) PRIMARY KEY,NAME VARCHAR(20),KEY(NAME),KEY(...))
      # 2.建表之后创建
      CREATE INDEX name_index ON t_user(NAME)
      ```

   3. **唯一索引**

      ```sql
      # 1.建表时创建   不能为索引起名
      CREATE TABLE t_user3(id VARCHAR(20) PRIMARY KEY,NAME VARCHAR(20),age INT(10),UNIQUE(age))
      
      # 2.建表之后创建
      CREATE UNIQUE INDEX name_index ON t_user3(NAME)
      ```

   4. **复合索引**

      ```sql
      # 1.建表时创建   不能为索引起名
      CREATE TABLE t_user4(id VARCHAR(20) PRIMARY KEY,NAME VARCHAR(20),age INT(10),KEY(NAME,age))
       # 2.建表之后创建
      CREATE INDEX name_age_index ON t_user4(NAME,age)
      ```

   还可以使用ALTER TABLE table_name ADD INDEX index_name (column_list);的形式

3. **删除索引：**DROP INDEX name_index ON t_user

### 15. 创建索引时需要注意什么？

1. 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
2. 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
3. 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。

### 16. 建立索引的原则

1、**最左前缀匹配原则**，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3、**尽量选择区分度高的列作为索引**，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4、**索引列不能参与计算**，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5、**尽量的扩展索引，不要新建索引**。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

**6、索引字段越小越好**

### **17.** 使用索引查询一定能提高查询的性能吗？

通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:

1. 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。
2. 基于非唯一性索引的检索。

### 18. 不走索引的情况

[(217条消息) Mysql索引在什么情况下会失效？_Anna_luo的博客-CSDN博客_sql索引失效有哪些情况会失效](https://blog.csdn.net/Anna_luo/article/details/123526416#:~:text=1、字段类型不匹配导致的索引失效 进行 SQL,数据查询的时候，where 条件字段类型与实际表中字段类型不匹配的时候，Mysql 会进行隐式的数据类型转换，而类型转换会使用到内置函数，导致在进行数据查询的时候并没有使用索引。)

1. 使用!= 或者 <> 导致索引失效

2. 类型不一致导致的索引失效

3. 函数导致的索引失效

   ```java
   SELECT * FROM `user` WHERE DATE(create_time) = '2020-09-03';
   如果使用函数在索引列，这是不走索引的。
   ```

4. 运算符导致的索引失效

   ```java
   SELECT * FROM `user` WHERE age - 1 = 20;
   ```

   如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。

5. OR引起的索引失效

   OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，OR两侧字段都加索引，则不会失效，有一侧没加则失效。

   OR失效详解：[(217条消息) mysql条件查询出现or连接时会使用索引的场景_你坤神哟的博客-CSDN博客_mysql or查询使用索引](https://blog.csdn.net/qq_41941605/article/details/121926332?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-121926332-blog-89472136.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-121926332-blog-89472136.pc_relevant_recovery_v2&utm_relevant_index=14)

6. 模糊搜索导致的索引失效

   当 % 放在匹配字段前是不走索引的，放在后面才会走索引。

7. NOT IN、NOT EXISTS导致索引失效

### 19. 索引合并

![image-20221031114943720](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031114943720.png)



使用多个索引完成一次查询的执行方法。

索引合并的方法：

1. **Intersection索引合并**

   1. 分析：

      1. Select * From single_table where key1='a' and key2 = 'b'

      2. 搜索方式：

         1. 全表扫描：使用key1索引查到范围在[a,a]之间的数据id，对于获取的每条二级索引记录（已按照主键排好序），**进行回表操作**获取完整的记录，筛选出记录中key2=b的记录
         2. Intersection索引合并：同时使用key1和key2进行查询，取二者查询结果即二级索引记录的交集（各自二级索引记录已按照主键排好序），**进行回表**操作，获取完整的记录。

         intersection索引合并的索引记录要比全表扫描少的多，因此需要回表的数据少，剩下很多回表操作带来的开销。方式二就是Intersection索引合并。

   2. 条件：二级索引的索引记录值，必须按照主键已经排好序

   3. 为什么要索引记录已排好序？

      1. 有序集合取交集比无序集合取交集容易
      2. id有序排列时，根据id值进行回表操作时不再是进行单纯的随机IO，因为这些值是有序的，能提高效率。

   4. 索引合并失效

      1. 使用二级索引执行查询时，如果从对应的扫描区间读取出的记录不是按照主键排序的，则不能使用Intersection

         1. Select * From single_table where key1> 'a' and key2 = 'b'

            key1的扫描区间是（‘a’，+oo），获取的记录不是按照主键值索引，不能使用intersection索引。

         2. Select * From single_table where key1> 'a' and key_part1= 'a'

            二级索引记录是先按照key_part1列的值进行排序，在key_part1值相等的情况下，在通过key_part2进行排序，之后再根据key_part3进行排序，因为key_part1是一个复合索引，所以形成的二级索引记录不是排序的，不能使用intersection索引。

   5. 聚簇索引和二级索引（可以走索引合并）

      1. Select * From single_table where key1= 'a' and id>9000

         key1获取的二级索引记录是排好序的，但是在sql语句执行时，并不会生成id>9000的主键并与key1生成的二级索引取交集，因为聚簇索引本身就是排好序的，获取key1=‘a’的索引记录后，沿着链表往后判断记录的id值是否>9000即可，符合则进行回表取记录即可。整个过程中不需要取id>9000区间的数据。

2. **Union索引合并**

   1. 分析：
      1. Select * From single_table where key1= 'a' or key3='b'
      2. 搜索方式：
         1. 直接使用or，不走索引，扫描区间是（-00，+00）
         2. **Union合并**：key1的扫描区间['a','a'],key3的扫描区间['b','b'],获取二者的二级索引记录后，通过二级索引id进行去重，去重后进行回表操作。
   2. 条件：二级索引的索引记录值，必须按照主键已经排好序，原因同上。
   3. 其他情况和Intersection索引情况一致。

3. Sort-Union索引合并

   1. 分析：

      1. Select * From single_table where key1< 'a' or key3> 'b'

         因为key1和key3生成的区间分别是（-00，a），（b,+00），生成的二级索引记录的主键是不排序的，**所以不能走Union索引合并**

         如果将二者生成的区间的索引记录按照主键排序后，**就可以走Union索引合并了**，这就是Union索引合并

      2. 主要就是解决Union索引合并条件太苛刻的问题（二级索引记录主键必须排序）

   2. 为什么没有Intersection-sort？
      1.  Sort-Union针对场景是单独根据搜索条件从某个二级索引记录中获取记录较少，对于Sort-Union相对来说，单个条件生成的二级索引记录较少，通过排序能够增加性能。
      2. Intersection是针对场景是单独根据搜索条件从某个二级索引记录中获取记录较多，对于Intersection来说，单个条件生成的二级索引记录较多，需要为大量的二级索引记录按照主键值进行排序，这个成本可能比使用单个二级索引执行查询的成本更高。



1. Union索引合并
2. Sort-Union索引合并

### 20. 索引数据页

mysql的记录存储在数据页中，一个数据页能存储多条数据。

记录与记录之间，是一个单向链表，即上一条记录存储这下一条记录的位置。

数据页之间是一个双向链表，里面存放着本数据页和下一数据页的页号。

![image-20221031185505947](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031185505947.png)

![image-20221031185815877](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221031185815877.png)

### 21. 索引优化方式（不完善）

1. 索引合并
2. 索引下推
3. 覆盖索引
4. 最左前缀原则

## 事务

### 1. 什么是事务

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

Mysql是一个客户端/服端软件，服务器可以处理来自多个客户端的多个事务。   

事务就是保证转账/收款这两个关键操作要么都成功，要么都要失败。

个人回答：

Mysql事务是一组操作，是数据库并发控制的基本单位。有原子性，一致性，隔离性，持久性个特征，以转账操作为例，A向B进行转账，A减金额，B加金额，这期间涉及多个操作，这些操作要么全成功，要么全失败，这样就保证了原子性，转账前后，两者的金额都是对应的，A减去的和B增加的一致，这是一致性；在A向B转账期间，如果有其它事务也进行操作，事务与事务之间通过事务隔离机制隔离，一个事务的执行不应影响其他事务的执行，这是隔离性；事务提交后，AB更改的金额信息是持久化到数据库磁盘的，这是持久性。

### 2. **事务具有的四个特征**

- 原子性( `Atomicity`)：事务的所有操作要么全部成功，要么全部回滚。
- 一致性( `Consistency`)：总是从一个一致性的状态转换到另一个一致性的状态。当事务运行过程中出现问题，但部分数据已写入数据库，此时数据库就是一种不正确，不一致状态。
- 隔离性( `Isolation`)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行
- 持久性( `Durability`)：已被提交的事务对数据库的修改应该永久保存在数据库中。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

### 3. 事务的隔离级别

某条记录：age=18

1.  读未提交：事务AB同时运行，事务B先修改了该记录age=19，但是并没有提交，事务A此时读取了这条记录，A读取的是B已修改的数据age=19，如果B在之后的事务中执行过失败，那么A就读取到了脏数据。
2.  读已提交：事务AB同时运行，事务B先修改了某条记录age=19，此时A进行数据读取，并不能读到B修改的值，只有B事务提交后，才能读取到B修改的值age=19。
3.  可重复读：mysql默认隔离级别。事务AB同时运行，事务B修改了age=19，并且提交事务。此时A进行读取，A读取的age=18。因为进事务时，age=18，此隔离级别保证记录在进入事务时数据的值，和在事务结束前读取的值一样。
4.  串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。。

**并发下事务带来的问题**

脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

不可重复读(Non-repeatable read):在一个事务的两次查询之中**数据**不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

幻读(Phantom Read):**幻读是针对数据插入（INSERT）操作来说的**。假设事务A对某些行的内容作了更改，但是还未提交，此时**事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的**，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。

脏写：问题太过严重，所有事务的隔离机制都不允许。

可重复读：同一事务内，多次查询读到的数据都是一致的。

![image-20221014214413871](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221014214413871.png)

![image-20221101165507569](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101165507569.png)

- 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
- 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
- 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。

### 4. Mvcc简介

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![image-20221101212354395](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221101212354395.png)

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

回滚日志不是一直保留的，当系统里没有比这个回滚日志更早的read-view的时候，就会删除这个回滚日志。拿read-viewc来说，当他之前的read-view都没有的时候，就会进行删除。

**为什么不建议使用长事务**

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。

长事务还占用锁资源，也可能拖垮整个库

**事务的启动方式**

1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

### 5. MVCC原理剖析

#### Mvcc控制下的可重复读

参考文章：[(158条消息) 【数据库】MySQL的ReadView_thesprit的博客-CSDN博客_mysql readview](https://blog.csdn.net/thesprit/article/details/112970122)

在Mysql中，当我们对某一条记录执行更新语句时，会生成一条undo日志，这条日志中记录了当前更新的事务id以及上一条undo日志的地址（roll_pointer）,所有的事务版本通过roll_pointer形成了一条链表，称为版本链。版本链的头结点是当前记录的最新值，每个版本中都有对应的事务id。可以通过这个版本链来控制并发事务**访问（查询）**相同记录时的行为，这就是MVCC（多版本并发控制）

**ReadView**

![image-20221104141024420](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221104141024420.png)

**版本链**

![image-20221104140835638](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221104140835638.png)

**具体控制方式：**

在事务中，当执行Select语句时，会创建一个ReadView（RR是第一次Select创建，RC是每次Select创建），记录了当前事务id，当前活跃的事务id，当前活跃事务的最小id，当前活跃事务的最大id+1。查询时，会拿着ReadView中记录的事务信息，去版本链中拿undo日志查询。

查询时，会判断当前事务id和undo日志记录中最新的事务id，如果当前事务id和undo事务id相等，说明这条undo日志是在当前事务中产生的，可以读取到记录信息。当undo的事务id与当前事务id不一样时，此时会判断undo的事务id和ReadView记录的最小值，如果undo的事务id比ReadView记录的最小值小，说明这条undo日志是在当前事务开始前提交的，可以读取这条事务信息，如果undo的事务id比ReadView记录的最大值+1大，说明这条事务是当前事务之后开启的，不能读取，就读取rollpointer指向的undo日志信息再进行判断。如果undo的事务id在ReadView记录的最大与最小的范围内，则判断ReadView有没有记录这个事务id，如果记录，说明当前事务开启时，undo事务还没有结束，不能读取。如果没有记录，说明当前ReadView创建时，那个事务已经提交了，可以读取到。

#### 当前读

Mvcc仅限于读操作，写操作另外。

在并发事务中，遇到并发写的操作时，读取数据时，使用的是当前读。

![image-20221104142027964](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221104142027964.png)

初始Id为1。最后结果是A：1 B：3

分析：start  transaction  with consistent  snapshot 表示事务开始时，就创建ReadView。

如果按照可重复读的隔离级别下，如果按照读的方式来分析上述流程，那么结果因为A：1，B：2。但是这样产生过的问题是，事务C操作的值被覆盖掉了，因为此时事务C已经提交。如果是状态操作的话，事务C添加了500元，事务B添加了300元，但是事务B是之后提交的，此时数据库最新的值是300元，产生了严重的属于性一直问题。

因此，在事务更新过程中，使用的是“当前读”，update t set k  = k+1 ,在这里读到的k，是事务C修改过的K，即2，在2的基础上加了1，因此事务B中k的查询结果是3。

select语句如果加锁，也是当前读。

```java
select k from t where id=1 lock in share mode;
 select k from t where id=1 for update;
```

如果事务C不是马上提交

![image-20221104203008137](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221104203008137.png)

这种情况下，此时C进行了更新操作，但是C并没有提交事务，事务B要进行更新，但是此时B是更新不了的，因为两个事务操纵的是同一条数据，当前这条数据加了行锁，并且锁被事务C占有，且事务C只有提交事务后，才会释放锁（两阶段锁协议），因此，事务C提交后，事务B才能执行更新操作，获取到K的值还是3.

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

事务B在等待过程中，有可能出现锁超时，关于锁超时：[mystudy/Mysql/进阶/锁.md · Zhang-HaoQi/Knowledge - 码云 - 开源中国 (gitee.com)](https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/Mysql/进阶/锁.md#死锁)

```sql
update user set age=11 where name=张三  //name没有添加索引
```

我们上述的更新操作，使用的是在索引上的记录，Mysql可以直接定位到这条记录并加上行锁，如果记录没有添加索引，那么更新的时候，Mysql会为这张表所有的行加锁（是表所有的行，并不是添加表锁），加上锁之后，Mysql会进行一遍过滤，把不符合要求的锁给取消掉。虽然最终是给真正要操作的记录添加了锁，但是为所有记录添加锁再判断取消这个过程对性能也是影响很大的，因此，如果是大表，要合理设计索引，否则很难保证并发度。

#### 在可重复读下是如何解决幻读的

**「MySQL在可重复读隔离级别下可以通过MVCC和加锁来解决幻读问题」**

可重复读的隔离级别下，是有可能产生幻读的，但是Mysql为我们提供了间隙锁，完美解决了幻读。

表结构

```sql
id name  age //age是索引列
```

此时，在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。

![image-20221104232531711](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221104232531711.png)

如图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁的。加锁过程

![image-20221104232621989](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221104232621989.png)

在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。当事务A执行`update user set name='风筝2号’ where age = 10;` 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。不仅插入 age = 10 的记录需要等待事务A提交，age<10、10<age<30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。

**这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。**

读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。

读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。

### 6. 事务的实现原理

事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。

每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。

每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。

隔离性是通过read_view和undo log以及锁实现的。

### 7. Mysql的事务日志

innodb 事务日志包括 **redo log 和 undo log。**

undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。

redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。

事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。

redo log 是在事务提交前写入日志文件的，（两阶段提交，第一阶段是redo，第二阶段是binlog），防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。

undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在MySQL innodb 存储引擎中用来实现多版本并发控制。

**个人理解：Mysql的三种日志**

在Mysql数据库中，常用的日志有三种，redo log ， undo log ，binlog。其中redo 和 undo 这两种日志是Innob存储引擎特有的，binlog是mysql服务层的，所有存储引擎都有。

redo日志主要记录数据更新后，最新的一个数据状态，以日志的形式保存，防止数据库在更新过程中意外宕机，造成数据未持久化到磁盘上，此时可以通过redo恢复。

undo日志主要记录在事务开始前或操作前，原记录的一个状态，undo日志包含事务id和roll_pointerl两个重要字段，一个记录当前事务id，一个记录上一条undo日志的地址。主要用于快照读以及事务的回滚。

binlog是记录对数据库的所有增删改操作，通过binlog可以使数据库恢复任何一个时间点，主要做数据备份。

mysql有一个两阶段提交，redo日志记录后，记录binlog日志，两者记录完成后，才提交事务，保证事务的持久性。

###  9. 事务中可以混合使用存储引擎吗

尽量不要在同一个事务中使用多种存储引擎，MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。

如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表）,在正常提交的情况下不会有什么问题。

但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。

### 10. Mysql的隔离级别为什么使用RR，实战中如何选择隔离级别

Mysql在5.0之前，Binlog日志只支持statement一种格式，在读已提交的隔离级别下，主从复制的时候会出现数据不一致问题。

**问题：**

事务A，事务B同时运行，事务A删除了age小于10的数据，事务B添加了一部分age小于10的数据，事务B先提交，事务A后提交。binlog记录先记录事务提交的，即先记录了事务B，在记录了事务A，这样通过binlog恢复数据的时候，先执行事务B的语句，再执行事务A的语句，恢复的数据中，事务B新增的语句被事务A的语句删除了。

**解决方案：**

1. 隔离级别为可重复读，利用删除的间隙锁，事务A删除数据期间事务B不能添加数据。
2. 方式二：使用row，基于行的复制格式的binlog（5.1之后版本才有）

综合以上原因，Mysql选择的默认隔离级别是可重复读。

**为什么其他数据库使用读已提交：**

1. repeatable存在间隙锁会使死锁的概率增大；在可重复读隔离级别下，条件列未命中索引会锁表！而在已提交读隔离级别下，只锁行
2. 在已提交读隔离级别下，引入了半一致性读(semi-consistent)特性增加了update操作的并发性能。更重要的是不可重复读问题在开发中是可以接收的，毕竟你数据都已经提交了，读出来本身就没有太大问题

参考下面两篇文章

[(148条消息) Mysql默认隔离级别为什么是可重复读？_余生之君的博客-CSDN博客_mysql的默认事务为啥是可重复读](https://blog.csdn.net/java_collect/article/details/105042975)

[技术分享 | 什么是半一致性读？ - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1651628)

### 11. 半一性读

夹在一致性读和锁定读之间的读取方式。当隔离级别不大于RC且执行UPDATE语句时将使用到半一致性读。

UPDATE读取到加了X锁的记录时，会将该记录的最新提交版本的数据读取出来，判断和UPDATE的搜索条件是否匹配，如果不匹配，不对记录加锁，跳到下一跳记录，如果匹配，则再次读取该记录并对其进行加锁。目的为了让UPDATE语句尽量不被别的语句阻塞。

![image-20221109115647745](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221109115647745.png)

```sql
T1:SELECT * FROM hero WHERE number= 8 FOR UPDATE;
为记录为8的记录添加X锁。
T2:UPDATE hero SET name 'cao曹操 ' WHERE number >= 8 AND number < 20 AND country != '魏';
```

原则上：T1已经获取了X锁，T2再次获取应该获取不到。

半一执行读：存储引擎会先获取 number 值为 的聚簇索引记录最新提交的版本并返回给server层.该版本的 country 值为'魏 很显然不符合 country != 条件 所以 server 层决定放弃获取 number 值为8的聚簇索引记录上的X型正经记录锁 转而让存储引擎读取下一条记录。

## 锁

### 1. 为什么要加锁

当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

数据库的并发策略：

并发控制主要有乐观锁（下3），悲观锁（下2），以及时间戳实现。

时间戳：每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存



### 2. 数据库的锁有哪些？

[mystudy/Mysql/进阶/锁.md · Zhang-HaoQi/Knowledge - 码云 - 开源中国 (gitee.com)](https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/Mysql/进阶/锁.md#全局锁)

大体分为：

1. 全级锁

2. 表级锁

3. 行级锁

4. 页级索

   页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级 冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁

### 3. 数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏 事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

悲观锁：事务在操作数据的时候，对操作的数据加锁，不允许其他的事务获取锁，事务提交后才释放锁，允许其他事务操作数据。实现方式：使用数据库中的锁机制。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。

乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

### 4. InnoDB引擎的行锁是怎么是实现的

InnoDB是基于索引来完成行锁例: 

```sql 
共享锁：SELECT ... LOCK IN SHARE MODE;
排它锁：select * from tab_with_index where id = 1 for update; 
```

for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将 完成表锁，锁表后会再进行一次筛选，将不符合条件的记录锁给释放掉。

### 5. 什么是死锁，如何解决

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

解决死锁的策略：

Mysql策略

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。（在InnoDB中，innodb_lock_wait_timeout的默认值是50s）
  - 设置过长，业务不允许。设置过短，可能造成非死锁的业务提前结束。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。
  - 默认开启，常用。
  - 会产生额外负担，即循环等待。当一个事务被锁的时候，要去看它所依赖的线程有没有被别人锁住，如此循环。
  - 成本高，如果峰值很大，大部分事务都需要回滚，影响性能。

程序策略：

1. 对并发量比较大的业务，使用队列削峰，或者使用分布式锁。

2. 将并发操作的一条记录均分到十条记录上

   影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。但是设计的逻辑可能更复杂一些。

### 6. 隔离级别与锁的关系

**普通Select语句**

不同隔离级别下，情况不同

1. 读未提交：不加锁，每次直接读取最新版本。有脏读，不可重复读，幻读现象。
2. 读已提交：不加锁，每次读之前生成一个ReadView。避免脏读，有不可重复读，欢度现象。
3. 可重复读：加锁间隙锁，第一次Select生成一个ReadView，把脏读，不可重复读，幻读都避免了。
   1. MVCC不能避免幻读的原因：
      1. 事务1执行查询，where number=30，没有数据，未提交事务。
      2. 事务2执行插入语句，number=30，并提交事务。
      3. 事务1更新number=30的语句，此时可以更新成功（事务2已经提交，改动并不会阻塞），此时事务1再去查num=30就可以查到了。
      4. 因此，MVCC并不能完全禁止幻读，可重复读隔离级别下只是很大程度避免了可重复读，但不是完全避免。
4. SERIALIZABLE:
   1. autocommit=0（手动提交），普通的Select语句会编程Select..LOCK IN SHARE MODE
   2. autocommit=0（自动提交），普通Select语句不会加锁，利用MVCC生成一个ReadView读取记录，自动提交只有一条记录，不会出现可重复读，幻读现象。

**锁定度语句**

参照Mysql是怎样运行的。

### 7. 锁优化建议

1. 使用较低的隔离级别（能用读已提交，不用可重复读）
2. 设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突
3. 选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。例如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时再申请排他锁，这样会导致死锁。
4. 不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。
5. 尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响
6. 不要申请超过实际需要的锁级别
7. 数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别
8. 对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。

### 8. 封锁协议

封锁协议 [Mysql为何使用可重复读(Repeatable read)为默认隔离级别? - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/379961203)

## 分库分表

推荐文章：[关于分库分表最全的一篇文章 - 老皮肉 - 博客园 (cnblogs.com)](https://www.cnblogs.com/sheseido/p/8880091.html#:~:text=关于分库分表最全的一篇文章 1,垂直（纵向）切分：把单一的表拆分成多个表，并分散到不同的数据库（主机）上。 2 水平（横向）切分：根据表中数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上。)

### 1. 为什么要分库分表

单表数据量太大，极大影响sql执行的性能。

**分表**

分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一 个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个 表的数据量在可控的范围内，比如每个表就固定在 200 万以内。

**分库**

一个库最多支撑到并发 2000，如果超过2000，一定要扩容了，而且一个健康的单库并发 值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候 就访问一个库好了。

![image-20221109174941876](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221109174941876.png)

### 2. 分库分表组件

sharding-jdbc

mycat

### 3. 如何对数据库如何进行垂直拆分或水平拆分的

#### 水平拆分

水平拆分：将一个表中的数据存储到多个库的多个表中，表结构一样，存储的数据不一样，以此来对抗更高的并发。博客系统中，博客表数量很大，并且访问量大，可以分为Blog1，Blog2等表。

![image-20221109175539039](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221109175539039.png)

优点：

- 单库单表的数据保持在一定的量级，有助于性能的提高。
- 切分的表的结构相同，应用层改造较少，只需要增加路由规则即可。
- 提高了系统的稳定性和负载能力。

缺点：

- 切分后，数据是分散的，很难利用数据库的Join操作，跨库Join性能较差。
- 拆分规则难以抽象。
- 分片事务的一致性难以解决。
- 数据扩容的难度和维护量极大。

**分片方式**

1. 按照Hash分片：对数据的某个字段求哈希，再除以分片总数后取模，取模后相同的数据为一个分片，这样的将数据分成多个分片的方法叫作哈希分片。
   1. 按照哈希分片常常应用于数据没有时效性的情况，比如所有数据无论是在什么时间产生的，都需要进行处理或者查询，例如支付行业的客户要求可以对至少1年以内的交易进行查询和退款，那么1年以内的所有交易数据都必须停留在交易数据库中，否则就无法查询和退款。
   2. 如果这家公司在一年内能做10亿条交易，假设每个数据库分片能够容纳5000万条数据，则至少需要20个表才能容纳10亿条交易。在路由时，我们根据交易ID进行哈希取模来找到数据属于哪个分片，因此，在设计系统时要充分考虑如何设计数据库的分库分表的路由规则。
2. 按照时间分片
   1. 按照时间的范围将数据分布到不同的分片上的，例如，我们可以将交易数据按照月进行切片，或者按照季度进行切片，由交易数据的多少来决定按照什么样的时间周期对数据进行切片。
   2. 适用于有明显时间特点的数据，例如，距离现在1个季度的数据访问频繁，距离现在两个季度的数据可能没有更新，距离现在3个季度的数据没有查询需求。
3. 二者都是常用的分片方式，也可以结合使用：对交易数据先按照季度进行切片，然后对于某一季度的数据按照主键哈希进行切片。

#### 垂直切分

垂直拆分：把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构不一样，每个库表都包含部分字段。将访问频率很高的字段放在一个表（字段较少），将访问频率很低的字段放入另外一个表（字段较多）。按照不同的业务划分比如User表、Pay表和Commodity表，将每个表切分到不同的数据库上。

![image-20221109175545417](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221109175545417.png)

优点：

1. 业务清晰，系统整合扩展容易。

2. 按照成本、应用的等级、应用的类型等将表放到不同的机器上，便于管理。

   对配置表的某些字段很少进行修改时，将其放到一个查询性能较高的数据库硬件上；对配置表的其他字段更新频繁时，则将其放到另一个更新性能较高的数据库硬件上。

3. 便于实现动静分离、冷热分离的数据库表的设计模式。

4. 数据维护简单。

缺点：

1. 无法关联查询，需要远程调用。
2. 单库性能瓶颈，不易进行数据扩展和提升性能。
3. 事务处理复杂。

**分片方式：**

1. 冷热分离
   1. 在微博系统的设计中，一个微博对象包括文章标题、作者、分类、创建时间等属性字段，这些字段的变化频率低，查询次数多，叫作冷数据。而博客的浏览量、回复数、点赞数等类似的统计信息，或者别的变化频率比较高的数据，叫作活跃数据或者热数据。
   2. 我们把冷热数据分开存放，就叫作冷热分离，在MySQL的数据库中，冷数据查询较多，更新较少，适合用MyISAM引擎，能更好地进行数据查询；而热数据更新比较频繁，适合使用InnoDB存储引擎，有更快的更新速度，这样能够有效提升性能。

## 读写分离，主从复制

### 1. 主从同步

主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。 

因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续 续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的 某个表。

### 2. 主从同步目的

1. 提高数据库性能，主服务写入，从服务读取，可以动态调整从数据库数量，提高数据库性能。
2. 提高数据安全，从服务备份而不破坏主数据库
3. 主服务器生成实时数据，从服务器分析这些数据，从而提高服务器的性能

### 3. 如何实现Mysql读写分离

基于主从复制架构，一个主库挂多个从库，写入从库，读的话使用子库。

### 4. Mysql主从复制原理

基本原理流程，是3个线程以及之间的关联
主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；
从：sql执行线程——执行relay log中的语句；

![image-20221109220823517](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221109220823517.png)

5. MySQL主从同步延时问题如何解决？

  MySQL 实际上在有两个同步机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。

  1. 半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。
  2. 并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。

## Mysql优化

### 1. 如何定位及优化SQL语句的性能问题？

explain命令 来查看语句的执行计划。对于查询语句，最重要的优化方式就是使用索引。

### 2. 大表数据查询，怎么优化

1. 优化shema、sql语句+索引；
2. 第二加缓存，memcached, redis；
3. 主从复制，读写分离；
4. 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；
5. 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding
   key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding
   key，将数据定位到限定的表上去查，而不是扫描全部的表；

### 3. 超大分页如何处理

select * from table where age > 20 limit 1000000 ,10   需要 load1000000 数据然 后基本上全部丢弃,只取 10 条当然比较慢.

优化1：select * from table where id in (select id from table where age > 20 limit 1000000,10)这样虽然也 load 了一百万的数据,但 是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快。

利用延迟关联或者子查询优化超多分页场景。MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那 当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数 进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联：

SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

优化2：使用redis缓存。

### 4. 慢查询的优化方式

**慢日志查询**
MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句为慢SQL。
由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析
使用
默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数

如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件

![image-20221109232212661](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221109232212661.png)

运行查询时间长的 sql，可以打开慢查询日志查看

慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还 是数据量太大？

优化：

1. 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
2. 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
3. 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

### 5. 如何优化查询过程中的数据访问

1. 访问数据太多导致查询性能下降
2. 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列，查询不需要的数据。解决办法：使用limit解决
3. 确认MySQL服务器是否在分析大量不必要的数据行
4. 多表关联返回全部列。解决办法：指定列名，避免使用Select *
5. 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
6. 是否在扫描额外的记录。解决办法：
   使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技
   巧去优化：
   使用索引覆盖扫描，把所有
7. 5555555555555555555555555++的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
8. 改变数据库和表的结构，修改数据表范式
9. 重写SQL语句，让优化器可以以更优的方式执行查询。

### 6. 如何优化关联查询

确定ON或者USING子句中是否有索引。（USING等价于JOIN），LEFT JOIN和Right JOIN，尽量让被参照表走索引。INNER JOIN 时，mysql 会把小结果集的表选为驱动表（小表驱动大表）

LEFT JOIN ： 左表为驱动表，右表为被驱动表。右表建立索引有效

RIGHT JOIN：左表为驱动表，右表为被驱动表。左表建立索引有效

INNER JOIN：小表为驱动表，大表为被驱动表。大表建立索引有效

 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。

### 7. 数据库结构优化

1. 将字段很多的表进行分割
2. 增加中间表，将联合查询改为中间表的查询
3. 适当增加冗余字段

### 8. 数据库CPU飙升

1. top指令查看是否是Mysql导致，确定的话找到进程ID，使用 show processlist查看跑的session情况，是不是有消耗资源的sql正在运行，找到消耗高的sql，查看执行计划，判断是否走索引或者数据量太大导致
2.  kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、 改 sql、改内存参数)之后，再重新跑这些 SQL。
3. 也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情 况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

### 9. 大表怎么优化

1. 查询带限制条件，避免直接全表查
2. 读写分离，主库写，从库读
3. 缓存：redis缓存
4. 通过分库分表的方式优化，使用垂直分表或水平分表

## 其他

### B+树

[B+树及插入和删除操作详解 (biancheng.net)](http://data.biancheng.net/view/61.html)

[图解：什么是红黑树？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/273829162)

### 开窗函数

[(238条消息) MySQL8.0开窗函数_kejiayuan的博客-CSDN博客_mysql 开窗函数](https://blog.csdn.net/kejiayuan0806/article/details/103297893#:~:text=MySQL从8.0开始支持开窗函数，这个功能在大多商业数据库如Oracle和PostgreSQL中早已支持，也叫分析函数。 它可以理解为记录集合，开窗函数也就是在满足某种条件的记录集合上执行的特殊函数。 对于每条记录都要在此窗口内执行函数，有的函数随着记录不同，窗口大小都是固定的，这种属于静态窗口；有的函数则相反，不同的记录对应着不同的窗口，这种动态变化的窗口叫滑动窗口。,开窗函数的本质还是聚合运算，只不过它更具灵活性，它对数据的每一行，都使用与该行相关的行进行计算并返回计算结果。 聚合函数是将多条记录聚合为一条；而开窗函数是每条记录都会执行，有几条记录执行完还是几条。 聚合函数也可以用于开窗函数中。)

