## volatile和CAS

多线程执行i++

[(139条消息) Volatile与CAS的底层原理_Lin~Xu的博客-CSDN博客](https://blog.csdn.net/rekingman/article/details/89464001)

[(139条消息) 可见性是什么？（通俗易懂）_叫练的博客-CSDN博客_什么是可见性问题](https://blog.csdn.net/duyabc/article/details/110946997)

volatile:

执行i++会进行指令重排，将一个操作分解为三个操作。多线程操作的时候，并不能保证原子性。因此引入了CAS。

```java
public class TestThread {

    public static void main(String[] args) throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(100);
        AtomicDemo ad = new AtomicDemo();
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + ":" + ad.getI());
                countDownLatch.countDown();
            }).start();
        }
        countDownLatch.await();
        System.out.println(ad.getIs());
    }


}

class AtomicDemo implements Runnable {
    //    private volatile   int i = 0; //volatile保证可见性
    AtomicInteger i = new AtomicInteger(0);

    @Override
    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + ":" + getI());
    }

    public int getI() {
        return i.incrementAndGet();
    }

    public int getIs() {
        return i.get();
    }
}
```

AtomicDemo底部使用了volatile和cas

[CountDownLatch的理解和使用 - Shane_Li - 博客园 (cnblogs.com)](https://www.cnblogs.com/Lee_xy_z/p/10470181.html)