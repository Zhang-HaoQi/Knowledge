# 锁

## 介绍

数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。

锁大致可以分成全局锁、表级锁和行锁三类

## 全局锁

对整个数据库实例加锁。

MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。

当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

使用场景：**做全库逻辑备份。**也就是把整库每个表都select出来存成文本。

**数据库备份**

之前做法：

通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

如果不加锁，如果两个表有关联，如第一个表是余额表，第二个表是买课表，先减余额，再添加买课记录。如果出现余额未减时备份，此时备份的信息是没有扣减的余额，接下来备份买课表，备份完成后，发现了有买课记录。

不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。

解决：在可重复读隔离级别下开启一个事务，即可拿到一个一致性视图。

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，**这个过程中数据是可以正常更新的**。

**为什么还需要FTWRL呢？**

**一致性读是好，但前提是引擎要支持这个隔离级别。**比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。**single-transaction方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。

**既然要全库只读，为什么不使用set global readonly=true的方式呢**？

readonly方式也可以让全库进入只读状态，但是有两个问题

- 一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。
- 二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。

但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。

## 表级锁

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

### **表锁**

**表锁的语法是 lock tables … read/write。**与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

### **元数据锁MDL。**

MDL不需要显式使用，在访问一个表的时候会被**自动加上**。

MDL的作用是，保证读写的正确性。**如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。**

当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

- 锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

**元数据锁可能产生的问题**

元数据锁是默认添加的，但也并不是我们就可以任意修表结构。

![image-20221103101707609](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221103101707609.png)

SessionA和SessionB运行的时候，都会添加读锁，运行到SessionC的时候，会添加写锁，因为SessionA和SessionB还没有释放锁，因此SessionC的操作，以及SeesionC之后的操作都会被阻塞，如果这一时刻，某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。此时大量请求处于阻塞状态，导致数据库负载过大甚至崩溃。

事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

**如何安全地给小表加字段？**

1. 解决长事务，事务不提交，就会一直占着MDL锁

   在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。

2. 如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，该怎么做呢

   在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

   ```sql
   ALTER TABLE tbl_name NOWAIT add column ...
   ALTER TABLE tbl_name WAIT N add column ... 
   ```

## 行级锁

MySQL的行锁是在引擎层由各个引擎自己实现的。MyISAM引擎不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。

事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。

### **两阶段锁**

![image-20221103104852875](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221103104852875.png)

事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。事务A持有的两个记录的行锁，都是在commit的时候才释放

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

**优化：**如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

举例：

1. 从顾客A账户余额中扣除电影票价；
2. 给影院B的账户余额增加这张电影票价；
3. 记录一条交易日志。

这三个操作在一个事务中进行，此时顾客B也进来购票，此时这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。

根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。

### 死锁

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

![image-20221103105837885](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221103105837885.png)

这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。（在InnoDB中，innodb_lock_wait_timeout的默认值是50s）
  - 设置过长，业务不允许。设置过短，可能造成非死锁的业务提前结束。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。
  - 默认开启，常用。
  - 会产生额外负担，即循环等待。当一个事务被锁的时候，要去看它所依赖的线程有没有被别人锁住，如此循环。

如果所有事务都要更新同一行的场景：

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，就会看到CPU利用率很高，但是每秒却执行不了几个事务。

**怎么解决由这种热点行更新导致的性能问题呢？**问题的症结在于，死锁检测要耗费大量的CPU资源。

**一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。**但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。

**另一个思路是控制并发度。**控制并发度，同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。

在代码层面的设计：（使用队列应该也可以）

将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。但是设计的逻辑可能更复杂一些。

# 事务隔离

在RR隔离级别下，事务开启的时候会创建一个视图，这样其他事务上对数据的修改，在当前事务中是没有影响的。

但是，如果当前事务中，要操作的记录在其他事务中正在被处理，即当前数据已被行锁，那么只能等到其他事务完成后，才能获取数据进行操作，那么此时操作的数据是其他事务修改之前的数据，还是修改之后的数据呢？

举例：

```java
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

![image-20221103141249528](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221103141249528.png)

**事务的启动时机**

begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。Mysql默认autocommit=1，表示自动提交。

事务C没有显式地使用begin/commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。

预期结果：A：1，B：2

实际结果：A：1，B：3

原因：

Mysql的两个视图：视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

1. 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view ... ，而它的查询方法与表一样。
2. 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

**快照**

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。

快照实现：InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。

每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。

数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。

![image-20221103143632523](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221103143632523.png)

虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。

图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。

InnoDB是怎么定义那个“100G”的快照的：

按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。

在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。

数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。

而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。

这个视图数组把所有的row trx_id 分成了几种不同的情况。

![image-20221103144357265](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221103144357265.png)



当前**事务的启动瞬间**来说，一个数据版本的row trx_id，有以下几种可能：

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
    若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

如果有一个事务，它的低水位是18，那么当它访问这一行数据时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。

![image-20221103145245780](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20221103145245780.png)

有了事务id后，系统里面随后发生的更新，就跟这个事务看到的内容无关。因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。

**InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。**



## MVCC原理

在Mysql中，当我们对某一条记录执行更新语句时，会生成一条undo日志，这条日志中记录了当前更新的事务id以及上一条undo日志的地址（roll_pointer）,所有的事务版本通过roll_pointer形成了一条链表，称为版本链。版本链的头结点是当前记录的最新值，每个版本中都有对应的事务id。可以通过这个版本链来控制并发事务**访问（查询）**相同记录时的行为，这就是MVCC（多版本并发控制）

具体控制方式：

在事务中，当执行Select语句时，会创建一个ReadView（RR是第一次Select创建，RC是每次Select创建），记录了当前事务id，当前活跃的事务id，当前活跃事务的最小id，当前活跃事务的最大id+1。查询时，会拿着ReadView中记录的事务信息，去版本链中拿undo日志查询。

查询时，会判断当前事务id和undo日志记录中最新的事务id，如果当前事务id和undo事务id相等，说明这条undo日志是在当前事务中产生的，可以读取到记录信息。当undo的事务id与当前事务id不一样时，此时会判断undo的事务id和ReadView记录的最小值，如果undo的事务id比ReadView记录的最小值小，说明这条undo日志是在当前事务开始前提交的，可以读取这条事务信息，如果undo的事务id比ReadView记录的最大值+1大，说明这条事务是当前事务之后开启的，不能读取，就读取rollpointer指向的undo日志信息再进行判断。如果undo的事务id在ReadView记录的最大与最小的范围内，则判断ReadView有没有记录这个事务id，如果记录，说明当前事务开启时，undo事务还没有结束，不能读取。如果没有记录，说明当前ReadView创建时，那个事务已经提交了，可以读取到。









