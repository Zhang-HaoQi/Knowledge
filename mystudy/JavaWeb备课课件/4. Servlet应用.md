Servlet应用

# 1. ServletRequest

## 1. 介绍

**request和response对象是由服务器创建的**，我们来使用他们。

request是来获取请求消息，response设置响应消息。

**解析**

![image-20211216135811805](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216135811805.png)

### Request体系

![image-20211216140020719](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216140020719.png)

### **获取请求消息数据**

#### **获取请求行**

GET  /servlet /demo1？name=zhangsan  HTTP/1.1

1. 获取请求方式: GET

   String getMethod()

2. 获取虚拟目录: /servlet 

   String getContextPath()

3. 获取Servlet路径: /demo1

   String getServletPath( )

4. 获取get方式请求参数: name= zhangsan

   String getQueryString()

5. 获取请求URI : /servlet / demo1

   string getRequestURI():

6. 获取url : http://localhost/servlet / demo1

   1. StringBuffer getRequestURL()
   2. URL:统一资源定位符: http://localhost/day14/demo1 中华人民共和国	url+文件路径
   3. URI :统一资源标识符: /day14/demo1              共和国            文件路径


7. 获取协议及版本: HTTP/1.1

​		String getProtocol()

8. 获取客户机的IP地址：

   String getRemoteAddr()

```java
@WebServlet("/req/demo1")
public class RequestDemo1 extends HttpServlet {


    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("username:"+req.getParameter("username"));
        System.out.println("password:"+req.getParameter("password"));
        System.out.println("参数集合");
        Map<String, String[]> parameterMap = req.getParameterMap();
        for (String key:parameterMap.keySet()
             ) {
            String[] paramers = parameterMap.get(key);
            System.out.println(Arrays.toString(paramers));
        }
        System.out.println("请求方法"+req.getMethod());
        System.out.println("请求虚拟路径"+req.getContextPath());
        System.out.println("请求接口路径"+req.getServletPath());
        System.out.println("请求URI"+req.getRequestURI());
        System.out.println("请求URL"+req.getRequestURL().toString());
    }

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req,resp);
    }

}
```

jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <link rel="stylesheet" href="/servlet/css/http.css">
</head>

<body>
<a href="/servlet/req/demo1">发送请求</a>
<form action="/servlet/req/demo1" method="get">
    <h1>发送get请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>
<br>

<form action="/servlet/req/demo1" method="post">
    <h1>发送post请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>

</body>
</html>
```

#### 获取请求头

1. String getHeader(String name ) :通过请求头的名称获取请求头的值

   1. ```java
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          //1、获取user-agent的头数据
          //告诉服务器我的浏览器版本
          String userHeader = request.getHeader("user-agent");
          System.out.println(userHeader);
          //判断浏览器版本
          if (userHeader.contains("Chrome")) {
              System.out.println("谷歌");
          } else {
              System.out.println("火狐");
          }
          System.out.println(".....................");
       //2、获取referer的头数据
          String refer = request.getHeader("referer");
          System.out.println(refer); 
           //当直接在浏览器输入时，此时为空   问题：为什么我把链接复制到文档里面打开也是null。。
           //当我通过页面访问时，就可以获取访问地址  http://localhost:8888/servlet/Login.html 
      }
      
      ```

2. Enumeration<string> getHeaderNames() ;获取所有的请求头名称

   1. ```java
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          //获取所有请求头
       Enumeration<String> headerNames= request.getHeaderNames();
          System.out.println("...................");
          System.out.println(headerNames);  //  org.apache.tomcat.util.http.NamesEnumerator@275fd6f4
          while(headerNames.hasMoreElements()){
              String name = headerNames.nextElement();
              //获取头的数据
              String value =request.getHeader(name);
              System.out.println(value);
          }
      }
      ```

##### 获取超链接的所有头信息

```jsp
	<a href="/servlet/demo3">访问服务器</a>
```

![image-20211216141609662](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216141609662.png)

##### 防盗链操作

首先我们部署两个项目，一个项目是存放另一个项目的超链接，一个项目是进行消息反馈。

即一个自制电影网站，一个优酷网站。通过自制网站访问优酷内容，和优酷自身访问优酷内容。比较其差别。

**项目一（优酷）：**

```java
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String referer =  request.getHeader("referer");
    System.out.println(referer);
    if(referer.contains("youku")){
        System.out.println("看电影没门");
        response.setContentType("text/html;charset=utf-8");
        response.getWriter().write("盗我的视频，没有门");
    }else解
    {
        System.out.println("请看电影");
        response.setContentType("text/html;charset=utf-8");
        response.getWriter().write("请看电影哈");
    }
}

// 访问链接：
  <a href="/youku/server">战狼</a>
```

refer:http://localhost:8800/servlet/

**项目二（自建小网站）**：

访问链接：访问的是项目一

```java
  <a href="http://localhost:8081/youku/server">战狼（盗版）</a>
```

refer:http://localhost:8808

#### 获取请求体

请求体:只有POST请求方式,才有请求体,在请求体中封装了POST请求的请求参数
 步骤：

1. 获取流对象
   1. BufferedReader getReader()     字符输入流，**可操作字符串类型的数据**
   2. ServletInputStream getInputstream() 字节输入流，可操作所有类型的数据，图片，文档等df
      1. 相关内容在文件上传中
2. 再从流对象中获取数据

```java
@WebServlet("/req/demo1")
public class ServletDemoTwo extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          //获取请求消息体，即请求参数
        //1.获取字符流
        BufferedReader bf =request.getReader();
        //2.获取数据
        String line= null;
        //line=参数，如果为空，这说明没有数据了
        while ((line=bf.readLine())!=null){
            System.out.println(line);
        }
    }

```

发送请求：

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <link rel="stylesheet" href="/servlet/css/http.css">
</head>

<body>
<a href="/servlet/req/demo1">发送请求</a>
<form action="/servlet/req/demo1" method="get">
    <h1>发送get请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>
<br>

<form action="/servlet/req/demo1" method="post">
    <h1>发送post请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>

</body>
</html>

```



### 其他功能

#### 1. 获取请求参数通用方式

1. String getParameter(String name) :根据参数名称获取参数值 username=zh&password=12

**html代码**

```html
<form action="/servlet/req/demo1" method="get">
    <h1>发送get请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>
<br>

<form action="/servlet/req/demo1" method="post">
    <h1>发送post请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>
```

**servlet代码**

```java
@WebServlet("/req/demo1")
public class RequestDemo1 extends HttpServlet {


    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
 System.out.println("username:"+req.getParameter("username"));
       System.out.println("password:"+req.getParameter("password"));
    }

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req,resp);
    }
}
```

**运行结果：**

![image-20211217205618431](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217205618431.png)

2. String[ ] getParametervalues(String name ) ;根据参数名称获取参数值的数组hobby=xx&hobby=game

3. Enumeration<String> getParameterNames( ):获取所有让求的参数名称

4. Map<String, String[]> getParameterMap( ) :获取所有参数的map集合

**Servlet代码**

```java
@WebServlet("/req/demo2")
public class RequestDemo2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //一、根据参数名称获取参数值
        String parameter= request.getParameter("username");
       System.out.println(parameter); //1427421650
        //二、根据参数值名称获取参数值数组  针对于复选框
        String[] hobbies = request.getParameterValues("hobby");
        for (String hobby:hobbies) {
           System.out.println(hobby);//篮球，足球，橄榄球
        }
        //三、获取所有参数名称
        Enumeration<String> parameterNames = request.getParameterNames();
        while (parameterNames.hasMoreElements()){
            String name= parameterNames.nextElement();
           System.out.println(name); //username password hobby
        }
        //四、获取所有参数名称及其参数值，以键值对的方式保存
        Map<String, String[]> parameterMap = request.getParameterMap();
        //遍历方法1
        for(String key:parameterMap.keySet()) {
            System.out.println(key);
            for (int a=0;a<parameterMap.get(key).length;a++){
                System.out.println(parameterMap.get(key)[a]);
            }
            System.out.println(".......................");
        }
        //遍历方法2
        Map<String, String[]> parameterMap1= request.getParameterMap();
        Set<String> keyset = parameterMap1.keySet();
        for (String name: keyset) {
            //获取键和值
            String [] values = parameterMap.get(name);
            System.out.println(name);
            for (String value:values) {
                System.out.println(value);
            }
            System.out.println("...............................");

        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request,response);
    }
}
```

**JSP代码**

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<form action="/servlet/req/demo2" method="get">
  <input type="username" name="username" placeholder="用户名">
  <br>
  <input type="username" name="password" placeholder="密码">
  <input type="checkbox" name="hobby" value="篮球">篮球
  <input type="checkbox" name="hobby" value="足球">足球
  <input type="checkbox" name="hobby" value="橄榄球">橄榄球
  <br>
  <input type="submit" value="提交">
</form>

</body>
</html>
```

#### 2. 请求转发:

我们在写代码时，不可能将代码都写在一个类里面，所以当服务器访问Servlet接口时，通常是一个接口将信息分担给另一个接口，这样便于维护。

![image-20211219202552812](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211219202552812.png)

**步骤：**

1. 通过request对象获取请求转发器对象：RequestDispatcher  getRequestDispatcher(String path)
2. 使用RequestDispatcher对象来进行转发: forward(ServletRequest request, ServletResponse response)

Dispatcher：调度

**特点:**

1. 浏览器地址栏路径不发生变化
2. 只能转发到当前服务器内部资源中。
3. 转发是一次请求

##### 1. 转发给servlet

发送请求到**ForwardDemo1**，之后转发到**ForwardDemo2** ,再由**ForwardDemo2**转发到**ForwardDemo3**

**jsp**

```jsp
<a href="/servlet/forward/demo1">please  enter me to servlet 03</a>
```

**ForwardDemo1**

```java
@WebServlet("/forward/demo1")
public class ForwardDemo1 extends HttpServlet {
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //方法一：创建对象进行转发
        RequestDispatcher requestDispatcher = request.getRequestDispatcher("/forward/demo2");
        requestDispatcher.forward(request,response);
        System.out.println("hello i am demo1");//转发后，当demo2执行完，后面的代码继续执行。
        //方法二：直接进行转发  注意：在同一个servlet中不能进行两次转发
        //request.getRequestDispatcher("/forward/demo3").forward(request,response);
    }
}
```

**ForwardDemo2** 

```java
@WebServlet("/forward/demo2")
public class ForwardDemo2 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.getRequestDispatcher("/forward/demo3").forward(request,response);
        System.out.println("hello i am demo2");
    }
}
```

**ForwardDemo3**

```java
@WebServlet("/forward/demo3")
public class ForwardDemo3 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("hello i am demo3");
    }
}
```

**结果：**

![image-20211219202640902](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211219202640902.png)

##### 2. 转发给jsp页面

**请求连接**

```jsp
<a href="/servlet/forward/demo4">please  enter me to  forward01.jsp </a>
```



```java
@WebServlet("/forward/demo4")
public class ForwardDemo4 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.getRequestDispatcher("/request/forward01.jsp").forward(req,resp);
    }
}
```

**前端页面forward01.jsp**

1. **使用EL表达式接收**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>hello demo4</h1>
</body>
```

#### 3. 共享数据

**域对象:**一个有作用范围的对象，可以在范围内共享数据

**request域:** 代表一次请求的范围，**一般用于请求转发的多个资源中共享数据**

**方法:**

1. void setAttribute(String name , object obj) :存储数据
2. object getAttitude(String name) :通过键获取值
3. void removeAttribute(String name) :通过键移除键值对

##### 1. 转发给servlet

**存储数据到request域中**

```jsp
    <a href="/servlet/forward/demo5">please  enter me to  servlet 05 </a>

```

```java
@WebServlet("/forward/demo5")
public class ForwardDemo5 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setAttribute("name","Tom");
        //转发给servlet
        req.getRequestDispatcher("/forward/demo6").forward(req,resp);
    }
}
```

**在其他类中获取数据**

```java
@WebServlet("/forward/demo6")
public class ForwardDemo6 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Object name = req.getAttribute("name");
        System.out.println(String.valueOf(name));
    }
}
```

结果：

![image-20211219205608740](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211219205608740.png)

##### 2. 转发给JSP

```java
@WebServlet("/forward/demo7")
public class ForwardDemo7 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       req.setAttribute("name","Lily");
        req.getRequestDispatcher("/request/forward01.jsp").forward(req,resp);
    }
}
```

**jsp获取数据**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>hello demo4</h1>
<span>${name}</span>
</body>
</html>
```

结果：

![image-20211219205754357](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211219205754357.png)

#### 中文乱码问题

1. 发送get请求时，不会发生乱码问题。因为Tomcat8已解决这种问题。

2. 当发送post请求时，如果请求内容为中文，会出现乱码问题。

   解决措施：请求参数前声明一下编码格式 request.setCharacterEncoding("utf-8");

**servlet**

```java
@WebServlet("/mess-code/demo1")
public class MessCodeDemo1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(req.getParameter("username"));
        System.out.println(req.getParameter("password"));
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //出现乱码问题，没有解决。使用req.getParameter("")获取参数设置utf-8可以解决
        BufferedReader reader = req.getReader();
        String line = null;
        while ((line=reader.readLine())!=null){
            System.out.println(line);
        }
    }
}
```

**jsp**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>乱码问题：</h1>
<form action="/servlet/mess-code/demo1" method="get">
    <h1>发送get请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>
<br>

<form action="/servlet/mess-code/demo1" method="post">
    <h1>发送post请求</h1>
    用户名：<input name="username" type="text">
    <br>
    密码：<input name="password" type="text">
    <br>
    <input type="submit" value="提交">
</form>

```

**结果：**

![image-20211219212342617](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211219212342617.png)

**解决方式:**设置字符编码

```java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("post请求");
        req.setCharacterEncoding("UTF-8");
        System.out.println(req.getParameter("username"));
        System.out.println(req.getParameter("password"));
    }
```

## 2. 如何同时运行两个项目，部署两个服务器

### 1.  创建一个空的项目工程文件

![image-20211220103857560](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211220103857560.png)

### 2. 创建项目名称

![image-20211220110904991](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211220110904991.png)

### 创建两个子模块 pro_01和pro_02

注意：配置jdk版本。

![image-20211220110000082](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211220110000082.png)

### 分别添加框架支持

![image-20211220110413080](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211220110413080.png)

### 分别添加Tomcat服务

注意：端口号的Name不能一样。

![image-20211220110618716](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211220110618716.png)

### 分别启动Tomcat服务

![image-20211220111149430](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211220111149430.png)

# 2. ServletResponse

## 1. 介绍

### Response体系

![image-20211216212434351](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216212434351.png)

### 设置响应消息

**设置响应行**

格式 HTTP/1.1  200 OK

设置状态码：set

**设置响应头**

 setHeader(String name, String value)

**设置响应体**

使用步骤:

1. 获取输出流

   1. 字符输出流: PrintWriter getWriter()

   2. 字节输出流: Servletoutputstream getoutputStream()
2. 使用输出流，将数据输出到客户端浏览器

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    response.setContentType("text/html");
    // Hello
    PrintWriter out = response.getWriter();
    out.println("<html><body>");
    out.println("<h1>" + message + "</h1>");
    out.println("</body></html>");
}
```

## 2. 案例

### 1. 重定向

#### **a.   资源跳转的方式**

![image-20211216212632173](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216212632173.png)

#### **b.  两种方式实现，推荐选择第二种。**

```java
 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("demo111111111111");
        //方式1：设置重定向
        //1.1设置状态码
        response.setStatus(302);
        //1.2设置响应头location
//response.setHeader("location","/Response/servletDemo2");
        //方式2：设置重定向（简单）
      response.sendRedirect("/Response/servletDemo2");
        }

```

#### **c.   重定向和转发的区别**

面试经常考这两个的区别（forword和redirect的区别）

**重定向：**

1. 页面跳转，地址栏发生变化

2. 重定向可以访问其他站点（服务器），比如访问百度

3. 重定向是两次请求，不能使用request域来共享数据

```java
request.setAttribute("msg","helloworld");//设置共享资源
response.sendRedirect("https://www.baidu.com/");//访问百度

Object msg = request.getAttribute("msg");  //获取共享资源   
System.out.println(msg);     //  null    获取不到
```

**转发：**

1. 页面跳转，地址栏不发生改变

2. 转发只能访问当前服务器下的资源

3. 转发是一次请求，可以使用request域来共享资源

#### d.  路径写法

路径分类：

1. **相对路径 ：**当前资源和目录资源之间相对的位置关系。   ./  开头

   ./当前目录 ../上一级目录

2. **绝对路径：**通过绝对路径，可以确定唯一资源。       以  /  开头
   1. 如：http://localhost:8888/Response/servletDemo2    /Response/servletDemo2 ，前面的http可以省略
   2. **判断定义的路径给谁用的，判断请求将来从哪里发出（虚拟目录什么时候使用）**
      1. **客户端浏览器使用，需要添加虚拟目录**（项目所在文件夹的名称）
         1. 如网页上的超链接，点击访问服务器，是客户端浏览器使用，需要添加虚拟目录
         2. <a>，<form>,重定向
      2. **服务器使用，不需要添加虚拟目录**
         1. 转发操作，是浏览器内部访问的
         2. 注意：重定向是服务器将状态码和路径传递给客户端，客户端再通过路径访问服务器，是客户端浏览器使用，需要添加虚拟目录

```java
//重定向：需要虚拟目录
response.sendRedirect("/Response/servletDemo2");

//转发：不需要虚拟目录
request.getRequestDispatcher("/selectDemo2").forward(request,response);
```

#### e. 动态路径获取

问题：我们通过上述代码可以看出，填写的虚拟目录的路径是固定的/Response，那么问题来了，以后假如我写非常多的接口，突然我把虚拟目录的路径改了，那么我就得把所有的虚拟目录的路径改了，这样就太麻烦了。所以我们在实际的编程中，都是通过动态获取虚拟目录的方式

动态获取虚拟目录

```java
动态获取虚拟目录
String contextPath = request.getContextPath();
response.sendRedirect(contextPath+"/servletDemo2");
```

### 2. 服务器输出字符数据到浏览器

步骤:

1. 获取字符输出流

2. 输出数据

```java
//获取字符输出流

PrintWriter writer = response.getWriter();

//输出数据

writer.write("helloworld");

//输出html格式数据

writer.write("<h1>helloworld<h1>");

//输出中文数据

writer.write("你好，我的世界");//中文乱码
```

3. 中文乱码问题

![image-20211216213515298](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216213515298.png)

1. 浏览器默认的字符编码根据操作系统的语言环境有关，win10的为GBK（中文简体）或gb312
2. 如果服务器的字符是new出来的，也是GBK，如果是获取的，字符编码是Tomcat定义的ISO-8859-1
3. 解决：获取流对象之前，设置编码格式  response.setContentType（“text/html;charset=utf-8”）

```java
方式1设置编码格式

 //1.1获取流对象之前，把流的默认编码“ISO-8859-1”设置为：utf-8
 response.setCharacterEncoding("utf-8");
 //1.2告诉浏览器，服务器发送的数据的编码，建议浏览器使用此编码
 response.setHeader("content-type","text/html;charset=utf-8");


方式2 设置编码格式（推荐）

 response.setContentType("text/html;charset=utf-8");
```

### 3. 服务器输出字节数据

步骤:

1. 获取字节输出流

2. 输出数据

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //方式2 设置编码格式
    response.setContentType("text/html;charset=utf-8");
    ServletOutputStream outputStream = response.getOutputStream();
    outputStream.write("hello".getBytes());
}
```

### 4. 验证码响应

Servlet代码

```java
@WebServlet("/checkCodeServlet")
public class checkCodeServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
     //1.创建一个对象，在内存中存图片（验证码图片对象）
        int width =100;
        int height= 50;
        BufferedImage image  =new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);//宽，高，格式
     //2.美化图片
        //2.1化背景颜色
        Graphics graphics = image.getGraphics();//画笔对象
        graphics.setColor(Color.pink);//设置画笔颜色
        graphics.fillRect(0,0,width,height);//填充一个蓝色的矩形  填充的位置和大小
        //2.2画边框
        graphics.setColor(Color.BLUE);//设置颜色
        graphics.drawRect(0,0,width-1,height-1);//画边框
        //2.3写验证码
         String str ="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";  //验证码包含的所有字符数字
        Random random = new Random();//画验证码验证符
        for (int i = 1; i < 5; i++) {
            int s = random.nextInt(str.length());//随机获取字符串的角标，长度在字符串长度的范围内
            char c = str.charAt(s);//获取随机的字符
            graphics.drawString(c+"",i*20,25);//字符串的内容和位置
        }
        //2.4画干扰线
        graphics.setColor(Color.black);
        for (int i = 0; i < 10; i++) {
            int x1 = random.nextInt(100);
            int x2 = random.nextInt(100);
            int y1 = random.nextInt(50);
            int y2 = random.nextInt(50);
            graphics.drawLine(x1,y1,x2,y2);
        }

        //3.将图片输入到页面展示
        ImageIO.write(image,"jpg",response.getOutputStream());//输出对象，后缀名，输出流输出
            }
```

HTML代码

```java
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        window.onload = function () {
            //点击图片切换
            //获取图片
            let elementById = document.getElementById("img");
          //更改图片，其实就是更改图片的路径，因为我们的图片是随机生成的，所以只需要图片重新加载一次即可。
            elementById.onclick=function () {
                // elementById.src="/Response/checkCodeServlet";
                //这时你会发现点击图片没有变化，这是因为之前浏览器已经访问过这个路径了，此时路径的内容已经存储在了浏览器的内存中，所以访问的还是之前的图片
               // 解决措施：假意传参.   如果参数传入相同的值，那么就会造成只能切换一次。跟上面一个道理。所以要传一个随机的值
               //  elementById.src="/Response/checkCodeServlet?1";

                //因为随机数有时候也可能相同，所以遇到这种情况，我们可以通过把时间戳当做参数来解决。
               let date = new Date().getTime();
                elementById.src="/Response/checkCodeServlet?"+date;
                alert(data)
            }
            //点击文字切换
            let elementById1 = document.getElementById("change");
            elementById1.onclick=function () {
               let date = new Date().getTime();
                elementById.src="/Response/checkCodeServlet?"+date;
            }
        }
    </script>
</head>
<body>
<!--图片的点击切换-->
<img id="img" src="/Response/checkCodeServlet">
<a id="change">看不清，换一张</a>
</body>
</html>

```

# 3. ServletContext

## 1. 介绍

**概念:**

代表整个web应用，可以和程序的容器(服务器)来通信

## 2. **获取方式**

1.通过request对象获取

request . getServletContext();

2.通过HttpServlet获取

this .getServletContext();

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    javax.servlet.ServletContext servletContext = request.getServletContext();
    javax.servlet.ServletContext servletContext1 = this.getServletContext();
    System.out.println(servletContext==servletContext1);  //true
    System.out.println(servletContext);                   //org.apache.catalina.core.ApplicationContextFacade@628e8f44

}

```

## 3. 功能

### 1.   获取MIME类型

1. MIME类型:在互联网通信过程中定义的一种文件数据类型

   格式:大类型/小类型  如：text/html  image/jpeg ;

2. 获取: string getMimeType(String file)

```java
//获取文件类型

javax.servlet.ServletContext servletContext = request.getServletContext();

String file = "a.jpg";

String mimeType = servletContext.getMimeType(file);

System.out.println(mimeType);//image/jpeg
```

### 2.   域对象:共享数据

a.   setAttribute(String name , object value)

b.   getAttribute(String name)

c.   removeAttribute(String name )

**ServletContext3设置共享数据**

```java
@WebServlet("/ServletContext3")
public class ServletContext3 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        javax.servlet.ServletContext servletContext1 = request.getServletContext();
      servletContext1.setAttribute("meg","helloworld");//helloworld
    }
```

**ServletContext2获得共享数据**

```java
@WebServlet("/ServletContext2")
public class ServletContext2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        javax.servlet.ServletContext servletContext1 = request.getServletContext();
        Object meg = servletContext1.getAttribute("meg");
        System.out.println(meg);//helloworld
    }
```

**注意：**

1. ServletContext对象范围：所有用户请求的数据。。 张三请求的数据，张四也可以看到

2. 该对象在服务器中贮存的时间特别长，从开始到销毁，所以用的时候需要非常谨慎。  

### 3.   获取文件的真实路径

1. 获取文件（服务器）的真实路径  String  getRealPath(**“”**);

2. 文件在不同路径下的获取方法

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    javax.servlet.ServletContext servletContext1 = request.getServletContext();
    //查看斜杠表示的目录
    String realPath1 = servletContext1.getRealPath("/");  
    System.out.println(realPath1);
    //E:\Java文件\Response\out\artifacts\Response_war_exploded\
    //获取ConfigurationA
    String realPathA = servletContext1.getRealPath("/WEB-INF/classes/ConfigurationA"); src目录下
    System.out.println(realPathA);
    // E:\Java文件\Response\out\artifacts\Response_war_exploded\WEB-INF\classes\ConfigurationA
    //获取ConfigurationB
    String realPathB = servletContext1.getRealPath("/WEB-INF/ConfigurationB");   WEB-INF目录下
    System.out.println(realPathB);
    //    E:\Java文件\Response\out\artifacts\Response_war_exploded\WEB-INF\ConfigurationB
    //获取ConfigurationC
    String realPathC= servletContext1.getRealPath("/ConfigurationC");        Web目录下
    System.out.println(realPathC);
    //   E:\Java文件\Response\out\artifacts\Response_war_exploded\ConfigurationC
}
```



![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image002.gif)![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image004.gif)

## 4. 案例

### 文件下载

在浏览器中超链接的图片可以直接查看，但是视频需要下载获取.

#### 需求:

1. 页面显示超链接

2. 点击超链接后弹出下载提示框

3. 完成图片文件下载

#### 分析:

1. 超链接指向的资源如果能够被浏览器解析,则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求（图片可以直接被浏览器解析，但是视频是不可以的）

2. 任何资源都必须弹出下载提示框

3. 使用响应头设置资源的打开方式: content-disposition: attachment ;filename=xxx

#### 步骤:

1. 定义页面，编辑超链接href属性,指向Servlet，传递资源名称filename

2. 定义Servlet

   1. 获取文件名称

   2. 使用字节输入流加载文件进内存

   3. 指定response的响应头: content- disposition: attachment; filename=xxx

      ![image-20211216215325140](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215325140.png)

   4. 将数据写出到response输出流

#### 代码展示

链接代码：

```html
<!--在浏览器中超链接的图片可以直接查看，但是视频需要下载获取-->
<a href="/Response/img/台球.jpg">图片下载</a>
<a href="/img/movie.avi">视频下载</a>
<br>
<a href="/Response/downLoad1?filename=ball.jpg">图片下载</a>
<a href="/Response/downLoad1?filename=movie.avi">视频下载</a>

```

接口:

接口中，在获取文件名之前，先解析文件名。

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //1.获取请求参数，文件名称
    String fileName =request.getParameter("filename");
    System.out.println(fileName); //photo
    
    //2.使用字节流，加载文件进内存
    //2.1找到文件所在的服务器路径
    ServletContext servletContext = request.getServletContext();
    String realPath = servletContext.getRealPath("/img/" + fileName);//图片的真是路径
    //2.2使用字节流关联
    FileInputStream fis = new FileInputStream(realPath);
    //自己理解为，通过此步骤，可以获取从浏览器把文件保存到本地的权限


    //3.设置response响应头
    //3.1设置响应头的数据类型：content-type  //因为我们也不知道文件的类型，所以需要设置。
    String mimeType = servletContext.getMimeType(fileName);
    response.setHeader("content-type",mimeType);
    //3.1.1解决中文文件名问题
    //获取user-agent请求头
    String agent = request.getHeader("user-agent");
    String fileName1 = DownLoadeUtilis.getFileName(agent, fileName);

    //3.2设置响应头的打开方式
    response.setHeader("content-disposition","attachment;filename="+fileName);//filename设置的为下载提示框的名字
    
    //4.将输入流的数据写出到输出流中
    ServletOutputStream sos = response.getOutputStream();
    byte[] buff = new byte[1024*8];
    int len = 0;
    while ((len=fis.read(buff))!=-1){
        sos.write(buff,0,len);
    }
    fis.close();//输入流关闭
}
```

文件夹：

![image-20211216215504979](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215504979.png)

#### 中文文件名称无法显示问题

```html
<a href="/Response/downLoad1?filename=球员.jpg">中文名称图片下载</a>
```

![image-20211216215541385](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215541385.png)

**解决思路**

1. 获取客户端使用的浏览器版本信息

2. 根据不同的浏览器版本信息，设置filename的编码 式不同

![image-20211216215627980](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216215627980.png)

 

```java
在获取文件名之前，先解析文件名

//3.1.1解决中文文件名问题

//获取user-agent请求头

String agent = request.getHeader("user-agent");

String fileName1 = DownLoadeUtilis.getFileName(agent, fileName);

//3.2设置响应头的打开方式

response.setHeader("content-disposition","attachment;filename="+fileName1);//filename设置的为下载提示框的名字
```

封装的代码

```java
public class DownLoadeUtilis {
    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException {
        if (agent.contains("MSIE")) {
// IE浏览器
            filename = URLEncoder.encode(filename, "utf-8");
            filename = filename.replace("+", "");
        } else if (agent.contains("Firefox")) {
//火狐浏览器
            BASE64Encoder base64Encoder = new BASE64Encoder();
            filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?=";
        } else {
// 其它浏览器
            filename = URLEncoder.encode(filename, "utf-8");

        }
        return filename;

    }
}
```

# 4.Cookie和Session

## 优秀blog

[(104条消息) Session是怎么实现的？存储在哪里？_码农的博客-CSDN博客_session怎么存储数据](https://blog.csdn.net/dlovejava/article/details/80863855)

[cookie和session的详解和区别](https://www.cnblogs.com/l199616j/p/11195667.html)

https://www.cnblogs.com/accolade/p/10817529.html

## 会话技术

### 介绍

Cookie和Session属于会话技术，cookie存储在浏览器上，session存储在服务器中。

**会话:**一次会话中包含多次请求和响应。



![image-20211217221820107](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217221820107.png)



**一次会话:**浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。

就好比打电话，A给B打电话，接通之后，会话开始，直到挂断电话，该次会话就结束了，而浏览器访问服务器，就跟打电话一样，浏览器A给服务器发送请求，访问web程序，该次会话就已经接通，其中不管浏览器发送多少请求(就相当于接通电话后说话一样)，都视为一次会话，直到浏览器关闭，本次会话结束。其中注意，一个浏览器就相当于一部电话，如果使用火狐浏览器，访问服务器，就是一次会话了，然后打开google浏览器，访问服务器，这是另一个会话，虽然是在同一台电脑，同一个用户在访问，但是，这是两次不同的会话。

**功能:**在一次会话的范围内的多次请求间，共享数据

**方式：**

1. 客户端会话技术: Cookie
2. 服务器端会话技术: Session

### Cookie和Session之间的区别和联系

假如一个咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案：

1. 该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。但是http协议本身是无状态的

2. 发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。也就是cookie。 顾客就相当于浏览器，cookie如何工作，下面会详细讲解

3. 发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。

　　由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。

**举例：**

网上购物时，添加一次购物车，就是一次请求，我将多个物品添加到购物车，就是多次请求，最后计算总价时，就需要将之前请求的数据进行一下总和，cookie就是做这个总和的。

## Cookie

### cookie介绍

会员卡的第二种方案。

客户端会话技术，将数据保存到客户端。**Cookie通过在客户端记录信息确定用户身份**，**Session通过在服务器端记录信息确定用户身份**。

**使用步骤：**

1. 创建cookie对象，绑定数据   new Cookie(String name，String value )
2. 发送cookie对象    response.addCookie(Cookie c);

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      //1.创建cookie对象
    Cookie c = new Cookie("msg","hello");
    //2.发送cookie
    response.addCookie(c);
}

```

3. 获取cookie，拿到数据

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
   //3.获取cookie
    Cookie[] cookies = request.getCookies();
    if(cookies!=null){
        for (Cookie c:cookies) {
            String name = c.getName();
             String value  =c.getValue();
            System.out.println(name+":"+value);   //msg:hello
        }
    }
}
```

**两次请求的response和request头对比**

**第一次请求：**

![image-20211217222401715](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217222401715.png)

**第二次请求：**

![image-20211217222419943](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217222419943.png)

**总结：**

1. 第一次请求时，是获取浏览器中的数据，所以第一次request请求未携带任何cookie信息。
2. 第一次请求完毕后，返回的response将第一次创建的cookie数据返回
3. 第二次请求时，浏览器拿着第一次response返回的cookie数据发送到服务器

![image-20211217222503995](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217222503995.png)

### Cookie细节

#### 1. 一次请求发送多个Cookie

demo1

```java
//1.创建cookie对象
Cookie c1 = new Cookie("msg","hello");
Cookie c2 = new Cookie("asd","hsdlo");
Cookie c3 = new Cookie("csa","heffo");
//2.发送cookie
response.addCookie(c1);
response.addCookie(c2);
response.addCookie(c3);
```

demo2

```java
//3.获取cookie
 Cookie[] cookies = request.getCookies();
 if(cookies!=null){
     for (Cookie c:cookies) {
         String name = c.getName();
          String value  =c.getValue();
         System.out.println(name+":"+value);
     }
 }
```

demo3

```java
@WebServlet("/CookieDemo3")
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
//什么都没写，但是request的请求头里面保存着之前cookie返回的数据
}
```

第一次请求数据，response的响应头

![image-20211217222652820](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217222652820.png)

第二次请求时，resquest的请求头

![image-20211217222711391](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217222711391.png)

第三次请求时，resquest的请求头

![image-20211217222744438](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217222744438.png)

响应头

![image-20211217222755804](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217222755804.png)

从以上的几次请求响应可以看出，除了第一次访问，其他访问请求cookie一直在都在浏览器访问服务器中作为数据传递。不管你吊没吊用获取cookie的方法。

#### 2. Cookie的存活时间

可以自由设置，默认是关闭浏览器，cookie就没用了。

```java
cookie.setMaxAge(expiry);　　//设置cookie被浏览器保存的时间。
expiry：单位秒，默认为-1，
expiry=-1：代表浏览器关闭后，也就是会话结束后，cookie就失效了，也就没有了。
expiry>0：代表浏览器关闭后，cookie不会失效，仍然存在。并且会将cookie保存到硬盘中，直到设置时间过期才会
expiry=0：删除cookie。不管是之前的expiry=-1还是expiry>0，当设置expiry=0时，cookie都会被浏览器给删除。
```

 #### 3. Cookie是否支持中文数据（下方案例中使用）

1. 在tomcat 8之前cookie中不能直接存储中文数据。需要将中文数据转码，一般采用URL编码(%E3)
2. 在tomcat 8之后，cookie支持中文数据。但是对于特殊字符比如空格不支持。还得使用URL编码和URL解码

#### 4. cookie的共享问题

**假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享?**

1. 默认情况下cookie不能共享

   1. setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录setPath("/cookie")
   2. 如果要共享，则可以将path设置为"/" setPath("/")

   ```java
   Cookie c = new Cookie("name","张浩琦");
   c.setPath("/");
   response.addCookie(c);
   
   获取信息
   Cookie[] cookies = request.getCookies();
   if(cookies!=null){
       for (Cookie c:cookies) {
           String name = c.getName();
           String value  =c.getValue();
           System.out.println(name+":"+value);
       }
   }
   ```

##### 同一个服务器的两个项目

![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217223411735.png)

如果我没有设置 setPath("/")

![image-20211217223443743](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217223443743.png)

设置了 setPath("/")

![image-20211217223504811](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217223504811.png)

##### 在多个服务器之间，能否实现数据共享

假如：[www.tieba.baidu.com](http://www.tieba.baidu.com)和[www.new.baidu.com](http://www.new.baidu.com)这两个网站肯定都属于百度的项目，但是这两个项目肯定不会运行在一个服务器中，但是这两个网页之间肯定有某些数据的共享。

1. 二者的域名为都有共同成分.baidu.com。这是一级域名。.news或.tieba 这是二级域名。
2. 只要我们保证两个网页的一级域名相同，那么我们就可以实现不同浏览器之间的数据共享。
   1. setDomain(String path) :如果设置一级域名相同, 那么多个服务器之间cookie可以共享
   2. setDomain(" . baidu. com") ,那么tieba. baidu. com和news . baidu. com中cookie可以共享

### Cookiie总结

**工作流程：**

1. servlet创建cookie，保存少量数据，发送浏览器。

2. 浏览器获得服务器发送的cookie数据，将自动的保存到浏览器端。

3. 下次访问时，浏览器将自动携带cookie数据发送给服务器。

**cookie操作**

1.创建cookie：new Cookie(name,value)

2.发送cookie到浏览器：HttpServletResponse.addCookie(Cookie)

3.servlet接收cookie：HttpServletRequest.getCookies() 浏览器发送的所有cookie

**cookie特点**

1. 每一个cookie文件大小：4kb ， 如果超过4kb浏览器不识别
2. 只能存字符串

2. 一个web站点（web项目）：发送20个

   3.一个浏览器保存总大小：300个

4. cookie 不安全，可能泄露用户信息。浏览器支持禁用cookie操作。

5. 默认情况生命周期：与浏览器会话一样，当浏览器关闭时cookie销毁的。---临时cookie

**作用:**

1. cookie一般用于存出少量的不太敏感的数据

2. 在不登录的情况下，完成服务器对客户端的身份识别

### 案例

#### 记录访问时间

![image-20211217223901386](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217223901386.png)

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
  /*
  * 在服务器中的Servlet判断是否有-一个名为lastTime的cookie
    1.有:不是第一次访问
    1.响应数据:欢迎回来，您上次访问时间为:2018年6月10日11:50:20
    2.写回Cookie: lastTime=2018年6月10日 11:50:01
    2.没有:是第一次访问
    1.响应数据:您好，欢迎您首次访问
    2.写回Cookie: lastTime=2018年6月10日 11:50:01
  *
  * */
  //设置响应消息体的编码格式
    response.setContentType("text/html;charset=utf-8");
  //1、判断是否有cookie  先获取所有的cookie、
    Cookie[] cookies = request.getCookies();
    //1.1设置一个关于是否有lastname的cookie判断
    boolean flag=false;
    //2.遍历cookie数组
if (cookies!=null&&cookies.length>0){
    for (Cookie cookie: cookies
         ) {
        //3.获取cookie的名称
        String name = cookie.getName();
        //4.判断名称是否是：lastname
        if("lastname".equals(name)){
            //有该cookie 表示不是第一次访问
            flag=true;
            //响应数据
            //获取cookie的数据
            String value = cookie.getValue();
            System.out.println("解码前"+value);
            //URL解码
            value= URLDecoder.decode(value,"utf-8");
            System.out.println("解码后"+value);
            response.getWriter().write("<h1>欢迎回来，您上次的访问时间为"+value+"</h1>");//此处为中文消息，需要设置响应消息体


            //设置cookie的值，现在的值
            //获取当前时间的字符串，重新设置cookie的值，重新发送
            Date date = new Date();
            System.out.println("修改前"+date);
            //设置时间的格式，默认的为美国的时间格式
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy年mm月dd日  HH：mm：ss");//设置日期时间的格式
            //将时间生成字符串
            String str_date=sdf.format(date);
            System.out.println("编码前"+str_date);
            //URL编码
            str_date = URLEncoder.encode(str_date,"utf-8");
            System.out.println("编码后"+str_date);
            //设置cookie
            cookie.setValue(str_date);
            //设置cookie的存活时间.存活一个月
            cookie.setMaxAge(60*60*24*30);
            //发送cookie
            response.addCookie(cookie);

            //找到名字为lastname的cookie之后，就不要循环了
            break;
        }



    }
}
if(cookies==null||cookies.length==0||flag==false){
    Date date = new Date();
    //设置时间的格式，默认的为美国的时间格式
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年mm月dd日  HH：mm：ss");//设置日期时间的格式
    //将时间生成字符串
    String str_date=sdf.format(date);
    //URL编码
    str_date = URLEncoder.encode(str_date,"utf-8");
    System.out.println("编码后"+str_date);
    //设置cookie
    Cookie cookie = new Cookie("lastname",str_date);
    cookie.setValue(str_date);
    //设置cookie的存活时间.存活一个月
    cookie.setMaxAge(60*60*24*30);
    //发送cookie
    response.addCookie(cookie);
    //响应数据
    //获取cookie的数据
    String value = cookie.getValue();
    //URL解码
    value= URLDecoder.decode(value,"utf-8");
    System.out.println("解码后"+value);
    response.getWriter().write("<h1>你好，欢迎您首次访问</h1>"+value);//此处为中文消息，需要设置响应消息体
}
}

```

## Session

### Session介绍

会员卡的第三种方案。

服务器端会话技术，在一次会话的多次请求间共 享数据,将数据保存在服务器端的对象中。HttpSession。

**使用步骤：**

1. 获取HttpSession对象 :
   1. HttpSession session = request . getSession();

2. 使用HttpSession对象 :
   1. object getAttribute(String name)   
   2. void setAttribute(String name, object value)
   3. void removeAttribute(String name)

**demo1:创建数据**

```java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
 //使用session共享数据
    //1.获取session对象
    HttpSession session = request.getSession();
    //2.存储数据
    session.setAttribute("msg","hello session");
}

```

**demo2：获取数据**

```java
//使用session共享数据
   //1.获取session对象
   HttpSession session = request.getSession();
   //2.获取数据
   Object msg = session.getAttribute("msg");
   System.out.println(msg);

```

**原理：**

session是依赖于cookie的。

第一次访问，请求头

![image-20211217224129424](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217224129424.png)

第二次访问请求头

![image-20211217224141239](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217224141239.png)

他们的JESSIONID的值是一样的，这也就是为什么一次会话，确定的session对象是同一个

![image-20211217224200226](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217224200226.png)

关闭后重新打开，session会话是否结束

### Session原理

参考文章：[(104条消息) Session是怎么实现的？存储在哪里？_码农的博客-CSDN博客_session怎么存储数据](https://blog.csdn.net/dlovejava/article/details/80863855)

session在访问tomcat服务器HttpServletRequest的getSession(true)的时候创建，tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid。

存储在服务器的内存中，tomcat的StandardManager类将session存储在内存中，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。

在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建。

在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。

### Session细节

#### 1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个?

1. 默认情况下：不是。
2. 如果需要相同，则可以创建cookie,键为JSESSIONID,设置最大存活时间，让cookie持久化保存。

```java
//1.获取session对象
HttpSession session = request.getSession();
//打印session
System.out.println(session);
Cookie cookie =new Cookie("JSESSIONID",session.getId());
cookie.setMaxAge(60*60);
response.addCookie(cookie);
```

#### 2.客户端不关闭，服务器关闭后，两次获取的session是同一个吗?

1. session对象都是存在服务器里面的，如果关闭服务器后，再打开，那么就又重新创建了两个服务器对象，肯定不一样。
2. 不是同一个，但是要确保对象不丢失（假如我添加了一些商品到购物车中，我有点事情出去了，京东服务器重启了，那么我的购物车的内容不都清空了吗？）
   1. session钝化
      1. 在服务器正常关闭之前，将session对象系列化到硬盘上
   2. session活化
      1. 在服务器启动后，将session文件转化为内存中的session对象即可
3. session钝化和活化Tomcat已经自动帮我们解决了，只不过我们是用IDEA时，IDEA不会活化，获取不到，所以我们再本地部署Tomcat即可。

#### 3. session的失效时间?

session什么时候被销毁?

1. 服务器关闭

2. session对象调用invalidate() 。

3. session默认失效时间30分钟

**选择性配置修改**

```xml
<session-config>

<session-timeout>30</session-timeout>

</session-config>
```

![image-20211217224705058](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211217224705058.png)

在Tomcat的web-xml里面，可以进行相关的配置。

#### 4. Session和cookie区别

1. session存储数据在服务器端，Cookie在客户端
2. session没有数据大小限制，Cookie有
3. session数据安全，Cookie相对于不安全

# 5. Filter和Listener

JavaWeb三大组件：Servlet，Filter，Listener

## Filter

### 介绍

#### 概念

生活中的过滤器:净水器,空气净化器，土匪、

web中的过滤器:当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。

过滤器的作用:

一般用于完成通用的操作。如:登录验证、统一编码处理、敏感字符过滤...

### **入门：**

1.步骤:

1.定义一个类，实现接口Filter（见下面的注解）

2.复写方法

3.配置拦截路径

#### 拦截路径

1. 方式一：在web.xml中配置

   1. ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
               version="3.1">
      
      
      <filter>
          <filter-name>demo1</filter-name>
          <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
      </filter>
      <filter-mapping>
          <filter-name>demo1</filter-name>
          <url-pattern>/*</url-pattern>
      </filter-mapping>
      
              </web-app>
      
      ```

2. 方式二：使用注解中配置@WebFilter("/*")

   1. ```java
      @WebFilter("/*")   //所有页面被访问之前都被过滤
      public class FilterDemo1 implements Filter {
          //Filter接口一定要是javax.servlet下面的
          @Override
          public void init(FilterConfig filterConfig) throws ServletException {
      
          }
      
          @Override
          public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
              System.out.println("doFilter");
              //设置以后，才可以正常访问，不然的话页面不会显示数据  放行
              filterChain.doFilter(servletRequest,servletResponse);
          }
      
          @Override
          public void destroy() {
      
          }
      }
      
      ```

### Filter细节

#### 1. 过滤器执行流程

1.执行过滤器（通常操作request相关数据）

2.执行放行后的资源（servlet中的代码）

3.回来执行过滤器放行代码下边的代码（通常操作response相关数据）

```java
@WebFilter("/*")   //所有页面被访问之前都被过滤
public class FilterDemo1 implements Filter {
    //Filter接口一定要是javax.servlet下面的
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        //放行前，通常执行request的相关代码
        System.out.println("");
        filterChain.doFilter(servletRequest,servletResponse);
        //放行后，通常执行response的相关代码
         System.out.println("");
    }

    @Override
    public void destroy() {

    }
}
```

#### 2. 过滤器生命周期方法

1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源

2. doFilter:每一次请求被拦截资源时，会执行。执行多次

3. destroy :在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源

#### 3. 过滤器配置详解

**拦截路径配置:**

@WebFilter("/*") 

1.具体资源路径: /index. jsp     只有访问index. jsp资源时，过滤器才会被执行

2.拦截目录，/user/* 		访问/user下的所有资源时，过滤器都会被执行

3.后缀名拦截: *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行

4.拦截所有资源: /*  访问所有资源时，过滤器都会被执行|

**拦截方式配置:**

浏览器访问服务器可以直接访问，也可以访问服务器后通过servlet转发到其他的servlet，即服务器内部访问。

**注解配置：**

设置dispatcherTypes属性

1. REQUEST :默认值。浏览器直接请求资源

2. FORWARD :转发访问资源
3. INCLUDE : 包含访问资源
4. ERROR :错误跳转资源

5. ASYNC :异步访问资源

```java
//拦截方式配置   当请求或访问index.jsp时，会被拦截
@WebFilter(value = "/index.jsp" ,dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST})
@WebFilter(value = "/index.jsp" ,dispatcherTypes = DispatcherType.FORWARD）
```

**xml配置**

![image-20211218213609702](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211218213609702.png)

#### 4. 过滤器链

![image-20211218214917584](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211218214917584.png)

**执行顺序:如果有两个过滤器:过滤器1和过滤器2**

1.过滤器1

2.过滤器2

3.资源执行

4.过滤器2

5.过滤器1

**过滤器先后顺序问题:**

1. 注解配置:按照类名的字符串比较规则比较，值小的先执行

如: AFilter 和BFilter, AFilter就先执行 了。

2. web. xml配置: <filter- mapping>谁定义在上边，谁先执行

**代码展示（课堂编写）**

### **拦截路径**

# 5. 路径问题汇总

1. /表示根路径

   1. 在前端页面，表示的是当前主机地址和端口号。即：localhost：8080

      1. ```java
         //jsp页面中发送请求，需要添加/servlet虚拟路径 
         <a href="/servlet/blog/add">添加blog</a>
         ```

   2. 在servlet服务中，表示的是当前服务器的虚拟路径。即localhost: 8080/servlet/

      1. ```java
         //servlet服务中进行转发，不需要添加/servlet虚拟路径 
         request.getRequestDispatcher("/hello.jsp").forward(request,response);
         ```

# 6. 案例

##  1. 用户登陆（request）

### 案例需求:

1. 编写login. html登录页面username & password两个输入框

2. 使用Druid数据库连接池技术，操作mysql数据库中tb_students_info表（这里使用的是DRUID链接池）

3. 使用JdbcTemplate技术封装JDBC（使用返回的数据直接封装）

4. 登录成功跳转到SuccessServlet展示:登录成功!用户名，欢迎您

5. 登录失败跳转到FailServlet展示:登录失败，用户名或密码错误

### 逻辑图示：

![image-20211216155747452](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211216155747452.png)

### 报错：

 Could not initialize class cn.itcast.Util.JDBCUtils

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image024.gif)

解决：

jar包放在lib文件夹里面，而我却放在了libs里面

### 核心代码

建表语句

```sql
CREATE TABLE `tb_students_info` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id\r\n',
  `username` varchar(255) NOT NULL DEFAULT '' COMMENT '用户名',
  `password` varchar(255) NOT NULL DEFAULT '' COMMENT '密码',
  `name` varchar(255) NOT NULL DEFAULT '' COMMENT '姓名',
  `dept_id` bigint(20) unsigned NOT NULL DEFAULT '0' COMMENT '部门id',
  `age` smallint(6) unsigned NOT NULL DEFAULT '0' COMMENT '年龄',
  `sex` bit(1) NOT NULL DEFAULT b'0' COMMENT '性别  0 男  1 女',
  `height` smallint(6) unsigned NOT NULL DEFAULT '0' COMMENT '身高',
  `money` decimal(10,2) NOT NULL DEFAULT '0.00' COMMENT '存款',
  `login_date` datetime DEFAULT NULL COMMENT '登陆时间',
  PRIMARY KEY (`id`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8;

/*Data for the table `tb_students_info` */

insert  into `tb_students_info`(`id`,`username`,`password`,`name`,`dept_id`,`age`,`sex`,`height`,`money`,`login_date`) values (3,'2019002','2019002','Henry',2,100,'',185,'0.00','2021-12-08 23:27:08'),(4,'2019003','2019003','Jane',1,22,'',162,'100.00','2021-12-08 23:27:44'),(5,'2019004','2019004','Jim',6,21,'\0',175,'50.00','2021-12-08 23:27:47'),(6,'2019005','2019005','John',5,25,'',172,'50.00','2021-12-04 23:27:52'),(7,'2019006','2019006','Lily',1,0,'\0',165,'0.00','2021-11-30 23:27:57'),(8,'2019007','2019007','Susan',1,20,'',170,'0.00','2021-11-02 23:28:01'),(9,'2019008','2019008','Thomas',4,35,'\0',178,'0.00','2021-12-03 23:28:06'),(10,'2019009','2019009','Tom',3,15,'',165,'0.00','2021-12-26 23:28:10'),(11,'2019010','2019010','Jerry',1,15,'\0',170,'0.00','2021-12-08 23:27:47'),(22,'2019012','2019012','王五',1,18,'\0',178,'0.00','2021-12-11 00:00:00'),(23,'2019012','2019012','王五',1,18,'\0',178,'100.00','2021-12-11 00:00:00'),(24,'2019012','2019012','王五',1,18,'\0',178,'100.00','2021-12-12 13:56:25');

```

实体类

```java
public class Student {
    private Long id;
    private String username;
    private String password;
    private String name;
    private Long deptId;
    private int age;
    private Boolean sex;
    private int height;
    private BigDecimal money;
    private LocalDateTime login_date;

    public Student() {
    }

    public Student(Long id, String username, String password, String name, Long deptId, int age, Boolean sex, int height, BigDecimal money, LocalDateTime login_date) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.name = name;
        this.deptId = deptId;
        this.age = age;
        this.sex = sex;
        this.height = height;
        this.money = money;
        this.login_date = login_date;
    }

    public BigDecimal getMoney() {
        return money;
    }

    public void setMoney(BigDecimal money) {
        this.money = money;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Long getDeptId() {
        return deptId;
    }

    public void setDeptId(Long deptId) {
        this.deptId = deptId;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Boolean getSex() {
        return sex;
    }

    public void setSex(Boolean sex) {
        this.sex = sex;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public LocalDateTime getLogin_date() {
        return login_date;
    }

    public void setLogin_date(LocalDateTime login_date) {
        this.login_date = login_date;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", name='" + name + '\'' +
                ", deptId=" + deptId +
                ", age=" + age +
                ", sex=" + sex +
                ", height=" + height +
                ", money=" + money +
                ", login_date=" + login_date +
                '}';
    }
}
```

**login.jsp**

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<form action="/student_system/login" method="post">
    用户名：<input type="text" name="username">
    密码：<input type="text" name="password">
    <input type="submit" value="登陆">
</form>
</body>
</html>
```

**请求代码:**

```java
@WebServlet("/login")
public class Login extends HttpServlet {
    private static final IStudentService studentService = new StudentServiceImpl();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.设置编码
        request.setCharacterEncoding("utf-8");
        response.setContentType("text/html;charset=utf-8");
        //2.获取请求参数
        String username = request.getParameter("username");
        String password = request.getParameter("password");
        if ("".equals(username) || "".equals(password) || username == null || password == null) {
            request.setAttribute("message", "fail");
            request.getRequestDispatcher("/login/fail.jsp").forward(request, response);
            return;
        }
        //3.查询数据库
        Student student = studentService.login(username, password);
        if (student == null) {
            request.setAttribute("message", "fail");
            request.getRequestDispatcher("/login/fail.jsp").forward(request, response);
        } else {
            //获取所有学生
            List<Student> allStundents = studentService.getAllStundents();
            request.setAttribute("message", allStundents);
//            //获取当前学生
//            request.setAttribute("message", student);
            request.getRequestDispatcher("/login/homepage.jsp").forward(request, response);
        }
    }

}
```

**homepage.jsp**

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
${message}

</body>
</html>
```

**fail.jsp**

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
${message}

</body>
</html>
```

### 参数传递优化（BeanUtils）

**问题：**

进行参数的共享时，我们是将每个参数对象先保存起来，再进行共享。那么问题来了，我们按照之前的共享的方式，一次只能保存一个数据，假如我有多个数据要传递呢？

**之前的方式**

```java
    //2.获取请求参数  并封装成对象    
	String username = request.getParameter("username");
  	String password = request.getParameter("password");
	User loginUser = new User(1, username, password);
```

**使用BeanUtils工具类**

1. 简化数据封装

   1. 引入BeanUtils下载网站：http://commons.apache.org/proper/commons-beanutils/

   2. 导入jar包

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image026.gif)

**注意：**commons-logging这个jar包一定要导入，作用：

![img](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/clip_image028.gif)

简单使用：

```java
@WebServlet("/add")
public class AddStudent extends HttpServlet {
    private static final IStudentService studentService = new StudentServiceImpl();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.设置编码
        request.setCharacterEncoding("utf-8");
        response.setContentType("text/html;charset=utf-8");
        //2.获取参数
        Map<String, String[]> parameterMap = request.getParameterMap();
        //3.创建空对象
        Student student = new Student();
        //4. 使用beanutils封装
        try {
            BeanUtils.populate(student, parameterMap);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        student.setDeptId(18L);
        student.setMoney(BigDecimal.valueOf(100.00));
        student.setSex(false);
        student.setLogin_date(LocalDateTime.now());
        int i = studentService.addStudent(student);
        if (i <= 0) {
            request.setAttribute("message", "插入失败");
            request.getRequestDispatcher("/login/fail.jsp").forward(request, response);
        } else {
            List<Student> allStudents = studentService.getAllStundents();
            request.setAttribute("message", allStudents);
            request.getRequestDispatcher("/login/homepage.jsp").forward(request, response);
        }
    }
}
```

### 扩展1：BeanUtils.工具类

简化数据封装用于封装JavaBean的

1. **JavaBean :标准的Java类**
   1. 要求:
      1. 类必须被public修饰
      2. 必须提供空参的构造器
      3. 成员变量必须使用private修饰
      4. 提供公共setter和getter方法
   2. 功能:封装数据

2. **概念:**

3. 成员变量:
   1. 属性: setter和getter方法截取后的产物
      1.  例如: getUsername() --> Username--> username
      2.  假如我有一个成员变量交name，但是他的set/get方法为getHisName，那么截取后的产物为hisName。hisName为属性，name为成员变量。但是大多数情况下，属性的成员变量的名称是一样的

4. **方法:**

5. setProperty( )。操作的是属性，而不是成员变量

```java
设置对象

1.成员变量gender  setSex/getSex

BeanUtils.setProperty(user,"gender","male");

System.out.println(user);   //  User{id=0, username='null', password='null', gender='null'}

BeanUtils.setProperty(user,"sex","male");

System.out.println(user);   //  User{id=0, username='null', password='null', gender='male'}

 

根据结果我们可以看出，成员变量gender，但他的set/get方法是sex。此时属性和成员变量不一样。

而setProperty( )操作的是属性，所以运行出来的结果不一样
```

2. getProperty( )

 ```java
//获取对象
 try {

   String genders = BeanUtils.getProperty(user, "sex");

   System.out.println(genders); male

 } catch (NoSuchMethodException e) {

   e.printStackTrace();

 }
 ```

3. populate(object obj，Map map) :将map集合的键值对信息,封装到对应的JavaBean对象中

 ```java
//A.1获取参数的map集合
Map<String, String[]> parameterMap = request.getParameterMap();
//A.2创建一个User对象
User loginUser = new User();
//A.3使用BeanUtils封装
try {
    BeanUtils.populate(loginUser,parameterMap);
} catch (IllegalAccessException e) {
    e.printStackTrace();
} catch (InvocationTargetException e) {
    e.printStackTrace();
}
 ```

### 扩展2：使用JdbcTemplate工具类

使用参考：[mystudy/Mysql备课课件/3. JDBC的基本使用.md · Zhang-HaoQi/Knowledge - 码云 - 开源中国 (gitee.com)](https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/Mysql备课课件/3. JDBC的基本使用.md)

```java
public class StudentDaoImpl implements IStudentDao {
    private JdbcTemplate template = new JdbcTemplate(DRUIDDateSource.getDataSource());

//获取一条学生数据
    @Override
    public Student login(String username, String password) {
        String sql = "SELECT * FROM tb_students_info WHERE username=? AND password=?";
        Student student = template.queryForObject(sql,new BeanPropertyRowMapper<Student>(Student.class),username,password);
        System.out.println(student);
        return student;
    }

    //获取所有学生
     @Override
    public List<Student> getAllStudent() {
        String sql = "SELECT * FROM tb_students_info ";
        List<Student> query = template.query(sql, new BeanPropertyRowMapper<Student>(Student.class));
        System.out.println(query);
        return query;
    }

    
    //添加学生
    @Override
    public int addStudent(Student student) {
        String sql = "INSERT INTO tb_students_info VALUE (?,?,?,?,?,?,?,?,?,?)";
        Date loginDate = new Date(Date.from(student.getLogin_date().atZone(ZoneOffset.ofHours(8)).toInstant()).getTime());
        int update = template.update(sql,
                null,
                student.getUsername(),
                student.getPassword(),
                student.getName(),
                student.getDeptId(),
                student.getAge(), student.getSex(), student.getHeight(), student.getMoney(), loginDate);
        return update;
    }
}
```

## 2.  验证码响应（response）

Servlet代码

```java
@WebServlet("/checkCodeServlet")
public class checkCodeServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
     //1.创建一个对象，在内存中存图片（验证码图片对象）
        int width =100;
        int height= 50;
        BufferedImage image  =new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);//宽，高，格式
     //2.美化图片
        //2.1化背景颜色
        Graphics graphics = image.getGraphics();//画笔对象
        graphics.setColor(Color.pink);//设置画笔颜色
        graphics.fillRect(0,0,width,height);//填充一个蓝色的矩形  填充的位置和大小
        //2.2画边框
        graphics.setColor(Color.BLUE);//设置颜色
        graphics.drawRect(0,0,width-1,height-1);//画边框
        //2.3写验证码
         String str ="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";  //验证码包含的所有字符数字
        Random random = new Random();//画验证码验证符
        for (int i = 1; i < 5; i++) {
            int s = random.nextInt(str.length());//随机获取字符串的角标，长度在字符串长度的范围内
            char c = str.charAt(s);//获取随机的字符
            graphics.drawString(c+"",i*20,25);//字符串的内容和位置
        }
        //2.4画干扰线
        graphics.setColor(Color.black);
        for (int i = 0; i < 10; i++) {
            int x1 = random.nextInt(100);
            int x2 = random.nextInt(100);
            int y1 = random.nextInt(50);
            int y2 = random.nextInt(50);
            graphics.drawLine(x1,y1,x2,y2);
        }

        //3.将图片输入到页面展示
        ImageIO.write(image,"jpg",response.getOutputStream());//输出对象，后缀名，输出流输出
            }
```

HTML代码

```java
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        window.onload = function () {
            //点击图片切换
            //获取图片
            let elementById = document.getElementById("img");
          //更改图片，其实就是更改图片的路径，因为我们的图片是随机生成的，所以只需要图片重新加载一次即可。
            elementById.onclick=function () {
                // elementById.src="/Response/checkCodeServlet";
                //这时你会发现点击图片没有变化，这是因为之前浏览器已经访问过这个路径了，此时路径的内容已经存储在了浏览器的内存中，所以访问的还是之前的图片
               // 解决措施：假意传参.   如果参数传入相同的值，那么就会造成只能切换一次。跟上面一个道理。所以要传一个随机的值
               //  elementById.src="/Response/checkCodeServlet?1";

                //因为随机数有时候也可能相同，所以遇到这种情况，我们可以通过把时间戳当做参数来解决。
               let date = new Date().getTime();
                elementById.src="/Response/checkCodeServlet?"+date;
                alert(data)
            }
            //点击文字切换
            let elementById1 = document.getElementById("change");
            elementById1.onclick=function () {
               let date = new Date().getTime();
                elementById.src="/Response/checkCodeServlet?"+date;
            }
        }
    </script>
</head>
<body>
<!--图片的点击切换-->
<img id="img" src="/Response/checkCodeServlet">
<a id="change">看不清，换一张</a>
</body>
</html>

```

## 3. 用户登陆（session）

记录用户信息

# 7. 问题汇总

## 1. WEB-INF资源问题

WEB-INF目录是不对外开放的，外部没办法直接访问到。所有只能通过映射来访问，比如映射为一个action或者servlet通过服务器端跳转来访问到具体的页面。这样可以限制访问，提高安全性。

### 1. 首页在WEB-INF下

通过xml设置欢迎页来解决。首页登陆页面。

```xml
正常登录页是首页，如果一定要放在webinf下面的话。xml中添加
<welcome-file-list>
    <welcome-file>/WEB-INF/view/Login.jsp</welcome-file>
</welcome-file-list>
```

### 2. 获取WEB-INF指定jsp文件

通过转发的形式获取

```java
@WebServlet("/forward/demo7")
public class ForwardDemo7 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.getRequestDispatcher("/WEB-INF/homepage.jsp").forward(req,resp);
    }
}
```



### 3. 静态资源在WEB-INF下

WEB-INF目录下文件访问资源文件时,可以忽略WEB-INF这一层目录.如index.jsp 要用css目录里的一个css文件.

```css
 <link rel="StyleSheet" href="../css/index.css" type="text/css" />这样就行了。
```

### 4. Tomcat项目Jar包问题

在使用Tomcat服务器进行开发的时候，如果需要使用第三方jar包，需要在WEB-INF下创建lib文件夹，将jar包复制进去，并右键add as library，否则可能在使用的时候出现类可以正常创建对象，但是使用报错情况。

![image-20211220160139056](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211220160139056.png)

 

 
