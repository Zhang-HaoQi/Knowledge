Maven

## 学习资料

[dependencyManagement：管理Maven依赖 (biancheng.net)](http://c.biancheng.net/maven2/dependency-management.html)

[Maven介绍 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1252599548343744/1309301146648610)

[文档合集 (ydlclass.com)](https://ydlclass.com/doc21xnv/frame/maven/#_1、基础配置)

[Maven 聚合工程的几个小细节 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247492149&idx=1&sn=e7280ca26fcd39da0493d86c873e78bd&scene=21#wechat_redirect)

## 一、项目构建

### 1. 项目的运行

**给你一套源代码，你怎么能跑起来？**

不能把！就是几个文件夹，几个文件。是不能运行的！

是不是需要和idea打交道，告诉idea怎么样才能运行起来，比如知道main方法在哪里？配置文件在哪里，编译好的文件输出到哪里，是不是？当然eclipse也一样。

**平时我们是怎么构建项目的，项目怎么运行起来呢？**

idea帮我们编译

我们依靠点击构建项目

一切设置好以后，使用工具（idea）帮我们打包

**项目构建中几个关键点?**

1、jdk啥版本

2、哪些文件夹是干啥的！！ 源文件？配置文件？测试文件？在哪里？

3、如果是web工程，web.xml放哪里？

4、编译文件，编译后的文件放在哪里。

5、打包，打包成什么文件

### 2. idea的项目结构Project Structure

“ 项目结构”对话框允许您管理项目和IDE级别的元素，例如Modules，Facets，Libraries， Artifacts和SDK。

![image-20220106111830603](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106111830603.png)

#### Project选项

指定项目名称，SDK，语言级别和编译器输出路径。

![image-20220106111802071](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106111802071.png)

- Project name：项目名，使用此字段编辑项目名称。

- Project SDK：项目SDK，选择项目SDK。如果所需SDK不在列表中，请单击“ New”，然后选择所需的SDK类型。然后，在打开的对话框中，选择SDK主目录，然后单击确定。要查看或编辑所选SDK的名称和内容，请单击"Edit"。（SDK页面将打开。）

- Project language level：选择要支持的Java语言级别。选定的级别将被用作项目默认值。

- Project compiler output：项目编译器输出，指定IntelliJ IDEA将存储编译结果的路径。单击选择路径对话框中browseButton 的目录。

  指定目录中的两个子目录将被创建： production为生产代码。 test为测试来源。 在这些子目录中，将为每个模块创建单独的输出目录。输出路径可以在模块级重新定义。

[(108条消息) Java SDK和Java JDK的区别_java_2017_csdn的博客-CSDN博客_jdk是sdk的一种](https://blog.csdn.net/java_2017_csdn/article/details/84333532)

#### Modules 选项

指定模块名称，idea是以项目和模块来构建项目，一个项目由多个模块组成。

![image-20220106112220056](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106112220056.png)

- Name：项目名称
- Souces：这里对Module的开发目录进行文件夹分类，就是说这个module里有什么内容，说明了不同性质的内容放在哪里。 注意，这些不同内容的标记代表了一个标准Java工程的各项内容，IntelliJ就是根据这些标记来识别一个Java工程的各项内容的，比如，它会用javac去编译标记为Sources的源码，打包的时候会把标记为Resources的资源拷贝到jar包中，并且忽略标记为Exluded的内容。左边显示的是在选中内容的预览。
- Paths：为模块配置编译器输出路径，还可以指定与模块关联的外部JavaDocs和外部注释的位置。
- Dependencies：在此选项卡上，您可以定义模块SDK并形成模块依赖关系列表。

##### Sources选项

![image-20220106112709114](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106112709114.png)

- Sources：源代码存放的文件，蓝色。
- Tests：设置测试代码存放的文件件，绿色。
- Resources：一般对应着Sources文件，一般放配置文件，如：db.properties。
- Test Resources：这个对应着Tests文件夹，存放着Tests代码的配置文件。
- Excluded：设置配出编译检查的文件，例如我们在project模块设置的out文件夹。

##### Paths选项

![image-20220106112444280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106112444280.png)

- Compiler output：编译输出路径。
- Inherit project compile output path：继承项目编译输出路径 选择此选项以使用为项目指定的路径。即上面在Project选项中设置的out文件路径。
- Use module compile output path:使用模块编译输出路径。
  -  Output path：编译输出路径。
  - Test output path：测试代码编译输出路径。
  - Exclude output paths： 排除输出路径，选中此复选框可以排除输出目录。

- JavaDoc：使用可用控件组合与模块关联的外部JavaDocs存储位置的列表。
- External Annotations：外部注释。使用![新](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/new.png) 和![删除](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/delete.png) 管理与模块关联的外部注释的位置（目录)列表。

##### Dependencies选项

![image-20220106112943409](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106112943409.png)

在此选项卡上，您可以定义模块SDK并形成模块依赖关系列表。

- Module SDK：模块SDK，选择模块SDK。

  （要将项目SDK与模块相关联，请选择Project SDK。请注意，如果稍后更改了项目SDK，模块SDK将相应更改。 如果所需SDK不在列表中，请单击“ 新建”，然后选择所需的SDK类型。然后，在打开的对话框中，选择SDK主目录，然后单击确定。 要查看或编辑所选SDK的名称和内容，请单击编辑。（SDK页面将打开。）

- 依赖列表

- 相关性存储格式，选择用于存储依赖关系的格式（作为IntelliJ IDEA模块或Eclipse项目）。该选项对使用不同开发工具的团队有帮助

- 注意：在此引入的jar依赖只能在本模块使用

#### Libraries选项

在此选项卡上，您可以定义模块SDK并形成模块依赖关系列表。

首先，可以创建一个新的项目库，可以设置分类。

![image-20220106113438761](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106113438761.png)

在此引入的jar包可以在整个项目工程下使用。

或者在WEB-INF的lib文件夹下创建lib，使用add as library 引入jar。

![image-20220106113534577](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106113534577.png)

#### Facts选项

表示这个 module 有什么特征，比如 Web，Spring 和 Hibernate 等；

![image-20220106120333983](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106120333983.png)

#### Artifacts选项

![image-20220106113723450](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106113723450.png)

- `Artifact` 是 maven 中的一个概念，表示某个 module 要如何打包，例如 war exploded、war、jar 等等这种打包形式； 一个 module 有了 Artifacts 就可以部署到应用服务器中了！
- 在给项目配置 Artifacts 的时候有好多个 type 的选项，exploed 是什么意思？explode 在这里你可以理解为展开，不压缩的意思。也就是 war、jar 等产出物没压缩前的目录结构。
- 建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。
- 默认情况下，IDEA 的 Modules 和 Artifacts 的 output 目录 已经设置好了，不需要更改.
- 打成 war 包 的时候会自动在 WEB-INF 目录 下生产 classes 目录 ，然后把编译后的文件放进去。

##### idea项目构建流程

[【2021就业班】maven精讲，通俗易懂_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Zo4y1o7Zx?p=2)

#### SDKS

系统开发工具 ，全局 SDK 配置 。

#### Global libraries

全局类库，可以配置一些常用的类库。

#### Problems

问题，在项目异常的时候很有用，可以根据提示进行项目修复（FIXED）。

#### .idea和.iml

**我们设置了半天看看我们设置的信息被保存在了哪里？**

这两个是idea的配置文件，我们上面配置的信息，都生成在了这两个文件夹中。这里面的内容通常是不作git提交的。

idea可以根据这两个文件，来构建我们的项目。

![image-20220106120142984](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106120142984.png)



## 二、Maven概述

以上的工作，需要我们自行构建，而且idea和eclipse，甚至一些其他的开发工具构建的时候是不一样的。

那么有没有一种统一的方式，甚至无需手动点击，通过配置就可以了，通过使用命令就能就行构建呢？

当然我们看到了我们的idea其实也是通过之文件来记录构建信息的，那么既然构建如此重要，形成一套规范化的，统一的便捷的构建工具就势在必行，于是出现了`maven`，当然还有`gradle`，他们的功能异常强大。

**好处**

- 统一管理jar包，自动导入jar及其依赖，这样是很初学者唯一能感受出来的好处，确实牛逼啊。
- 项目移植之后甚至不需要安装开发工具，只需要maven加命令就能跑起来，降低学习成本。
- 使我们的项目流水线成为可能，因为使用简单的命令我们就能完成项目的编译，打包，发布等工作，就让程序操作程序成为了可能，大名鼎鼎的jekins技能做到这一点。

### 1. Maven的下载安装

[(108条消息) Maven如何配置阿里镜像及安装全步骤_zhang19903848257的博客-CSDN博客_maven怎么配置阿里镜像](https://blog.csdn.net/zhang19903848257/article/details/107923791?spm=1001.2014.3001.5501)

### 2. Maven的标准目录

```maven
a-maven-project
src                                 
 |--main
     |--java         源代码目录
     |--resources    资源目录      
 |--test
     |--java         测试代码目录
     |--resources    测试资源目录
|--target
 |--classes      编译后的class文件目录
 |--test-classes 编译后的测试class文件目录
pom.xml             Maven工程配置文件
```

项目的根目录`a-maven-project`是项目名，它有一个项目描述文件`pom.xml`，存放Java源码的目录是`src/main/java`，存放资源文件的目录是`src/main/resources`，存放测试源码的目录是`src/test/java`，存放测试资源的目录是`src/test/resources`，最后，所有编译、打包生成的文件都放在`target`目录里。这些就是一个Maven项目的标准目录结构。

所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。

### 3. pom.xml的基本要求

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 	
         http://maven.apache.org/xsd/maven-4.0.0.xsd">

	<modelVersion>4.0.0</modelVersion>
	<groupId>com.itranswarp.learnjava</groupId>
	<artifactId>hello</artifactId>
	<version>1.0</version>
	<packaging>jar</packaging>
	<properties>
        ...
	</properties>
	<dependencies>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.2</version>
        </dependency>
	</dependencies>
   
</project>
```

其中，`groupId`类似于Java的包名，通常是公司或组织名称，`artifactId`类似于Java的类名，通常是项目名称，再加上`version`，一个Maven工程就是由`groupId`，`artifactId`和`version`作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。

依赖`commons-logging`：

```xml
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>1.2</version>
</dependency>
```

使用`<dependency>`声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。

### 4. Maven生命周期

maven生命周期其实就是描述了一个项目从源代码到部署的整个周期

![image-20220106121942932](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106121942932.png)

Maven有三个内置的生命周期：**默认（default），清洁（clean）和站点（site）**。

- 清洁（clean） 为执行以下工作做必要的清理。就是我们经常做的，删除target文件夹。
- 默认（default） 真正进行项目编译打包等工作的阶段
- 站点（site） 生成项目报告，站点，发布站点

> **默认（default）的生命周期包括以下阶段（该阶段经过简化，实际上更加复杂）：**

1. 验证（validate） - 验证项目是否正确，所有必要的信息可用。
2. **编译**（compile） - 编译项目的源代码。
3. 测试（test） - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署。
4. **打包**（package）- 采用编译的代码，并以其可分配格式（如JAR）进行打包。
5. 验证（verify） - 对集成测试的结果执行任何检查，以确保满足质量标准。
6. **安装**（install） - 将软件包安装到本地存储库中，用作本地其他项目的依赖项。
7. 部署（deploy） - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享（私服）。

```undefined
mvn install
```

此命令在执行安装之前按顺序（验证（validate），编译（compile），打包（package）等）执行每个默认生命周期阶段。在这种情况下，您只需要调用最后一个构建阶段来执行，安装（install）。

在构建环境中，使用以下调用将工件清理地构建并部署到共享存储库中。

```undefined
mvn clean deploy
```

相同的命令可以在多模块场景（即具有一个或多个子项目的项目）中使用。Maven遍历每个子项目并执行清洁（clean），然后执行部署（deploy）（包括所有之前的构建阶段步骤）。

**注意：在我们开发阶段，有一些生命周期的阶段，比如验证（validate）这些，基本很少用到。只要使用关键的几个基本能满足需求。**

### 5. Maven 常用命令

| 命令                   | 说明                                                   |
| ---------------------- | ------------------------------------------------------ |
| mvn –version           | 显示版本信息                                           |
| mvn clean              | 清理项目生产的临时文件,一般是模块下的target目录        |
| mvn compile            | 编译源代码，一般编译模块下的src/main/java目录          |
| mvn package            | 项目打包工具,会在模块下的target目录生成jar或war等文件  |
| mvn test               | 测试命令,或执行src/test/java/下junit的测试用例         |
| mvn install            | 将打包的jar/war文件复制到你的本地仓库中,供其他模块使用 |
| mvn deploy             | 将打包的文件发布到远程参考,提供其他人员进行下载依赖    |
| mvn site               | 生成项目相关信息的网站                                 |
| mvn dependency:tree    | 打印出项目的整个依赖树                                 |
| mvn archetype:generate | 创建Maven的普通java项目                                |
| mvn tomcat:run         | 在tomcat容器中运行web应用                              |

### 6. Maven的版本规范（我们的项目）

所有的软件都用版本

Maven使用如下几个要素来定位一个项目，因此它们又称为项目的坐标。

- `groudId` 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名开头。一般对应着JAVA的包的结构，例如org.apache。
- `artifactId` 单独项目的唯一标识符。比如我们的tomcat, commons等。不要在artifactId中包含点号(.)。
- `version` 项目的版本。
- `packaging` 项目的类型，默认是jar，描述了项目打包后的输出。类型为jar的项目产生一个JAR文件，类型为war的项目产生一个web应用。如果模块是根模块或者是公共模块，此处应该填写pom

```java
    <groupId>marchsoft</groupId>
    <artifactId>smpe-admin</artifactId>
    <packaging>pom</packaging>   
    <version>1.0.0-RELEASE</version>
```

Maven在版本管理时候可以使用几个特殊的字符串 SNAPSHOT，LATEST，RELEASE。比如"1.0-SNAPSHOT"。各个部分的含义和处理逻辑如下说明：

- `SNAPSHOT` 这个版本一般用于开发过程中，表示不稳定的版本。
- `LATEST` 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个snapshot版，具体看哪个时间最后。
- `RELEASE` 指最后一个发布版。

## 三、Maven依赖（重点）

**引入依赖**

maven管理依赖也就是jar包牛逼之处是不用我们自己下载，会从一些地方自动下载

- maven远程仓库: [https://mvnrepository.com/open in new window](https://mvnrepository.com/)
- maven远程仓库: https://maven.aliyun.com/mvn/search

maven工程中我们依靠在pom.xml文件进行配置完成jar包管理工作（依赖）

在工程中引入某个jar包，只需要在`pom.xml`中引入jar包的坐标，比如引入log4j的依赖：

```java
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.7</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

`Maven` 通过 `groupId`、 `artifactId` 与 `version` 三个向量来定位Maven仓库其jar包所在的位置，并把对应的jar包引入到工程中来。jar包会自动下载

**jar包下载流程**

![image-20220106122855148](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106122855148.png)

### 1. 依赖范围

#### classpath和打包

顾明思议，就是编译好的`class`文件所在的路径。

事实上，我们的类加载器（`classloader`）就是去对应的`classpath`中加在class二进制文件。

[java打jar包的几种方式详解 - jack_Meng - 博客园 (cnblogs.com)](https://www.cnblogs.com/mq0036/p/8566427.html#a11)

##### 普通java项目

![image-20220106125836375](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106125836375.png)

META-INF中有个文件，有以下内容，告诉jvm执行的时候去哪个类里找main方法。

普通的java工程类路径就是最外层的目录。

```java
Manifest-Version: 1.0
Created-By: 1.8.0_131 (Oracle Corporation)
Main-Class: Hello        //去这个类中找main方法
```

##### web项目

[(108条消息) idea在运行web项目时部署在tomcat的位置_XDarker的博客-CSDN博客_idea tomcat位置](https://blog.csdn.net/weixin_39723337/article/details/81234490)

通过日志可以查看web项目的部署路径。

![image-20220106151455468](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106151455468.png)

![image-20210119142224760](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20210119142224760.4aa4a2cd.png)

src目录下的配置文件会和class文件一样，自动copy到应用的 WEB-INF/classes目录下 ，所以普通jar包的类路径

就是根路径，没有资源，如果有配置文件也放在src目录下，他会同步打包在类路径下。

所以web项目的classpath是 `WEB-INF/classes`

![image-20220106154358659](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106154358659.png)

##### maven项目

maven工程会将`src/main/java` 和 `src/main/resources` 文件夹下的文件全部打包在classpath中。运行时他们两个的文件夹下的文件会被放在一个文件夹下。

maven 项目不同的阶段引入到classpath中的依赖是不同的，例如，

- `编译时`，maven 会将与编译相关的依赖引入classpath中
- `测试时`，maven会将测试相关的的依赖引入到classpath中
- `运行时`，maven会将与运行相关的依赖引入classpath中

而依赖范围就是用来控制依赖于这三种classpath的关系。

#### scope标签

scope标签就是依赖范围的配置

该项默认配置compile,可选配置还有test、provided、runtime、system、import。

其中compile、test和provided使用较多。

1. 有些jar包（如selvlet-api）运行时其实是不需要的，因为tomcat里有，但编译时是需要的，因为编译的时候没有tomcat环境
2. 有些jar只在测试的时候才能用到。比如junit，真是运行不需要的
3. 有些jar运行，测试时必须要有，编译时不需要，如jdbc驱动，编译时用的都是jdk中的接口，运行时我们才使用反射注册了驱动。

#### 编译依赖范围（compile）

**该范围就是默认依赖范围**，此依赖范围对于编译、测试、运行三种`classpath`都有效，举个简单的例子，假如项目中有`fastjson`的依赖，那么`fastjson`不管是在编译，测试，还是运行都会被用到，因此`fastjson`必须是编译范围（构件默认的是编译范围，所以依赖范围是编译范围的无须显示指定）

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.68</version>
</dependency>
```

#### 测试依赖范围(test)

使用此依赖范围的依赖，只对测试classpath有效，在编译主代码和项目运行时，都将无法使用该依赖，最典型的例子就是 Junit, 构件在测试时才需要，所以它的依赖范围是测试，因此它的依赖范围需要显示指定为、、<scope>test</scope>,当然不显示指定依赖范围也不会报错，但是该依赖会被加入到编译和运行的classpath中,造成不必要的浪费 。

```xml
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.7</version>
    <scope>test</scope>
</dependency>
```

#### 已提供依赖范围(provided)

使用该依赖范围的maven依赖，只对编译和测试的classpath有效，对运行的classpath无效，典型的例子就是servlet-api， 编译和测试该项目的时候需要该依赖，但是在运行时，web容器已经提供的该依赖，所以运行时就不再需要此依赖，如果不显示指定该依赖范围，并且容器依赖的版本和maven依赖的版本不一致的话，可能会引起版本冲突，造成不良影响。

```java
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
</dependency>
```

#### 运行时依赖范围(runtime)

使用该依赖范围的maven依赖，只对测试和运行的classpath有效，对编译的classpath无效，典型例子就是JDBC的驱动实现，项目主代码编译的时候只需要JDK提供的JDBC接口，只有在测试和运行的时候才需要实现上述接口的具体JDBC驱动。

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.25</version>
    <scope>runtime</scope>
</dependency> 
```

### 2. 依赖的传递

jar其实也是别人写的工程，他也会依赖其他的jar包，传递性让我们可以不用关系我们所依赖的jar他依赖了哪些jar，只要我们添加了依赖，他会自动将他所依赖的jar统统依赖进来。

![image-20220106155607355](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106155607355.png)

我们只需依赖A.jar，其他的会自动传递进来。

#### 依赖传递的原则

- **最短路径优先原则**：如果A依赖于B，B依赖于C，在B和C 中同时有log4j的依赖，并且这两个版本不一致，那么A会根据最短路径原则，在A中会传递过来B的log4j版本。

![image-20220106155737092](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106155737092.png)

- **路径相同先声明原则**：如果我们的工程同时依赖于B和A，B和C没有依赖关系，并且都有D的依赖，且版本不一致，那么会引入在pom.xml中先声明依赖的log4j版本。

![image-20220106155903547](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106155903547.png)

```xml
<dependency>
    <groupId>com.xinzi</groupId>
    <artifactId>B</artifactId>
    <version>1.2.3</version>
</dependency> 
<dependency>
    <groupId>com.xinzhi</groupId>
    <artifactId>A</artifactId>
    <version>1.3.2</version>
</dependency> 
```

因为1.2.3先声明，所以使用。

不同版本的jar选一个会导致一个问题，1.3.2版本高，A.jar可能用到了高版本的一些新的方法，此时因为某些原因系统选择了低版本，就会导致A.jar报错，无法运行。那么就要想办法把低版本排除掉，一般高版本会兼容低版本。

### 3、依赖的排除

结合上个例子，我们想把低版本的D.jar排除了，就可以这样做，这样系统就只能依赖高版本

```java
<dependencies>
    <dependency>
        <groupId>com.xinzi</groupId>
        <artifactId>B</artifactId>
        <version>1.2.3</version>
    //排除低版本
        <exclusions>
            <exclusion>
                <artifactId>com.xinzhi</artifactId>
                <groupId>D</groupId>
            </exlcusion>
        </exclusions>
    </dependency> 
    <dependency>
        <groupId>com.xinzhi</groupId>
        <artifactId>A</artifactId>
        <version>1.3.2</version>
    </dependency> 
</dependencies>
```

### 4、聚合和继承

[Maven 聚合工程的几个小细节 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247492149&idx=1&sn=e7280ca26fcd39da0493d86c873e78bd&scene=21#wechat_redirect)

[闲扯Maven项目代码组织形式 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247494927&idx=1&sn=d6d1637f1df6a4a9338c7944c5f727bb&scene=21#wechat_redirect)

源码见maven

**聚合模块（父模块）的打包方式必须为pom，否则无法完成构建**。

在聚合多个项目时，如果这些被聚合的项目中需**要引入相同的Jar，那么可以将这些Jar写入父pom中**，**各个子项目继承该pom即可**。，**父模块的打包方式必须为pom**，否则无法构建项目。

通过在各个子模块中配置来表明其继承与哪一个父模块：

```xml
<parent>
    <artifactId>parent</artifactId>
    <groupId>org.example</groupId>
    <version>1.0-SNAPSHOT</version>
</parent>
<modelVersion>4.0.0</modelVersion>

<artifactId>childern-two</artifactId>
```

可以被继承的POM元素如下：

- **groupId**：项目组ID，项目坐标的核心元素
- **version**：项目版本，项目坐标的核心因素
- properties：自定义的Maven属性 一般用于同一制定各个依赖的版本号
- dependencies：项目的依赖配置 公共的依赖
- dependencyManagement：项目的依赖管理配置
- repositories：项目的仓库配置
- build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等

一些对项目的描述

- description：项目的描述信息
- organization：项目的组织信息
- inceptionYear：项目的创始年份
- url：项目的URL地址
- developers：项目的开发者信息
- contributors：项目的贡献者信息
- distributionManagement：项目的部署配置
- issueManagement：项目的缺陷跟踪系统信息
- ciManagement：项目的持续集成系统信息
- scm：项目的版本控制系统
- malilingLists：项目的邮件列表信息
- reporting：包括项目的报告输出目录配置、报告插件配置等



#### 多模块项目创建

![image-20220106163541291](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106163541291.png)

##### 1. 创建工程parent

1. 删除parent的src文件夹，之后代码都写在子模块中

2. 生成的pom

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>parent</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

</project>
```

##### 2. 创建子模块son1

1. 在parent上新建模块

   ![image-20220106164146894](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106164146894.png)

2. 选择依赖的父工程

   ![image-20220106164241335](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106164241335.png)

3. 自动生成的pom

   ![image-20220106164539245](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106164539245.png)

##### 3. 创建子模块son2和son3

##### 4. 父工程的pom

1. 创建两个模块后，父工程的pom中引入了三个子模块的module
2. 并且父工程的打包方式变为了pom

![image-20220106165217526](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106165217526.png)

##### 5. 创建son3的子工程

1. 注意：此处选择的parent是son3

![image-20220106165322276](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106165322276.png)

2. 删除src目录

![image-20220106165443836](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106165443836.png)

同理：

son3的pom的中引入模块grand-son，并且打包方式变为pom

grand-son引入son3的partent信息。

**maven结构**

![image-20220106165917601](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106165917601.png)

##### 6. 子模块使用父模块依赖

parent中引入hutool依赖，在son1中使用。

```xml
    <dependencies>
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>5.7.18</version>
              <!-- 设置  依赖是否可选，默认为false,即子项目默认都继承。如果为true,
                 则子项目必需显示的引入  -->
            <optional>false</optional>
        </dependency>
    </dependencies>
```

son1中的测试，可以正常使用。

```java
package com.parent;
import cn.hutool.core.util.StrUtil;
public class Hello {
    public static void main(String[] args) {
        System.out.println(StrUtil.isNotEmpty(""));
    }
}

```

可以直接使用父模块的原因   <optional>false</optional> 没有这句话默认为false

##### 7. 子模块间相互调用  

1. 删除parent中的hutool的pom，并将pom放在son2的模块下，在son1中使用。
2. 在son2中创建User类，在son1中调用。

![image-20220106170939258](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106170939258.png)



**在son1中引入son2模块**

将son2模块以依赖的形式在son1中引入

```xml
    <dependencies>
        <dependency>
            <groupId>org.example</groupId>
            <artifactId>son2</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
```

效果：可以在son1中正常使用son2的内容。

![image-20220106171158517](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106171158517.png)

## 四、POM文件

### 1、基础配置

一个典型的pom.xml文件配置如下：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <!-- 模型版本。必须是这样写，现在是maven唯一支持的版本 -->
    <modelVersion>4.0.0</modelVersion>
    <!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.xinzhi，maven会将该项目打成的jar包放本地路径：/com/xinzhi/ -->
    <groupId>com.xinzhi</groupId>
    <!-- 本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 -->
    <artifactId>test</artifactId>
    <!-- 本项目目前所处的版本号 -->
    <version>1.0.0-SNAPSHOT</version>
    
    <!-- 打包的机制，如pom,jar,  war，默认为jar -->
    <packaging>jar</packaging>

    <!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：${file.encoding} -->
    <!-- 常常用来整体控制一些依赖的版本号 -->
    <properties>
        <file.encoding>UTF-8</file.encoding>
        <java.source.version>1.8</java.source.version>
        <java.target.version>1.8</java.target.version>
    </properties>
    

    <!-- 定义本项目的依赖关系，就是依赖的jar包 -->
    <dependencies>
        <!-- 每个dependency都对应这一个jar包 -->
        <dependency>
            <!--一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件， 然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库），--> 
            <!--就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入， maven就会把你上传的jar包下载到他的本地 -->
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>

            <!-- 依赖范围 -->
            <scope>complie</scope>
            <!-- 设置  依赖是否可选，默认为false,即子项目默认都继承。如果为true,
                 则子项目必需显示的引入  -->
            <optional>false</optional>
            
            <!-- 依赖排除-->
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-api</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>

    ...
</project>
```

上面的几个配置项对任何项目都是必不可少的，定义了项目的基本属性。

#### properties

使用properties来约束依赖版本的使用。便于依赖的统一管理。

![image-20220106173540446](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220106173540446.png)

#### dependencyManagement（重要）

**dependencies**

子模块可以通过继承获得父模块中声明的全部依赖，这样虽然避免了在各个子模块 POM 中重复进行依赖声明，但也极有可能造成子模块中引入一些不必要的依赖

- 即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）。
- 继承下来就会被编译，如果子项目根本不用这个依赖会增加子工程的负担。

**dependencyManagement：**通常会在父工程中定义，目的是统一各个子模块的依赖版本，不会实际引入到模块中。

- 在该元素下声明的依赖不会实际引入到模块中，只有在 dependencies 元素下同样声明了该依赖，才会引入到相应模块中。
- 该元素能够约束 dependencies 下依赖的使用，即 dependencies 声明的依赖若未指定版本，则使用 dependencyManagement 中指定的版本，否则将覆盖 dependencyManagement 中的版本。

[dependencyManagement：管理Maven依赖 (biancheng.net)](http://c.biancheng.net/maven2/dependency-management.html)

### 2、 构建配置

idea构建项目时，所配置的一些信息，这些信息正常都不需要配置，使用默认配置即可。

配置的信息有：打包后的包名称，源代码文件所在目录，资源（resource）文件所在目录等，除了finalName，其他的使用默认的即可。

```xml
<build>
        <!--产生的构件的文件名，默认值是${artifactId}-${version}。-->
        <finalName>myPorjectName</finalName>
    
        <!--I构建产生的所有文件存放的目录,默认为${basedir}/target，即项目根目录下的target -->
        <directory>s{basedir}/out</directory>
    
    
        <!--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。-→>
        <!--项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom .xm1的相对路径。-->
        <sourceDirectory>${basedir}\src\main\java</sourceDirectory>
    
        <!--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom .xm1的相对路径。-->
        <testSourceDirectory>${basedir}\src\test\java</testSourceDirectory>
    
    <!-- 产生的构件的文件名，默认值是${artifactId}-${version}。 -->
    <finalNasourceDirectory>${basedir}\src\main\java</sourceDirectory>

    <!--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->
    
    <outputDirectory>${basedir}\target\classes</outputDirectory>

    <!--被编译过的测试class文件存放的目录。 -->
    <testOutputDirectory>${basedir}\target\test-classes
    </testOutputDirectory>
    <!-- 以上配置都有默认值，就是约定好了目录就这么建 -->
    
    <resources>
         <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
    </resources>

    <!--单元测试相关的所有资源路径，配制方法与resources类似 -->
    <testResources>
        <testResource>
            <targetPath />
            <filtering />
            <directory />
            <includes />
            <excludes />
        </testResource>
    </testResources>

    <!--使用的插件列表 。 -->
    <plugins>
        <plugin>
		...具体在插件使用中了解
        </plugin>
    </plugins>

    <!--主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement， -->
    <!--所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 -->
    <!--给定插件的任何本地配置都会覆盖这里的配置 -->
    <pluginManagement>
        <plugins>...</plugins>
    </pluginManagement>

</build>
```

#### 资源所在文件配置

在maven项目中，我们的资源文件都默认放在了resource目录下，如果想要切换目录，比如放在java目录下，需要手动配置。建议不配，这样配置过后，java和resource目录下都可以放资源文件。

```xml
<!-- 处理资源被过滤问题 -->
<build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
    </resources>
</build>
```

#### 添加本地jar包

本地jar，如：支付宝jar包放到 src/main/webapp/WEB-INF/lib 文件夹下，如果没有配置，本地没问题，但是线上会找不到sdk类，为什么要引入，因为支付宝jar包再中央仓库没有。

```xml
<!-- geelynote maven的核心插件之-complier插件默认只支持编译Java 1.4，因此需要加上支持高版本jre的配置，在pom.xml里面加上 增加编译插 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <source>1.8</source>
        <target>1.8</target>
        <encoding>UTF-8</encoding>
        <compilerArguments>
            <!-- 本地jar，支付宝jar包放到  src/main/webapp/WEB-INF/lib 文件夹下，
           如果没有配置，本地没问题，但是线上会找不到sdk类
           为什么要引入，因为支付宝jar包再中央仓库没有，再比如oracle连接驱动的jar
        -->
            <extdirs>${project.basedir}/src/main/webapp/WEB-INF/lib</extdirs>
        </compilerArguments>
    </configuration>
</plugin>
```

### 3、仓库配置

```xml
<repositories>
    <repository>
        <id>alimaven</id>
        <name>aliyun maven</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
</repositories>
```

pom.xml里面的仓库与setting.xml里的仓库功能是一样的。主要的区别在于，pom里的仓库是个性化的。比如一家大公司里的setting文件是公用的，所有项目都用一个setting文件，但各个子项目却会引用不同的第三方库，所以就需要在pom.xml里设置自己需要的仓库地址。

###  4、多环境配置

```xml
<profiles>
        <profile>
            <id>dev</id>
            <build>
                <finalName>dev</finalName>
            </build>
            <repositories>
                <repository>
                    <id>ali</id>
                    <name>ali repo</name>
                    <url>https://maven.aliyun.com/repository/central</url>
                    <releases>
                        <enabled>true</enabled>
                    </releases>
                    <snapshots>
                        <enabled>true</enabled>
                    </snapshots>
                </repository>
            </repositories>
        </profile>
        <profile>
            <id>test</id>
            <build>
                <finalName>test</finalName>
            </build>
            <repositories>
                <repository>
                    <id>ali</id>
                    <name>ali repo</name>
                    <url>https://mirrors.huaweicloud.com/repository/maven/</url>
                    <releases>
                        <enabled>true</enabled>
                    </releases>
                    <snapshots>
                        <enabled>true</enabled>
                    </snapshots>
                </repository>
            </repositories>
        </profile>
        <profile>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
            <id>pro</id>
            <build>
                <finalName>pro</finalName>
            </build>
        </profile>
    </profiles>
```

### 5、项目信息配置（知道）

```java
<!--项目的名称, Maven产生的文档用 -->
<name>banseon-maven </name>

<!--项目主页的URL, Maven产生的文档用 -->
<url>http://www.clf.com/ </url>

<!--项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时 -->
<!--（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签），不鼓励使用纯文本描述。 -->
<!-- 如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 -->
<description>A maven project to study maven. </description>


<!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 -->
<inceptionYear />

<!--项目开发者列表 -->
<developers>

    <!--某个项目开发者的信息 -->
    <developer>
        <!--SCM里项目开发者的唯一标识符 -->
        <id> HELLO WORLD </id>
        <!--项目开发者的全名 -->
        <name> banseon </name>
        <!--项目开发者的email -->
        <email> banseon@126.com</email>
        <!--项目开发者的主页的URL -->
        <url />
        <!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 -->
        <roles>
            <role> Project Manager</role>
            <role>Architect </role>
        </roles>
        <!--项目开发者所属组织 -->
        <organization> demo</organization>
        <!--项目开发者所属组织的URL -->
        <organizationUrl>http://hi.clf.com/ </organizationUrl>
        <!--项目开发者属性，如即时消息如何处理等 -->
        <properties>
            <dept> No </dept>
        </properties>
        <!--项目开发者所在时区， -11到12范围内的整数。 -->
        <timezone> -5</timezone>
    </developer>

</developers>

<!--项目的其他贡献者列表 -->
<contributors>

    <!--项目的其他贡献者。参见developers/developer元素 -->
    <contributor>
        <name />
        <email />
        <url />
        <organization />
        <organizationUrl />
        <roles />
        <timezone />
        <properties />
    </contributor>

</contributors>

<!--该元素描述了项目所有License列表。应该只列出该项目的license列表，不要列出依赖项目的license列表。 -->
<!--如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 -->
<licenses>

    <!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 -->
    <license>

        <!--license用于法律上的名称 -->
        <name> Apache 2 </name>
        <!--官方的license正文页面的URL -->
        <url>http://www.clf.com/LICENSE-2.0.txt </url>
        <!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 -->
        <distribution> repo</distribution>
        <!--关于license的补充信息 -->
        <comments> Abusiness-friendly OSS license </comments>
    </license>

</licenses>



...还有很多
```

还有一些可以了解的不常用的配置如报表配置、问题管理配置、项目集成配置、profile配置

## 五、Maven仓库

详情见文档(含maven私服)：[文档合集 (ydlclass.com)](https://ydlclass.com/doc21xnv/frame/maven/#五、maven仓库)

视频：[【2021就业班】maven精讲，通俗易懂_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Zo4y1o7Zx?p=30)

```xml
仓库地址   
<repositories>
        <repository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
        </repository>
    </repositories>
插件仓库
    <pluginRepositories>
        <pluginRepository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>
```



## 六、Maven插件

### 1、Maven 插件介绍

Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：

- 打包jar 文件
- 创建 war 文件
- 编译代码文件
- 代码单元测试
- 创建工程文档
- 创建工程报告

插件通常提供了一个目标的集合，并且可以使用下面的语法执行：

```css
mvn [plugin-name]:[goal-name]
```

例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令：

```css
mvn compiler:compile
```

###  2、maven-compiler-plugin

#### jdk版本插件

设置maven编译的jdk版本，maven3默认用jdk1.5，maven2默认用jdk1.3

```xml
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <source>1.8</source> <!-- 源代码使用的JDK版本 -->
                    <target>1.8</target> <!-- 需要生成的目标class文件的编译版本 -->
                    <encoding>UTF-8</encoding><!-- 字符集编码 -->
                </configuration>
            </plugin>
        </plugins>
    </build>

```

#### jar包插件

- maven-jar-plugin，默认的打包插件，用来打普通的project JAR包；
- maven-shade-plugin，用来打可执行JAR包，也就是所谓的fat JAR包；
- maven-assembly-plugin，支持自定义的打包结构，也可以定制依赖项等。

我们日常使用的以maven-assembly-plugin为最多，因为大数据项目中往往有很多shell脚本、SQL脚本、.properties及.xml配置项等，采用assembly插件可以让输出的结构清晰而标准化。

```xml
<build>
    <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-assembly-plugin</artifactId>
                    <version>3.3.0</version>
                    <executions>
                        <execution>
                            <id>make-assembly</id>
                            <!-- 绑定到package生命周期 -->
                            <phase>package</phase>
                            <goals>
                                <!-- 只运行一次 -->
                                <goal>single</goal>
                            </goals>
                        </execution>
                    </executions>
                    <configuration>
                        <archive>
                            <manifest>
                                <addClasspath>true</addClasspath>
                                //最重要的，运行文件的main方法所在类
                                <mainClass>com.parent.Hello</mainClass> <!-- 你的主类名 -->
                            </manifest>
                        </archive>

                        <descriptorRefs>
                            <descriptorRef>jar-with-dependencies</descriptorRef>
                        </descriptorRefs>
                    </configuration>
                </plugin>
    </plugins>
</build>
```

#### war包

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <configuration>
        <warName>test</warName>
        <webResources>
            <resource>
                <directory>src/main/webapp/WEB-INF</directory>
                <filtering>true</filtering>
                <targetPath>WEB-INF</targetPath>
                <includes>
                    <include>web.xml</include>
                </includes>
            </resource>
        </webResources>
    </configuration>
</plugin>
```

## 七、 构建项目

### web项目

源码见maven

1. 设置打包格式，设置为war包（一定要设置，否则tomcat运行不了）

   ```xml
       <packaging>war</packaging>
   ```

2. 编写项目相关信息

   ```xml
   <groupId>org.example</groupId>
   <artifactId>web-pro</artifactId>
   <version>1.0-SNAPSHOT</version>
   ```

3. 引入servlet等相关依赖

   ```xml
   <dependencies>
       <dependency>
           <groupId>javax.servlet</groupId>
           <artifactId>javax.servlet-api</artifactId>
           <version>3.1.0</version>
           <scope>provided</scope>
       </dependency>
   </dependencies>
   ```

4. 配置资源目录（配不配都行，配的话能识别java目录下的配置文件信息，正常都在resource目录下）

   ```xml
    <build>
           <resources>
               <resource>
                   <directory>src/main/java</directory>
                   <includes>
                       <include>**/*.properties</include>
                       <include>**/*.xml</include>
                   </includes>
                   <filtering>false</filtering>
               </resource>
               <resource>
                   <directory>src/main/resources</directory>
                   <includes>
                       <include>**/*.properties</include>
                       <include>**/*.xml</include>
                   </includes>
                   <filtering>false</filtering>
               </resource>
           </resources>
       </build>
   ```

6. 引入相关插件

   1. jdk插件(必配)

      ```xml
       		<plugins>
                  <plugin>
                      <groupId>org.apache.maven.plugins</groupId>
                      <artifactId>maven-compiler-plugin</artifactId>
                      <version>3.1</version>
                      <configuration>
                          <source>1.8</source> <!-- 源代码使用的JDK版本 -->
                          <target>1.8</target> <!-- 需要生成的目标class文件的编译版本 -->
                          <encoding>UTF-8</encoding><!-- 字符集编码 -->
                      </configuration>
                  </plugin>
              </plugins>
      ```

   2. tomcat插件（有无都行）

      ```xml
      <plugin>
          <groupId>org.apache.tomcat.maven</groupId>
          <artifactId>tomcat8-maven-plugin</artifactId>
          <version>2.2</version>
          <configuration>
              <port>8080</port>
              <uriEncoding>UTF-8</uriEncoding>
              <path>/mavenpro</path>
              <finalName>web-pro</finalName>
          </configuration>
      </plugin>
      ```

   3. war包打包插件

      ```xml
      <!--            war包打包插件-->
                  <plugin>
                      <groupId>org.apache.maven.plugins</groupId>
                      <artifactId>maven-war-plugin</artifactId>
                      <configuration>
                          <warName>test</warName>
                          <webResources>
                              <resource>
                                  <directory>src/main/webapp/WEB-INF</directory>
                                  <filtering>true</filtering>
                                  <targetPath>WEB-INF</targetPath>
                                  <includes>
                                      <include>web.xml</include>
                                  </includes>
                              </resource>
                          </webResources>
                      </configuration>
                  </plugin>
      ```

   7. 必要的情况下，可以配置maven仓库地址，看实际业务要求吧。

      ```java
          <repositories>
              <repository>
                  <id>public</id>
                  <name>aliyun nexus</name>
                  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
                  <releases>
                      <enabled>true</enabled>
                  </releases>
              </repository>
          </repositories>
      
          <pluginRepositories>
              <pluginRepository>
                  <id>public</id>
                  <name>aliyun nexus</name>
                  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
                  <releases>
                      <enabled>true</enabled>
                  </releases>
                  <snapshots>
                      <enabled>false</enabled>
                  </snapshots>
              </pluginRepository>
          </pluginRepositories>
      
      ```

      

**pom文件**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>web-pro</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>


    <dependencies>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <!-- 处理资源被过滤问题 -->
    <build>
        <!--        资源配置目录-->
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
        <plugins>
            <!--   jdk相关插件-->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <source>1.8</source> <!-- 源代码使用的JDK版本 -->
                    <target>1.8</target> <!-- 需要生成的目标class文件的编译版本 -->
                    <encoding>UTF-8</encoding><!-- 字符集编码 -->
                </configuration>
            </plugin>

            <!--            tomcat插件-->
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.2</version>
                <configuration>
                    <port>8088</port>
                    <uriEncoding>UTF-8</uriEncoding>
                    <path>/mavenpro</path>
                    <finalName>web-pro</finalName>
                </configuration>
            </plugin>
            <!--            war包打包插件-->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-war-plugin</artifactId>
                <configuration>
                    <warName>test</warName>
                    <webResources>
                        <resource>
                            <directory>src/main/webapp/WEB-INF</directory>
                            <filtering>true</filtering>
                            <targetPath>WEB-INF</targetPath>
                            <includes>
                                <include>web.xml</include>
                            </includes>
                        </resource>
                    </webResources>
                </configuration>
            </plugin>
        </plugins>


    </build>
    <repositories>
        <repository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
        </repository>
    </repositories>

    <pluginRepositories>
        <pluginRepository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>


</project>
```

