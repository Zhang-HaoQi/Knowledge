

# 1.1 数组/链表s 

数组链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。

数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快 慢指针。 

[#链表双指针系列 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2120596033251475465)

[#数组双指针 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2120601117519675393)

此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。

## 前缀和

前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。

### 基础

1. 前缀和：nums 的第 0 项到 当前项 的和。
2. 定义 prefixSum 数组，prefixSum[x]：第 0 项到 第 x 项 的和。
   prefixSum[x] = nums[0] + nums[1] +…+nums[x]
   prefixSum[x]=nums[0]+nums[1]+…+nums[x]
3. nums 的某项 = 两个相邻前缀和的差：
   nums[x] = prefixSum[x] - prefixSum[x - 1]
   nums[x]=prefixSum[x]−prefixSum[x−1]
4. nums 的 第 i 到 j 项 的和，有：
   nums[i] +…+nums[j]=prefixSum[j] - prefixSum[i - 1]
   nums[i]+…+nums[j]=prefixSum[j]−prefixSum[i−1]
5. 当 i 为 0，此时 i-1 为 -1，我们故意让 prefixSum[-1] 为 0，使得通式在i=0时也成立：
   nums[0] +…+nums[j]=prefixSum[j]
   nums[0]+…+nums[j]=prefixSum[j]

**前置数组初始化**

![image-20220111113457280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111113457280.png)

前缀和数组多了一个空间，存储0，目的就是为了适配nums[i]+…+nums[j]=prefixSum[j]−prefixSum[i−1]这个公式。

preSum默认从索引1处开始赋值，preSum[0]默认为0；

**指定索引处的值累加**

如获取原始数组索引2到5的值。

```java
preSum[6] - this.preSum[2];
```

### 模板

```java
class NumArray02 {

    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }

}

```

![image-20220111160631693](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111160631693.png)

preSum[i] 就代表着 nums[0..i-1] 所有元素的累加和，如果我们想求区间 nums[i..j] 的累加和，只要 计算 preSum[j+1] - preSum[i] 即可，⽽不需要遍历整个区间求和。



### 练习

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

方式一：使用for循环遍历，通过累加获取结果

```java
//方式一：for循环遍历，时间复杂度为O（N）
class NumArray01 {

    private int[] nums;

    public NumArray01(int[] nums) {
        this.nums = nums;
    }

    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}
```

方式二：使用数组的前缀和

```java
//方式二：前缀和，时间复杂度为O（1）
class NumArray02 {

    //方式二：
    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }

}
```

#### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

参考题解：[从暴力法开始优化 「二维前缀和」做了什么事 | leetcode.304 - 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qian-zhui-he-jian-dan-tui-dao-tu-sqekv/)

##### 方式一：一维前缀和

使用累加思想，将每一排数据进行累加，最后在指定区间内进行累加并相减。

![image-20220111114955276](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111114955276.png)

问题：最后累加时，查询 n 行的子阵列，每次就查询花费 O(n)*O*(*n*)，比 O(n^2)*O*(*n*2) 好

```java
class NumMatrix01 {
    private int[][] preMatrix;

    public NumMatrix01(int[][] matrix) {
        preMatrix = new int[matrix.length + 1][matrix[0].length + 1];
        for (int i = 1; i < preMatrix.length; i++) {
            for (int j = 1; j < preMatrix[0].length; j++) {
                preMatrix[i][j] = preMatrix[i][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        int result = 0;
        for (int i = row1; i <= row2; i++) {
            result += preMatrix[i + 1][col2 + 1] - preMatrix[i + 1][col1];
        }
        return result;
    }
}
```

##### 方式二：二维前缀和

**赋值操作**

二维前缀和指从0，0开始，到指定索引处，所形成的矩形空间的数值之和。

如：求1，1的前缀和。
（蓝色框前缀和3+0）+（红色框前缀和3+5）+当前位置元素6-（红蓝框相交3）=3+8+6-3=14

![image-20220111120446343](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111120446343.png)

**取某一范围内的元素值和**

如：取1，1——3，3之间的元素和。

![image-20220111152810871](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111152810871.png)

```java
class NumMatrix02 {
    private int[][] preMatrix;

    public NumMatrix02(int[][] nums) {
        preMatrix = new int[nums.length + 1][nums[0].length + 1];
        for (int i = 1; i < preMatrix.length; i++) {
            for (int j = 1; j < preMatrix[0].length; j++) {
                preMatrix[i][j] = preMatrix[i][j - 1]
                        + preMatrix[i - 1][j]
                        - preMatrix[i - 1][j - 1]
                        + nums[i - 1][j - 1];
            }
        }
    }
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return preMatrix[row2 + 1][col2 + 1]
                - preMatrix[row2 + 1][col1]
                - preMatrix[row1][col2 + 1]
                + preMatrix[row1][col1];
    }
}
```

#### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

##### 方式一：前缀和+双层for

时间复杂度为O（n^2）

![image-20220111153801420](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111153801420.png)

同理，假如k=13。 在前缀数组中。14-1=13.说明包含了一段连续的元素相加=13。对比到原始数组中就是子数组2+5+6。

```java
class Solution01 {
    public static int subarraySum(int[] nums, int k) {
		//获取前缀和数组
        int[] preSum = new int[nums.length + 1];
        for (int i = 1; i < preSum.length; i++)
            preSum[i] = preSum[i - 1] + nums[i - 1];
        //符合要求的元素数量
        int count = 0;
        //如果后续-前序=k，说明连续。符合要求
        for (int i = 1; i < preSum.length; i++) {
            for (int j = 0; j < i; j++) {
                if (preSum[i] - preSum[j] == k) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

##### 方式二：前缀和+map

时间复杂度为O（n）

题解：

[前缀和的运用，一步步优化 | 560. 和为K的子数组 - 和为 K 的子数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/)

视频讲解：

[LeetCode#560 和为K的子数组 | 前缀和 哈希表优化_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16K411W78r/?spm_id_from=333.788.recommend_more_video.1)

假如我们现在有两个前缀和4和6，并且这两个前缀分别出现了1次和0次。下一个前缀和是8，我们要求的k是4，8-4=4.即如果在前缀和8之前存在前缀和为4的前缀，那么我们就找到了符合要求的元素。前缀和为4的元素是存在的，并且有1个，现在又出现了一个符合要求的前缀和，因此符合要求的数量又添加了1。

在此，我们并不关心前缀和的位置，我们只关心前缀和的数量。

```java
class Solution02 {
    public static int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int preFixSum = 0;//记录前缀和
        int count = 0;//记录符合要求的数量
        for (int num : nums) {
            preFixSum += num;
            //判断之前是否有符合的前缀和，有的话count+=
            if (map.containsKey(preFixSum - k))
                count += map.get(preFixSum - k);
            //存入当前的前缀和入map，当前前缀和如果map中有则+1，没有则默认为1
            map.put(preFixSum, map.getOrDefault(preFixSum, 0) + 1);
        }
        return count;
    }
}
```



## 差分数组

差分数组的主要适⽤场景是频繁对原始数组的 某个区间的元素进⾏增减。

### 基础

⽐如说，我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给...

常规的思路:区间 nums[i..j] 加上 val⼀个 for 循环给它们都加上.这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改⾮常频繁，所以效率会很低下。

```java
 		 //需求：将nums的索引1-3的元素值都+1
        int[] nums = {8, 2, 6, 3, 1};
        //方法一：O（N）
        for (int i = 1; i <= 3; i++) {
            nums[i] += 1;
        }
```

这⾥就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造⼀个 diff 差 分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差：

**差分数组**

![image-20220112083326756](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220112083326756.png)

diff[1]=nums[1]-nums[0]

```java
       //需求：将nums的索引1-3的元素值都+1
        int[] nums = {8, 2, 6, 3, 1};
        //方法二：使用差分数组
        //1.将原数组转换为差分数组   即diff的某一项diff[i]，对应着nums的这一项nums[i]减去nums这一项他前一项的值nums[i-1]
        int[] diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
```

**差分数组还原**

通过差分数组推导出原数组。

![image-20220112084138048](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220112084138048.png)

res[1]=res[0]+diff[1]

```java
        int[] res = new int[diff.length];
        res[0] = diff[0];
        for (int i = 1; i < res.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
```

此时，如果我们给diff[1]+3。即-6变为-3，那么res[1]对应着也+了3，因为差分数组还原时，后一项的每一个res都依赖前一项的res的值，因此res[2],res[3]都对应着+3等等。

**差分数据累加**

如果，我们要求原数组索引1—3之间的元素都+3，其它索引位置元素不变。那么索引为4的元素以及4之后的元素因为受到了之前+3的影响，因此需要在diff索引为4的位置再-3，才能满足对应的要求。

![image-20220112085623419](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220112085623419.png)

diff[1]+3,diff[4]-3;

```java
    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j+1] -= val;
    }
```

注意：当j+1==diff.length时，如果j为数组的最后一个元素，不需要再减的操作。

### 模板

```java
//差分数组模板
class Difference {
    //差分数组
    private int[] diff;

    //初始化一个数组，区间操作在此数组上进行
    public void proDiff(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        //构建差分数组
        for (int i = 1; i < diff.length; i++)
            diff[i] = nums[i] - nums[i - 1];
    }

    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j + 1] -= val;
    }

    public int[] result() {
        int[] res = new int[diff.length];
        for (int i = 1; i < res.length; i++)
            res[i] = res[i - 1] + diff[i];
        return res;
    }

    //业务处理
    public int[] getModifiedArray(int length, int i, int j, int val) {
        int[] nums = new int[length];
        //形成差分数组
        proDiff(nums);
        //进行累加
        increment(i, j, val);
        //返回结果
        return result();
    }
}
```

### 练习

#### [1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)

套用模板即可

```java
class Solution01 {
    //差分数组
    private int[] diff;

    //初始化一个数组，区间操作在此数组上进行
    public void proDifference(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        //构建差分数组
        for (int i = 1; i < diff.length; i++)
            diff[i] = nums[i] - nums[i - 1];
    }

    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j+1] -= val;
    }

    //结果返回
    public int[] result() {
        int[] res = new int[diff.length];
        res[0] = diff[0];
        for (int i = 1; i < res.length; i++)
            res[i] = res[i - 1] + diff[i];
        return res;
    }

    //业务处理
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] nums = new int[n];
        proDifference(nums);
        for (int l = 0; l < bookings.length; l++) {
            int i = bookings[l][0];
            int j = bookings[l][1];
            int val = bookings[l][2];
            increment(i - 1, j-1, val);
        }
        return result();
    }

}
```

#### [待做：1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)

待定：
