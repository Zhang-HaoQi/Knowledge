# 1.1 数组/链表

数组链表代表着计算机最基本的两种存储形式：**顺序存储和链式存储**，所以他俩可以算是最基本的数据结构。

数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快 慢指针。 

[#链表双指针系列 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2120596033251475465)

[#数组双指针 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2120601117519675393)

此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。

## 前缀和

作图链接：https://www.processon.com/view/link/61e260db7d9c0806a8a8beec

### 引入前缀和

**使用场景：**原始数组不会被修改的情况下，频繁查询某个区间的累加和。

**例题：**

![image-20220115102016075](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115102016075.png)

如：求数组{1,2,5,6,-2,5,4} 中索引为1到索引为3的和。

**使用for循环累加**

```java
//方式一：for循环遍历，时间复杂度为O（N）
class NumArray01 {

    private int[] nums;

    public NumArray01(int[] nums) {
        this.nums = nums;
    }

    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}

   public static void main(String[] args) {
        int[] nums = {1,2,5,6,-2,5,4};
        NumArray01 NumArray01 = new NumArray01(nums);
        int i = numArray.sumRange(1, 3);
        System.out.println(i);
    }
```

问题：时间复杂度为O（n） 

思考：如果我能获取索引为3之前所有元素的和（包含3），又获取索引为1之前元素的所有和（不包含1），二者相减，不就获取到了索引为1到索引为3之间元素的和。

**改进，使用前缀和**

前缀和：nums 的第 0 项到当前项的和。

![image-20220111113457280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111113457280.png)

此时，如果我们要计算索引1-3所有元素之和。

可以使用preSum(4)-preSum(1）即可获得所求结果。

```java
//方式二：前缀和，时间复杂度为O（1）
class NumArray02 {

    //方式二：
    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }
}

    public static void main(String[] args) {
        int[] nums = {-2, 0, 3, -5, 2, -1};
        NumArray02 numArray02 = new NumArray02(nums);
        int i = numArray02.sumRange(1, 3);
        System.out.println(i);
    }
```

### 相应规则

1. 前缀和：nums 的第 0 项到 当前项 的和。
2. 定义 prefixSum 数组，prefixSum[x]：第 0 项到 第 x 项 的和。
   prefixSum[x] = nums[0] + nums[1] +…+nums[x]
   prefixSum[x]=nums[0]+nums[1]+…+nums[x]
3. nums 的某项 = 两个相邻前缀和的差：
   nums[x] = prefixSum[x] - prefixSum[x - 1]
   nums[x]=prefixSum[x]−prefixSum[x−1]
4. nums 的 第 i 到 j 项 的和，有：
   nums[i] +…+nums[j]=prefixSum[j] - prefixSum[i - 1]
   nums[i]+…+nums[j]=prefixSum[j]−prefixSum[i−1]
5. 当 i 为 0，此时 i-1 为 -1，我们故意让 prefixSum[-1] 为 0，使得通式在i=0时也成立：
   nums[0] +…+nums[j]=prefixSum[j]
   nums[0]+…+nums[j]=prefixSum[j]

**前置数组初始化**

![image-20220111113457280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111113457280.png)

前缀和数组多了一个空间，存储0，目的就是为了适配nums[i]+…+nums[j]=prefixSum[j]−prefixSum[i−1]这个公式。

preSum默认从索引1处开始赋值，preSum[0]默认为0；

**指定索引处的值累加**

如获取原始数组索引1到3的值。

```java
preSum[4] - this.preSum[1];
```

### 模板

```java
class NumArray02 {

    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }

}

```

preSum[i] 就代表着 nums[0..i-1] 所有元素的累加和，如果我们想求区间 nums[i..j] 的累加和，只要 计算 preSum[j+1] - preSum[i] 即可，⽽不需要遍历整个区间求和。

### 练习

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

![image-20220115105630680](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115105630680.png)

方式一：使用for循环遍历，通过累加获取结果

```java
//方式一：for循环遍历，时间复杂度为O（N）
class NumArray01 {

    private int[] nums;

    public NumArray01(int[] nums) {
        this.nums = nums;
    }

    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}
```

方式二：使用数组的前缀和

```java
//方式二：前缀和，时间复杂度为O（1）
class NumArray02 {

    //方式二：
    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }

}
```

#### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

参考题解：[从暴力法开始优化 「二维前缀和」做了什么事 | leetcode.304 - 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qian-zhui-he-jian-dan-tui-dao-tu-sqekv/)

![image-20220115105555785](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115105555785.png)

##### 方式一：一维前缀和

使用累加思想，将每一排数据进行累加，最后在指定区间内进行累加并相减。

![image-20220111114955276](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111114955276.png)

问题：最后累加时，查询 n 行的子阵列，每次就查询花费 O(n)，比 O(n^2) 好

```java
class NumMatrix01 {
    private int[][] preMatrix;

    public NumMatrix01(int[][] matrix) {
        preMatrix = new int[matrix.length + 1][matrix[0].length + 1];
        for (int i = 1; i < preMatrix.length; i++) {
            for (int j = 1; j < preMatrix[0].length; j++) {
                preMatrix[i][j] = preMatrix[i][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        int result = 0;
        for (int i = row1; i <= row2; i++) {
            result += preMatrix[i + 1][col2 + 1] - preMatrix[i + 1][col1];
        }
        return result;
    }
}
```

##### 方式二：二维前缀和

**赋值操作**

二维前缀和指从0，0开始，到指定索引处，所形成的矩形空间的数值之和。

如：求1，1的前缀和。
（蓝色框前缀和3+0）+（红色框前缀和3+5）+当前位置元素6-（红蓝框相交3）=3+8+6-3=14

![image-20220111120446343](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111120446343.png)

解析：

问：0,0这一块的面积是多少？

问：0,0到0,1这一块的面积是多少？

问：0,0到1,0这一块的面积是多少？

问：1,1这一块的面积是多少？

**取某一范围内的元素值和**

如：取1，1到3，3之间的元素和。

![image-20220111152810871](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111152810871.png)

```java
class NumMatrix02 {
    private int[][] preMatrix;

    public NumMatrix02(int[][] nums) {
        preMatrix = new int[nums.length + 1][nums[0].length + 1];
        for (int i = 1; i < preMatrix.length; i++) {
            for (int j = 1; j < preMatrix[0].length; j++) {
                preMatrix[i][j] = preMatrix[i][j - 1]
                        + preMatrix[i - 1][j]
                        - preMatrix[i - 1][j - 1]
                        + nums[i - 1][j - 1];
            }
        }
    }
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return preMatrix[row2 + 1][col2 + 1]
                - preMatrix[row2 + 1][col1]
                - preMatrix[row1][col2 + 1]
                + preMatrix[row1][col1];
    }
}
```

#### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

##### 方式一：前缀和+双层for

时间复杂度为O（n^2）

![image-20220111153801420](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111153801420.png)

同理，假如k=13。 在前缀数组中。14-1=13.说明包含了一段连续的元素相加=13。对比到原始数组中就是子数组2+5+6。

```java
class Solution01 {
    public static int subarraySum(int[] nums, int k) {
		//获取前缀和数组
        int[] preSum = new int[nums.length + 1];
        for (int i = 1; i < preSum.length; i++)
            preSum[i] = preSum[i - 1] + nums[i - 1];
        //符合要求的元素数量
        int count = 0;
        //如果后续-前序=k，说明连续。符合要求
        for (int i = 1; i < preSum.length; i++) {
            for (int j = 0; j < i; j++) {
                if (preSum[i] - preSum[j] == k) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

##### 方式二：前缀和+map

时间复杂度为O（n）

题解：

[前缀和的运用，一步步优化 | 560. 和为K的子数组 - 和为 K 的子数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/)

视频讲解：

[LeetCode#560 和为K的子数组 | 前缀和 哈希表优化_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16K411W78r/?spm_id_from=333.788.recommend_more_video.1)

假如我们现在有两个前缀和4和6，并且这两个前缀分别出现了1次和0次。下一个前缀和是8，我们要求的k是4，8-4=4.即如果在前缀和8之前存在前缀和为4的前缀，那么我们就找到了符合要求的元素。前缀和为4的元素是存在的，并且有1个，现在又出现了一个符合要求的前缀和，因此符合要求的数量又添加了1。

在此，我们并不关心前缀和的位置，我们只关心前缀和的数量。

```java
class Solution02 {
    public static int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int preFixSum = 0;//记录前缀和
        int count = 0;//记录符合要求的数量
        for (int num : nums) {
            preFixSum += num;
            //判断之前是否有符合的前缀和，有的话count+=
            if (map.containsKey(preFixSum - k))
                count += map.get(preFixSum - k);
            //存入当前的前缀和入map，当前前缀和如果map中有则+1，没有则默认为1
            map.put(preFixSum, map.getOrDefault(preFixSum, 0) + 1);
        }
        return count;
    }
}
```

## 差分数组

### 引入查分数组

**使用场景：**差分数组的主要适⽤场景是频繁对原始数组的 某个区间的元素进⾏增减。

**举例：**

⽐如说，我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给...

常规的思路:区间 nums[i..j] 加上 val⼀个 for 循环给它们都加上.这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改⾮常频繁，所以效率会很低下。

```java
 		 //需求：将nums的索引1-3的元素值都+1
        int[] nums = {8, 2, 6, 3, 1};
        //方法一：O（N）
        for (int i = 1; i <= 3; i++) {
            nums[i] += 1;
        }
```

这⾥就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造⼀个 diff 差 分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差：

**生成差分数组**

![image-20220112083326756](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220112083326756.png)

diff[1]=nums[1]-nums[0]

```java
       //需求：将nums的索引1-3的元素值都+1
        int[] nums = {8, 2, 6, 3, 1};
        //方法二：使用差分数组
        //1.将原数组转换为差分数组   即diff的某一项diff[i]，对应着nums的这一项nums[i]减去nums这一项他前一项的值nums[i-1]
        int[] diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
```

**差分数组还原**

**推导：**

推导diff与nums的关系

1. 推导1

   1. diff[0]=nums[0]
   2. 推导出：nums[0]=diff[0]

2. 推导2

   1. diff[1]=nums[1]-nums[0]

   2. 推导出：num[1]=diff[1]+nums[0]

3. 推导3

   1. diff[2]=nums[2]-nums[1]

   2. 推导出：nums[2]+diff[2]+nums[1];

4. 结论：nums[i]=diff[i]+nums[i-1];

通过差分数组推导出原数组。

![image-20220112084138048](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220112084138048.png)

res[1]=res[0]+diff[1]

```java
        int[] res = new int[diff.length];
        res[0] = diff[0];
        for (int i = 1; i < res.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
```

此时，如果我们给diff[1]+3。即-6变为-3，那么res[1]对应着也+了3，因为差分数组还原时，后一项的每一个res都依赖前一项的res的值，因此res[2],res[3]都对应着+3等等。

**差分数据累加**

如果，我们要求原数组索引1—3之间的元素都+3，其它索引位置元素不变。那么索引为4的元素以及4之后的元素因为受到了之前+3的影响，因此需要在diff索引为4的位置再-3，才能满足对应的要求。

![image-20220115114348763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115114348763.png)

![image-20220115114028348](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115114028348.png)diff[1]+3,diff[4]-3;

```java
    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j+1] -= val;
    }
```

注意：当j+1==diff.length时，如果j为数组的最后一个元素，不需要再减的操作。

### 模板

```java
//差分数组模板
class Difference {
    //差分数组
    private int[] diff;

    //初始化一个数组，区间操作在此数组上进行
    public void proDiff(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        //构建差分数组
        for (int i = 1; i < diff.length; i++)
            diff[i] = nums[i] - nums[i - 1];
    }

    //连续区间内，值的修改
    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j + 1] -= val;
    }

    //结果还原
    public int[] result() {
        int[] res = new int[diff.length];
        for (int i = 1; i < res.length; i++)
            res[i] = res[i - 1] + diff[i];
        return res;
    }

    //业务处理
    public int[] getModifiedArray(int length, int i, int j, int val) {
        int[] nums = new int[length];
        //形成差分数组
        proDiff(nums);
        //进行累加
        increment(i, j, val);
        //返回结果
        return result();
    }
}
```

### 练习

#### [1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)

![image-20220115114743692](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115114743692.png)

套用模板即可

```java
class Solution01 {
    //差分数组
    private int[] diff;

    //初始化一个数组，区间操作在此数组上进行
    public void proDifference(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        //构建差分数组
        for (int i = 1; i < diff.length; i++)
            diff[i] = nums[i] - nums[i - 1];
    }

    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j+1] -= val;
    }

    //结果返回
    public int[] result() {
        int[] res = new int[diff.length];
        res[0] = diff[0];
        for (int i = 1; i < res.length; i++)
            res[i] = res[i - 1] + diff[i];
        return res;
    }

    //业务处理
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] nums = new int[n];
        proDifference(nums);
        for (int l = 0; l < bookings.length; l++) {
            int i = bookings[l][0];
            int j = bookings[l][1];
            int val = bookings[l][2];
            increment(i - 1, j-1, val);
        }
        return result();
    }

}
```

#### [待做：1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)

## 滑动窗口

作图链接：https://www.processon.com/view/link/61e2608607912973ef267d5c

### 引入滑动窗口

**使用场景：**在主串中寻找子串

**举例：**

![image-20220115115603218](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115115603218.png)

分析：

我们的目的是找到主串中**最短**的子串，子串中包含目标串，不需要关注目标串中元素的**排列顺序**。因此，我们只需要找到主串中的某一个子串含有目标串的每个元素并且相等元素的数量一致切这个子串最短即可。

解析：

子串肯定有一个开始索引和结束索引。因此我们可以使用双指针分别表示子串的开始和结束索引。（即窗口的左右边界）

我们要保证子串中含有目标串，并且每个元素的数量一致，因此需要记录目标串元素的数量。（使用map或int记录元素数量）

可能有多个子串中包含目标串，因此我们需要一个长度变量来比较自创长度（即窗口的宽度）

**查找元素ABC**

1. 初始条件

   ![image-20220115132950497](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115132950497.png)

2. 找到第一个符合目标串的元素

   ![image-20220115133021255](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133021255.png)

3. 找到符合要求的目标串的子串

   ![image-20220115133238653](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133238653.png)

4. 缩短窗口的宽度，力争获取到最小符合要求的子串。

   ![image-20220115133331144](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133331144.png)

5. 此时，子串已经不符合要求，窗口向右移动，寻找下一个满足要求的子串。即寻找下一个A。

   ![image-20220115133544864](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133544864.png)

6. 窗口继续缩小，直到不符合要求。缩小的时候，是通过left的移动进行缩小。此时窗口长度还是6。不用改变。

   ![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115134048308.png)

7. 依次类推，直到最后一轮

   ![image-20220115133832818](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133832818.png)

```java
class Solution01 {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        //1.记录需要字串的数量
        Map<Character, Integer> tMap = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            tMap.put(t.charAt(i), tMap.getOrDefault(t.charAt(i), 0) + 1);
        }
        //2.窗口左边界，窗口右边界，窗口的起始，窗口长度
        int left = 0, right = 0, winStart = 0, windowLength = Integer.MAX_VALUE;
        //3.临界条件，右侧指针到尾
        while (right < s.length()) {
            char c = s.charAt(right);
            if (tMap.containsKey(c)) {
                //如果map中包含此索引，则说明当前位置含字串的元素，所需的字串元素数量-1.
                tMap.put(c, tMap.getOrDefault(c, 0) - 1);
            }
            //当当前串中包含字串时。判断能否缩短当前字串，如果移动左指针实现。
            while (checkNum(tMap) == true) {
                if (right - left < windowLength) {
                    winStart = left;
                    windowLength = right - left+1;
                }
                char leftNum = s.charAt(left);
                if (tMap.containsKey(leftNum)) {
                    //如果删除了字串的一个元素，但是这个元素时要求的字串中包含的元素，则需求的字串元素数量+1
                    tMap.put(leftNum, tMap.getOrDefault(leftNum, 0) + 1);
                }
                left++;
            }
            right++;
        }
        //防止出现主串和字串长度一样，但是又不符合条件。  如测试案例  "aa"  "bb"
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(winStart, winStart + windowLength);
    }

    public boolean checkNum(Map<Character, Integer> tMap) {
        boolean flag = true;
        for (Character key : tMap.keySet()) {
            if (tMap.get(key) > 0) flag = false;
        }
        return flag;
    }
}
```

注意：substring（beginIndex,endIndex）方法的使用

传入的beginIndex和endIndex，截取的并不是这两个索引之间的元素，而是在beginIndex为其实索引，生成新的字符串长度为（endIndex - beginIndex）。

```java
    public String substring(int beginIndex, int endIndex) {
        if (beginIndex < 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        if (endIndex > value.length) {
            throw new StringIndexOutOfBoundsException(endIndex);
        }
        int subLen = endIndex - beginIndex;
        if (subLen < 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return ((beginIndex == 0) && (endIndex == value.length)) ? this
                : new String(value, beginIndex, subLen);
    }
```

### 练习

#### 测试案例

1. 目标子串大于主串  false    如： 主串:  “bb”,   目标字串"bbbb"
2. 目标字串与主串一样     如： 主串:  “bb”,   目标字串"bb"
3. 主串全由目标字串组成   如 ： 主串：“bbbbb”,   目标字串"b"

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

题解：[【数据结构和算法】滑动窗口，视频演示 - 最小覆盖子串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimum-window-substring/solution/shu-ju-jie-gou-he-suan-fa-hua-dong-chuan-p6ip/)

```java
class Solution01 {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        //1.记录需要字串的数量
        Map<Character, Integer> tMap = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            tMap.put(t.charAt(i), tMap.getOrDefault(t.charAt(i), 0) + 1);
        }
        //2.窗口左边界，窗口右边界，窗口的起始，窗口长度
        int left = 0, right = 0, winStart = 0, windowLength = Integer.MAX_VALUE;
        //3.临界条件，右侧指针到尾
        while (right < s.length()) {
            char c = s.charAt(right);
            if (tMap.containsKey(c)) {
                //如果map中包含此索引，则说明当前位置含字串的元素，所需的字串元素数量-1.
                tMap.put(c, tMap.getOrDefault(c, 0) - 1);
            }
            //当当前串中包含字串时。判断能否缩短当前字串，如果移动左指针实现。
            while (checkNum(tMap) == true) {
                if (right - left < windowLength) {
                    winStart = left;
                    windowLength = right - left+1;
                }
                char leftNum = s.charAt(left);
                if (tMap.containsKey(leftNum)) {
                    //如果删除了字串的一个元素，但是这个元素时要求的字串中包含的元素，则需求的字串元素数量+1
                    tMap.put(leftNum, tMap.getOrDefault(leftNum, 0) + 1);
                }
                left++;
            }
            right++;
        }
        //防止出现主串和字串长度一样，但是又不符合条件。  如测试案例  "aa"  "bb"
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(winStart, winStart + windowLength);
    }

    public boolean checkNum(Map<Character, Integer> tMap) {
        boolean flag = true;
        for (Character key : tMap.keySet()) {
            if (tMap.get(key) > 0) flag = false;
        }
        return flag;
    }
}
```

#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

[LeetCode.567.字符串的排列_哔哩哔哩_bilibili](https://www.bilibili.com/video/av71240379/)

[注释超详细的滑动窗口讲解，附本题躲坑指南 - 字符串的排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutation-in-string/solution/zhu-shi-chao-xiang-xi-de-hua-dong-chuang-rc7d/)

[Java 滑动窗口 - 字符串的排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutation-in-string/solution/java-hua-dong-chuang-kou-by-yi-fang-0826-ge5j/)

解法：

- [x] map解法

```java
class Solution02 {
    public boolean checkInclusion(String s1, String s2) {
        int l1Len = s1.length();
        int l2Len = s2.length();
        //目标子串长度大于主串长度
        if (l1Len > l2Len) return false;
        //记录目标子串所需各个元素的数量
        Map<Character, Integer> s1Map = new HashMap<>();
        for (int i = 0; i < l1Len; i++)
            s1Map.put(s1.charAt(i), s1Map.getOrDefault(s1.charAt(i), 0) + 1);
        Map<Character, Integer> s2Map = new HashMap<>();
        int left = 0, right = 0;
        while (right < l2Len) {
            //窗口大小满足字串的长度
            while ((right - left + 1) == l1Len) {
                //当两个map相同时，达到目的
                if (s1Map.equals(s2Map)) return true;
                //当right+1==length时，到了最后s2的最后一个字符，之后的right++操作会造成越界
                if (right + 1 < l2Len) {
                    right++;
                    //窗口向右活动一个空间
                    //添加新元素的数量到窗口
                    s2Map.put(s2.charAt(right), s2Map.getOrDefault(s2.charAt(right), 0) + 1);
                    //减去旧窗口中元素的数量
                    s2Map.put(s2.charAt(left), s2Map.getOrDefault(s2.charAt(left), 0) - 1);
                    //移除窗口中不再使用的元素
                    if (s2Map.get(s2.charAt(left)) == 0) s2Map.remove(s2.charAt(left));
                    //右指针偏移
                    left++;
                } else {
                    //如果到了最后一个字符，还没有满足要求的窗口，则不成立
                    return false;
                }
            }
            //往窗口中添加元素
            s2Map.put(s2.charAt(right), s2Map.getOrDefault(s2.charAt(right), 0) + 1);
            right++;
        }
        return false;
    }
}
```

参考解法：

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int len1 = s1.length();
        int len2 = s2.length();
        
        if(len1 > len2)
            return false;
        
        HashMap<Character, Integer> mapS1  = new HashMap<>();
        HashMap<Character, Integer>  mapS2 = new HashMap<>();
        
        for(char ch : s1.toCharArray())
            mapS1.put(ch, mapS1.getOrDefault(ch, 0) + 1);
        
        int index = 0;
        for(int i = 0; i < len1; i++, index++){
            char ch = s2.charAt(i);
            mapS2.put(ch, mapS2.getOrDefault(ch, 0) + 1) ;
        }
        
        while(index < len2){
            if(mapS2.equals(mapS1))
                return true;
            
            char before = s2.charAt(index - len1);
            char after  = s2.charAt(index);
            
            mapS2.put(before, mapS2.get(before) - 1);
            if(mapS2.get(before) == 0)
                mapS2.remove(before);
            mapS2.put(after, mapS2.getOrDefault(after, 0) + 1);

            index++;
        }
        
        return mapS2.equals(mapS1);
    }
}
```

- [ ] 数组解法：第二轮

## 二分查找

作图链接：https://www.processon.com/view/link/61e260ba1e085306c96d14bf

### 引入二分查找

举例：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

![image-20220115140626066](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115140626066.png)

##### 我的解法

```java
public class 二分查找_704 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums01 = {-1, 0, 3, 5, 9, 12, 18, 21, 35, 48, 52, 60};
        System.out.println(solution.search(nums01, 12));
    }
}
class Solution {
    public int search(int[] nums, int target) {
        int first = 0, last = nums.length - 1, mod = nums.length / 2;
        while (first < last) {
            //缩短区间
            if (nums[mod] == target) {
                return mod;
            } else if (nums[mod] > target) {
                last = mod - 1;
                mod = (mod - first) / 2;
            } else if (nums[mod] < target) {
                first = mod + 1;
                mod = mod + (last - mod) / 2;
            }
        }
        //用于最后last=fist这个元素的值与target的比较。
        if (nums[last] == target) return last;
        return -1;
    }
}

```

![image-20220114151602823](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114151602823.png)

first：当前筛选区间的第一个元素位置

last:当前筛选区间的最后一个元素位置

mod：将筛选区间折半后，分割两区间元素的位置。（区间长度/2）

以first和last作为二分后，筛选元素的区间。以mod为每次二分的分界点。

注意：first+1和last-1表示可筛选的元素区间

问题：

1. 分界点我的选择是以所剩元素的长度进行的二分，造成的问题及时mod维护特别繁琐,并且还时不时会出现越界问题，加大了问题的复杂度。
2. 对最后一个元素的处理，即当first==last的时候，再进行while循环时，有时会产生死循环。此时mod不发生改变，而last或first却发生改变。
3. 而first+1=last时，此时如果直接返回-1，那么就会少判断最后一个元素。因此最后的返回时，还需要再判断。

**查找元素9**

1. 初始：first=0，last=length-1，mod=length/2

   ![image-20220114153045199](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114153045199.png)

2. 第二轮：9<nums[mod]，目标区间在左侧。first=0,mod =(mod - first) / 2,last=mod-1

   ![image-20220114152035363](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114152035363.png)

3. 第三轮：9<nums[mod]，目标区间在右侧。first=mod+1,mod= mod + (last - mod) / 2,last不变。

   ![image-20220114152211269](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114152211269.png)

4. 如果要查找元素10

   ![image-20220114152629359](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114152629359.png)

   1. **此时，first=last=mod，并且没有找到对应元素**

5. 如果要查找元素12

   1. 和10的情况一样，但是此时最后一个数值，first和last相等的这个元素还没有判断。因此最后需要再做一个判断。

##### 优秀解法

```java
class Solution02 {
    public int search(int[] nums, int target) {
        int first = 0, last = nums.length - 1, mid = 0;
        while (first<= last) {
            mid = first + (last - first) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                last = mid - 1;
            } else if (nums[mid] < target) {
                first = mid + 1;
            }
        }
        return -1;
    }
}
```

该解法与上述解法最大的却别是在，以区间的最后一个元素的索引（之前是区间的长度）作为mid。

![image-20220114155655432](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114155655432.png)

first：当前筛选区间的第一个元素位置

last:当前筛选区间的最后一个元素位置

mid（注意，与之前不同）：first + (last-first)/2  将筛选区间折半后，分割两区间元素的位置。（最后一个元素的索引/2）

注意：first+1和last-1表示可筛选的元素区间。此处如果不进行+1和-1的操作，如果查找的元素原数组中不包含的话，会成为死循环。

**查找元素9**

1. 初始

   1. ![image-20220114155802999](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114155802999.png)

2. 第一轮循环

   ![image-20220114155817833](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114155817833.png)

3. 第二轮循环

   ![image-20220114160128161](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114160128161.png)

4. 第三轮循环

   ![image-20220114160150225](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114160150225.png)

5. 第四轮循环

   ![image-20220114160158214](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114160158214.png)

##### 扩展

上述二分查找获取元素的条件是元素无重复，和是已经排列好的数组。如果我要找到1,2,2,2,2,3中第一次出现2的位置和最后一次出现2的位置如何寻找呢？

###### 1. 获取目标元素第一次出现的位置

```java
//返回目标元素第一次出现的位置
class Solution03 {
    public int searchRange(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid - 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        //防止出边界。如在1,2,2,2,2,3中查找5  不同考虑right的取值范围
        return left >= nums.length || nums[left] != target ? -1 : left;
    }
}
```

**原始数组**

1. 获取目标数组中2第一次出现的位置

   ![image-20220114180639763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180639763.png)

2. 第一次循环

   ![image-20220114180740347](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180740347.png)

3. 第二次循环

   ![image-20220114181349196](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181349196.png)

4. 第三轮循环  left = right

   此时以获取正确结果为nums[left]

   ![image-20220114181533346](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181533346.png)

**返回值解析**

```java
return left >= nums.length || nums[left] != target ? -1 : left;
```

如果我查找一个原始数组中没有的元素，比如我要查找5

1. 在目标数组中查找元素5

   ![image-20220114181807672](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181807672.png)

2. 第一轮循环

   ![image-20220114181930691](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181930691.png)

3. 第二轮循环

   ![image-20220114182009377](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182009377.png)

4. 第三轮循环

   没有找到对应的元素，并且left超出边界，所以返回-1

   ![image-20220114182055486](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182055486.png)

###### 2. 获取目标元素最后一次出现的位置

```java
//返回目标元素最后一次出现的位置
class Solution04 {
    public int searchRange(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        //防止出边界。如在1,2,2,2,2,3中查找0  不用考虑left的取值范围。
        return right < 0 || nums[right] != target ? -1 : right;
    }
}
```

**原始数组**

1. 获取目标数组中2最后一次出现的位置

   ![image-20220114180639763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180639763.png)

2. 第一次循环

   ![image-20220114182719465](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182719465.png)

3. 第二次循环

   此时left和right相等

   ![image-20220114182927197](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182927197.png)

4. 第三轮循环

   此时返回right对应的值即可。

   ![image-20220114183020545](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183020545.png)

**临界值的取值**

1. 获取目标值为0的元素最后一次出现的位置

   ![image-20220114180639763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180639763.png)

2. 第一轮循环

   ![image-20220114183312768](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183312768.png)

3. 第二轮循环

   ![image-20220114183342044](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183342044.png)

4. 第三轮循环

   此时right已经出界，并且没有找到目标值，返回-1

   ![image-20220114183429603](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183429603.png)

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

结合上一题目的扩展

```java
class Solution05 {
    public int[] searchRange(int[] nums, int target) {
        int arr[] = new int[2];
        int first = getIndex(nums, target, true);
        int last = getIndex(nums, target, false);
        arr[0] = first;
        arr[1] = last;
        return arr;
    }

    public int getIndex(int[] nums, int target, boolean isLeft) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                if (isLeft) {
                    right = mid - 1;
                } else left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        if (isLeft) {
            return left >= nums.length || nums[left] != target ? -1 : left;
        } else return right < 0 || nums[right] != target ? -1 : right;
    }
}
```

## 练习

