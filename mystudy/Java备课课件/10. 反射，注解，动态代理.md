## 反射

## 0. 学习资料

[(87条消息) 高薪程序员&面试题精讲系列24之你熟悉反射吗？_一一哥-CSDN博客](https://blog.csdn.net/syc000666/article/details/121508889?spm=1001.2014.3001.5501)

## 1. 反射基础

### 介绍

Java的反射(reflection)机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。


通过Java语言中的反射机制可以操作字节码文件。可以读写字节码文件，操作代码片段（class文件）

**反射相关的包：**

java.lang.reflect.*;

**反射相关的类：**

1. java. lang.class:代表整个字节码。**代表一个类型，代表整个类**。
2. java.lang.refleat.Field:代表字节码中的属性字节码。代表类中的成员变量**（静态变量和静态变量)**
3. java.lang.reflect.constructor:代表字节码中的构造方法字节码。**代表类中的构造方法**
4. java.lang.reflect.Method:代表字节码中的方法字节码。**代表类中的方法。**

```java
//1.Class
public class User {
    //2.Filed
    private String name;
    //3.Constructor
    public User(){

    }
    //4.Method
    public void setName(String name){

    }
}
```

### 获取类

1. static 类<?> forName(String className) 返回与给定的字符串名称的类或接口相关的 类对象。  
   ClassLoader getClassLoader() 返回类的类装载器。  
   Constructor<T> getConstructor(类<?>... parameterTypes) 返回一个 Constructor对象反映指定的公共构造函数的 类对象表示的类。  
   Constructor<?>[] getConstructors() 返回一个数组包含 Constructor物体反射所有的 类对象表示的类的公共构造函数。  
   Constructor<T> getDeclaredConstructor(类<?>... parameterTypes) 返回一个 Constructor对象反映指定的构造函数的类或接口的 类对象表示。 
   Constructor<?>[] getDeclaredConstructors() 返回 Constructor物体反射所有的构造函数通过 类对象表示的类中声明一个数组。  
   Field getDeclaredField(String name) 返回一个对象，反映了 Field指定声明字段的类或接口的 类对象表示。  Field[] getDeclaredFields() 返回 Field物体反射所有字段的类或接口的 类对象表示声明数组。  
   方法 getDeclaredMethod(String name, 类<?>... parameterTypes) 返回一个 方法对象反映指定声明方法的类或接口的 类对象表示。  
   方法[] getDeclaredMethods() 返回一个数组包含 方法物体反射所有声明的方法的类或接口的 类对象，代表包括公众、保护，默认（包）的访问，和私有方法，但不包括继承的方法。  
   Field getField(String name) 返回一个 Field对象反映的类或接口的 类对象表示的指定公共成员。  
   Field[] getFields() 返回一个数组包含 Field物体反射的类或接口的 类对象代表所有可访问的公共领域。  
   Type[] getGenericInterfaces() 返回表示接口，通过该对象表示的类或接口直接实现的 Types。  
   Type getGenericSuperclass() 返回表示实体的直接父类的 Type（类、接口、简单类型或void）的 类代表。  类<?>[] getInterfaces() 确定由该对象表示的类或接口实现的接口。  
   方法 getMethod(String name, 类<?>... parameterTypes) 返回一个 方法对象反映的类或接口的 类对象表示的指定公共成员方法。  
   方法[] getMethods() 返回一个数组包含 方法物体反射所有的类或接口的 类对象表示的公共方法，包括那些由类或接口的超类和超接口继承的声明。  
   int getModifiers() 返回该类或接口的java语言的修饰，在整数编码。  
   String getName() 返回单位名称（类，接口，数组类，原始类型，或无效）的 类对象表示，作为一个 String。  
   String getSimpleName() 返回在源代码中给定的底层类的简单名称。  
   类<? super T> getSuperclass() 返回表示的实体（类、接口类的 类，原始类型或void）的 类代表。  
   String getTypeName() 返回此类型的名称的信息字符串。  
   T newInstance() 创建这个 类对象表示的类的一个新实例。  
   String toString() 将对象转换为字符串。  

Java提供了三种通过反射获取类的范式。

1. **Class.forName("类的包路径.类名")**

   1. ```java
      public class ReflectTest01 {
          public static void main(String[] args) {
              try {
                  Class c1 = Class.forName("java.lang.String");//c1表示String.class文件，表示String类型
                  Class c2 = Class.forName("java.util.Date");//表示Date类型
                  Class c3 = Class.forName("java.lang.Integer");//表示Integer类型
                  Class c4 = Class.forName("java.lang.System");//表示System类型
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```

   2. **注意：我们可以使用Class.forName会导致类加载，可以来执行某个类的静态代码块。**

      1. 当我们只需要加载静态代码快，类的其他内容不执行时，我们可以通过Class.forName（“完整类名”）来实现。

      2. **该方法会导致类加载时，静态代码块执行。**（jdbc注册驱动使用）。

      3. ```java
         public class ReflectTest03 {
             public static void main(String[] args) {
                 try {
                     Class.forName("lession_21_12_06_reflect.User");
                 } catch (ClassNotFoundException e) {
                     e.printStackTrace();
                 }
             }
         }
         public class User {
             static {System.out.println("这是User类的静态代码块");}
         }
         ```

      4. ![image-20211206201753064](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211206201753064.png)

2. **对象.class()**

   1. ```java
      public class ReflectTest01 {
          public static void main(String[] args) {
              String  str  = "123";
              Class<? extends String> x = str.getClass();
              System.out.println(aClass);//class java.lang.String
              Date date = new Date();
               Class<? extends Date> y = date.getClass();
              System.out.println(y);//class java.util.Date
          }
      }
      ```

   2. 进行对比

      1. ```java
         		Class c1 = Class.forName("java.lang.String");
            		Class<? extends Date> y = date.getClass();
                 System.out.println(c1==x);//true
                 System.out.println(c2==y);//true
         ```

      2. ![image-20211206155255923](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211206155255923.png)

3. **任意类型.class;**

   1. ```java
      public class ReflectTest01 {
          public static void main(String[] args) {
              //方式三：
              Class<String> s = String.class;
              Class<Date> d = Date.class;
              Class<Integer> i = int.class;
              Class<Character> c = char.class;
          }
      }
      
      ```

**汇总**

```java
public class ReflectTest01 {
    public static void main(String[] args) {
        //方式一：
        Class c1 =null;
        Class c2=null;
        try {
            c1 = Class.forName("java.lang.String");//c1表示String.class文件，表示String类型
             c2 = Class.forName("java.util.Date");//表示Date类型
            Class c3 = Class.forName("java.lang.Integer");//表示Integer类型
            Class c4 = Class.forName("java.lang.System");//表示System类型
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        //方式二：
        String  str  = "123";
        Class<? extends String> x = str.getClass();
        System.out.println(x);//class java.lang.String
        Date date = new Date();
        Class<? extends Date> y = date.getClass();
        System.out.println(date.getClass());//class java.util.Date
        System.out.println(c1==x);
        System.out.println(c2==y);
        //方式三：
        Class<String> s = String.class;
        Class<Date> d = Date.class;
        Class<Integer> i = int.class;
        Class<Character> c = char.class;
    }
}

```

#### 创建对象

通过反射创建对象的，使用的类的newInstance()方法，该方法在Java9已经淘汰。

new Instance()方法会调用User这个类的无参数构造方法，完成对象的创建。因此，如果一个类没有提供无参构造方法，是会出错的。

```java
public class ReflectTest02 {
    public static void main(String[] args) {
        //创建对象
        User user = new User();
        System.out.println(user);//lession_21_12_06_reflect.User@1540e19d
        //使用反射创建对象
        try {
            Class aClass = Class.forName("lession_21_12_06_reflect.User");
            //通过反射机制来获取实例
            Object object = aClass.newInstance();
            System.out.println(object);//lession_21_12_06_reflect.User@677327b6
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}

```

#### 获取父类或接口

```java
class  Father{

}
interface Action{

}
public class Student extends Father implements Action{}
public class QueryMethodTest {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Class studentClass = Class.forName("lession_21_12_06_reflect.Student");
        Class superclass = studentClass.getSuperclass();
        System.out.println(superclass.getSimpleName());
        Class[] interfaces = studentClass.getInterfaces();
        for (int i = 0; i < interfaces.length; i++) {
            System.out.println(interfaces[i].getSimpleName());
        }
    }
```

### 获取属性

#### 基本使用

我们可以通过反射机制，获取每一个类的属性名称，属性类型，修饰符等信息。

常用API：

```java
public class Student {
    //使用不同的权限修饰符修饰
    public static final int no=0;
    private String name;
    protected int age;
    boolean sex;
}
public class ReflectFiledTest {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
        Class studentClass = Class.forName("lession_21_12_06_reflect.Student");
        //获取完整类名
        String className = studentClass.getName();
        System.out.println("完整类名"+className);
        //获取简写类名
        String simpleName = studentClass.getSimpleName();
        System.out.println("简写类名"+simpleName);
        //获取类中的所有public修饰的属性
        Field[] fields = studentClass.getFields();
        System.out.println(fields.length);
        Field field = fields[0];
        //获取属性名
        String fieldName = field.getName();
        System.out.println("属性名"+fieldName);
        //获取所有的属性
        Field[] allFields = studentClass.getDeclaredFields();
        System.out.println(allFields.length);
        for (int i =0; i <allFields.length; i++) {
            System.out.println("属性"+i);
            Field field1 = allFields[i];
            System.out.println("属性名"+field1.getName());
            //获取修饰符列表
            int modifiers = field1.getModifiers();
            String modifierName= Modifier.toString(modifiers);
            System.out.println("权限修饰附："+modifiers+"——"+modifierName);
            //获取属性类型
            Class<?> type = field1.getType();
            String typeName = type.getName();
            System.out.println("属性类型名称："+typeName);
        }

    }
}
```

#### 获取/修改属性值

修改属性时，对于私有属性的修改和获取，我们需要设置nameField.setAccessible(true); 允许我们对私有属性参与修改。（有风险）

nameField.setAccessible(true); 打破封装，让外部类也可以访问私有成员

修改属性的要素：1. 对象 2. 属性 3.属性值

获取属性的要素：1. 对象 2. 属性

反射机制让我们代码更复杂，但是让程序更灵活，我们可以通过配置文件，来创建对象并为对象赋值（JavaEE企业级开发都是用这种方式。）

```java
public class Student {
    //使用不同的权限修饰符修饰
    public static final int no=0;
    private String name;
    protected int age;
    boolean sex;
}
public class QueryFiledTest {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {
        //设置producted修饰的属性
        Class studentClass = Class.forName("lession_21_12_06_reflect.Student");
        Object o = studentClass.newInstance();
        Field ageField = studentClass.getDeclaredField("age");
        ageField.set(o, 18);
        System.out.println(ageField.get(o));
        //设置private修饰的属性
        Field nameField = studentClass.getDeclaredField("name");
        nameField.setAccessible(true);//设置为可以修改私有成员
        nameField.set(o, "张三");
        System.out.println(nameField.get(o));
    }
}
```

### 获取方法

方法要素：

1. 对象
2. 方法名
3. 参数
4. 返回值类型

#### 基本使用

```java
public class QueryMethodTest {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        Class studentClass = Class.forName("lession_21_12_06_reflect.Student");
        Object o = studentClass.newInstance();
        Method[] methods = studentClass.getDeclaredMethods();
        for (Method method : methods
        ) {
            System.out.println("方法-------------");
            int modifiers = method.getModifiers();
            System.out.println("修饰符"+Modifier.toString(modifiers));
            System.out.println("返回值类型"+method.getReturnType().getName());
            System.out.println("方法名"+method.getName());
            Class[] parameters = method.getParameterTypes();
            for (Class parameter : parameters
            ) {
                System.out.println("参数"+parameter.getSimpleName());
            }

        }
    }
}
```

#### 调用方法

```java
public class QueryMethodTest {
    public static void main(String[] args) throws Exception {
        Method setNameAndAge = studentClass.getDeclaredMethod("setNameAndAge", String.class, int.class);
        Method setName = studentClass.getDeclaredMethod("setName", String.class);

        Object o1 = setNameAndAge.invoke(o, "张三", 18);
        //o为对象，o1,o2为方法的返回值
        System.out.println(o);
        System.out.println(o1);
        Object o2 = setName.invoke(o, "张三");
        System.out.println(o2);
    }
}
public class Student {
    //使用不同的权限修饰符修饰
    public static final int no = 0;
    private String name;
    protected int age;
    boolean sex;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String setName(String name) {
        this.name = name;
        return this.name;
    }

    public Student setNameAndAge(String name, int age) {
        this.name = name;
        this.age = age;
        new Student();
        return new Student(name, age);
    }
}
```

### 获取构造器

```java
public class Student {
    //使用不同的权限修饰符修饰
    public static final int no = 0;
    private String name;
    protected int age;
    boolean sex;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

}
public class ConstructTest {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class studentClass = Class.forName("lession_21_12_06_reflect.Student");
        Constructor[] constructors = studentClass.getConstructors();
        for (Constructor constructor:constructors
             ) {
            System.out.println("权限修饰符"+Modifier.toString(constructor.getModifiers()));
            System.out.println("名称"+constructor.getName());
        }
        Constructor constructor = studentClass.getDeclaredConstructor(String.class, int.class);
        Object o = constructor.newInstance("张三", 18);
        System.out.println(o);

        Constructor constructor2 = studentClass.getDeclaredConstructor();
        Object o2 = constructor2.newInstance();
        System.out.println(o2);

    }
}
```



## 2. 文件处理优化

### 文件处理

我们可以使用反射来读取相应的配置文件，并且生成相应对象，这样更加灵活。我们可以根据配置文件，在系统中创建不同的对象。

优点：代码不用改动，修改配置文件来创建不同对象。非常灵活

高级框架底层都采用了反射机制。

```java
public class ReflectFileTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        //普通方式创建对象，代码写死，只能创建User对象
        User u = new User();
        System.out.println(u);

        //通过反射创建对象
        FileReader reader = new FileReader("user.properties");
        Properties properties = new Properties();
        properties.load(reader);
        reader.close();
        String user = properties.getProperty("user");
        Class aClass = Class.forName(user);
        Object o = aClass.newInstance();
        System.out.println(o);
    }
}
```

user.properties在当前项目目录下，内容是：` user=lession_21_12_06_reflect.User`

### 文件路径优化

在idea中，我们使用相对路径默认是以当前工程目录为起始目录。如果我们在此写死，很可能使用其他软件运行项目的时候，运行不起来。因为不同的编辑器对路径的处理不同。

如果我们使用绝对路径，以盘符开始，此时当我们切换操作系统运行代码时，如我们的代码在mac和linux上运行，他们就没有盘符，因此此方法也不可行。

**推荐优先使用类路径存储文件，即当前模块的src目录。我们的文件都存储在这个下面，这样就可以适配不同的编辑器和操作系统。**

![image-20211206203416209](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211206203416209.png)

**通过类路径获取文件（麻烦）**

user.properties在当前模块的src目录下。

```java
public class ReflectFileTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        String path = Thread.currentThread()//当前线程对象
                .getContextClassLoader()//当前类加载器
                .getResource("user.properties")//获取资源（默认从类路径（当前模块的src）下加载资源）
                .getPath();//获取绝对路径（该方法跨平台）
       System.out.println(path);
        FileReader reader = new FileReader(path);
        Properties properties = new Properties();
        properties.load(reader);
        String user = properties.getProperty("user");
        Class aClass = Class.forName(user);
        Object o = aClass.newInstance();
        System.out.println(o);
        //优化
        InputStream resourceAsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("user.properties");
        Properties properties1 = new Properties();
        properties1.load(resourceAsStream);
        String user = properties1.getProperty("user");
        Class aClass = Class.forName(user);
        Object o = aClass.newInstance();
        System.out.println(o);
    }
}
```

path打印： /G:/ComputerStudy/JavaLession/hsdlession/lession_12/data_lesssion/out/production/ready_lession/user.properties

**使用资源绑定器（简单）**

资源绑定器ResourceBundle可以帮助我们快速获取并处理类路径下的文件。

注意：

1. ResourceBundle只能获取类路径下的properties文件，不能获取其他文件
2. 文件不能带后缀名

```java
public class ReflectFileTest {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException  {
        //使用资源绑定器
        ResourceBundle bundle = ResourceBundle.getBundle("user");
        String user = bundle.getString("user");
        Class aClass = Class.forName(user);
        Object o = aClass.newInstance();
        System.out.println(o);
    }
}

```

### 文件获取路径和Class路径的写法区别

使用Stream获取文件的时候，我们必须填写文件的后缀名。因此路径是以/或者\ \进行分割

使用Class.forName（）获取的是某个包下的类，因为我们的写法是所在包的写法，以.进行分割

使用ResourceBundle，他读取的是文件，因此也是使用以/或者\ \进行分割。只不过它只能获取类路径（src）下的properties文件。

## 3. 类加载器

类加载器是负责加载类的命令/工具。ClassLoader

**JDK中自带了3个类加载器**

1. 启动类加载器：C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar
2. 扩展类加载器:   C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext/*.jar
3. 应用类加载器:   classpath中配置的路径.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar



**String s = "abc"；代码的执行步骤**

代码在开始执行之前，会将所需要类全部加载到JVM当中。

通过类加载器加载，看到以上代码类加载器会找String.class文件，找到就加载。

加载流程：

1. 首先通过"启动类加载器"加载。
   1. 注意:启动类加载器专门加载:C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar
   2. rt.jar中都是JDK最核心的类库。
2. 如果通过"启动类加载器"加载不到的时候，会通过"扩展类加载器"加载。
   1. 注意:扩展类加载器专门加载: C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext/*.jar
3. 如果"扩展类加载器"没有加载到，那么会通过"应用类加载器"加载。
   1. 注意:应用类加载器专门加载: classpath中的类。

**双亲委派机制**

java中为了保证类加载的安全，使用了双亲委派机制。

优先从启动类加载器中加载,，这个称为"父"，父"无法加载到,再从扩展类加载器中加载，这个称为"母"。

双亲委派。如果都加载不到，才会考虑从应用类加载器中加载。直到加载到为止。
