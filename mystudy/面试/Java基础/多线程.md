# 基础

sleep和yield的区别

1）sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给优先级低的线程以运行的机会，而yield()方法只会给相同优先级或者更高优先级的线程以运行机会。
2）线程执行sleep()方法后会转入阻塞状态，所以，执行sleep()方法的线程在指定的时间内肯定不会被执行，而yield()方法只是使当前线程重新回到可执行状态，所以执行yield()方法的线程有可能在进入到可执行状态后马上又被执行。
3）sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常。
4）sleep()方法比yield()方法（跟操作系统）具有更好的可移植性。

### 死锁

#### 0. 常见问题

1. 什么是死锁
2. 如何排查死锁
3. 如何避免死锁

#### 1. 什么是死锁

##### 概念

在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成**两个线程都在等待对方释放锁**，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

##### 死锁产生的条件

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**互斥条件**

互斥条件是指**多个线程不能同时使用同一个资源**。

比如下图，如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。

![image-20220118114937490](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118114937490.png)

**持有并等待条件**

持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是**线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。

![image-20220118114949978](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118114949978.png)

**不可剥夺条件**

不可剥夺条件是指，当线程已经持有了资源 ，**在自己使用完之前不能被其他线程获取**，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。

![image-20220118115005578](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118115005578.png)

**环路等待条件**

环路等待条件指都是，在死锁发生的时候，**两个线程获取资源的顺序构成了环形链**。

比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。

![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118115005578.png)

##### 案例

[mystudy/Java备课课件/11. 多线程.md · Zhang-HaoQi/Knowledge - 码云 - 开源中国 (gitee.com)](https://gitee.com/zhang-haoqi/knowledge/blob/develop/mystudy/Java备课课件/11. 多线程.md#死锁)

#### 2. 如何排查死锁

**四种方式：**

1. 使用Jps
2. 使用jconsole
3. 使用jvisualvm
4. 使用jmc

##### **方式一：使用jps**

1. jps -l :查看本机运行的所有Java程序及id

   ![image-20220118141452228](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118141452228.png)

2. jps -l PID:输出进程 pid 和运行程序完整路径名（包名和类名）。

   ![image-20220118141446538](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118141446538.png)

3. jstack -l PID:发现死锁问题

![image-20220118141356641](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118141356641.png)

![image-20220118141644336](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220118141644336.png)

##### 其它三种方式：

[死锁的 4 种排查工具 ！ - Java中文社群 - 博客园 (cnblogs.com)](https://www.cnblogs.com/vipstone/p/15178628.html)

#### 3. 如何预防和避免死锁

**如何预防死锁？** 

破坏死锁产生的必要条件：

1. **破坏请求与保持条件** ：一次性申请所有的资源。
2. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件** ：靠按序申请资源来预防。**按某一顺序申请资源，释放资源则反序释放。**破坏循环等待条件。

**如何避免死锁？**

避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

[操作系统——死锁的概念以及死锁处理策略 - 王陸 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wkfvawl/p/11598647.html)

**安全状态** 指的是系统能够按照某种进程推进顺序（P1、P2、P3.....Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。



# 学习资料

[Java Synchronized 重量级锁原理深入剖析上(互斥篇) - 简书 (jianshu.com)](https://www.jianshu.com/p/be4ef14e123c)

synchronized原理

多线程相关：[Java 线程基础 - 简书 (jianshu.com)](https://www.jianshu.com/p/82827f086a7b)

## 同步代码块

![image-20220115200453200](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115200453200.png)

mointorEnter

![image-20220115200411691](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115200411691.png)

![image-20220115200920386](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115200920386.png)

mointorExit

![image-20220115201518362](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115201518362.png)

![image-20220115201500132](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115201500132.png)

## 同步方法

![image-20220115202834365](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115202834365.png)

出现了一个ACC_SYNCHRONIZED

![image-20220115202927778](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115202927778.png)

![image-20220115203002841](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115203002841.png)

## 常见面试题

![image-20220115203029124](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115203029124.png)

7. 的解释，synchronized没有先来后到的概念，如果一个线程结束后，后面的线程可以争抢这个锁。

   ReentrantLock是公平锁，可以设置是否排队。

## 5. 深入Monitor

### 结构

![image-20220115204501420](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115204501420.png)

### 竞争

**问题：**

1. 何时会进入Monitor竞争  2. 了解如何竞争

**分析:**

**1. 进入竞争**

![image-20220116100129047](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116100129047.png)

此时有两个线程t1和t2都来执行这个代码块，此时两个线程处于竞争状态。

**2. 竞争过程**

1. 当遇到synchronized时，会执行monitorter。

2. 执行monitorter时，会调用InterpreterRuntime.cpp中的monitorterenter方法。

   1. 关键代码：会先判断是否有偏向锁（用户是否设置），无偏向锁，走重量级锁

      ![image-20220115205054446](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115205054446.png)

   2. 对于重量级锁，monitorenter函数中会调用 ObjectSynchronizer::slow_enter，进入ObjectMonitor：：enter这个方法（接下来演示的图片中的代码都是这个方法中的）

      ![image-20220116102254243](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116102254243.png)

      1. 通过CAS尝试把monitor的owner字段设置为当前线程，看是否能成功
         1. ![image-20220116102409219](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116102409219.png)
         2. ![image-20220116102520451](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116102520451.png)
      2. 设置成功，如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行recursions++，记录重入次数
         1. ![image-20220116102615154](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116102615154.png)
         2. _recursions对应+1
      3. 设置成功，如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获得锁并返回。
         1. ![image-20220116102801839](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116102801839.png)
      4. 如果获取锁失败，则等待锁的释放
         1. t1和t2都来强锁，t1抢到了就去执行对应代码，t2没有抢到（或t3,t4等更多线程都没有抢到），就会进入_cxq中被阻塞。
            1. ![image-20220116103426112](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116103426112.png)
            2. 此时_cxq中有t2，t3等其他未抢到锁被阻塞的线程

**总结：**

1. 通过CAS尝试把monitor的owner字段设置为当前线程。
2. 如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行recursions ++，记录重入的次数。
3. 如果当前线程是第一次进入该monitor，设置recursions为1,][_owner为当前线程，该线程成功获得锁并返回。
4. 如果获取锁失败，则等待锁的释放。

### 等待

当线程未抢到锁时，会调用EnterI(THREAD)进入线程的阻塞。假如t2没有抢到锁

**EnterI(THREAD)执行流程**

假如t2没有抢到锁，进入EnterI(THREAD），竞争失败等待调用的是ObjectMonitor对象的EnterI方法（位于： src/share/vm/runtime/objectMonitor.cpp）

1. 再次尝试抢锁，如果抢到锁就执行

![image-20220116110506838](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116110506838.png)

2. 进入自旋（一个循环，多次抢锁，看能否抢到锁）

   ![image-20220116110624155](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116110624155.png)

3. 上述两步骤如果都没有重新抢到锁，将当前线程封装成ObjectWaiter对象node，状态设置为：Objectwaiter：：TS_CXQ

   ![image-20220116111214869](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116111214869.png)

4.  通过CAS把node节点push到_cxq列表中

   1. ![image-20220116111623754](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116111623754.png)

   2. push失败的时候，会进行重新push，在重新push前，还会检测是否能再抢到锁

      ![image-20220116111836464](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116111836464.png)

   3. 该循环结束后，所有的节点都会被挂到_cxq列表中。

5. 放入到_cxq列表中的线程，需要挂起

   ![image-20220116112106695](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116112106695.png)

   1. 挂起前，尝试是否能抢到锁

      ![image-20220116112124938](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116112124938.png)

   2. 未抢到后，会进行park挂起，挂起后的线程，等待被别人唤醒，唤醒后继续尝试获取锁

      1. 挂起

      ![image-20220116113007854](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116113007854.png)

      2. 唤醒后尝试强锁

         ![image-20220116113731406](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116113731406.png)

6. 当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。

   ![image-20220116113757252](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116113757252.png)

   

   

**总结：**

1. 进入EnterI（THREAD）后，会先尝试获取锁，再尝试自旋获取锁，如果没有获取锁则进行下一步
2. 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。
3. 在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node节点push到_cxq列表中。
4. node节点push到_cxq列表之后，通过自旋尝试（疑问：是否自旋？）获取锁，如果还是没有获取到锁，则通过park将当前线程挂起，等待被唤醒。
5. 当该线程被唤醒时，会从挂起的点继续执行，通过objectMonitor ::TryLock尝试获取锁。

### 释放

**问题：**

1. 什么时候会释放
2. 释放过程

**分析：**

**1. 释放时间**

![image-20220116114031970](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116114031970.png)

代码块内容执行完毕后，释放锁。

**2. 释放过程**

在 HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor的exit方法中。（位于：src/share/vm/runtime/objectMonitor.cpp）

1. 对于重入锁，进行recursions--。当recursions=0的时候，表示当前线程已经完全出了同步代码块，把锁释放掉了。

   ![image-20220116115011033](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116115011033.png)

2. 唤醒当前正在等待的线程。我们此时有两个链表，一个是_cxq，一个是 _ EntryList

   1. ObjectWaiter是被等待线程的包装，w是要被唤醒的线程，我们要找到w。

   ![image-20220116115227006](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116115227006.png)

   2. qmode = 2：直接绕过EntryList队列，从cxq队列中获取线程用于竞争锁。w此时为_cxq队列的头节点。ExitEpilog为唤醒线程。

      ![image-20220116115431699](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116115431699.png)

   3. qmode =3：w此时为_cxq队列的头节点，cxq队列插入EntryList尾部；           

      ![image-20220116120040362](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116120040362.png)

   4. qmode =4：w此时为_cxq队列的头节点，cxq队列插入到_EntryList头部

      ![image-20220116120224463](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116120224463.png)

   5. qmode=1.

      ![image-20220116120617230](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116120617230.png)

   6. 当QMode=2的时候，有唤醒w，有return。当QMode=1,3,4的时候没有唤醒w。

3. 最后，使用ExitEpilog唤醒w。

   ![image-20220116120350474](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116120350474.png)

   1. ExitEpliog解析:里面提供了unpark(),来唤醒之前挂载的线程。

      ![image-20220116122804662](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116122804662.png)

   2. 被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor 的竞争。

      ![image-20220116122912998](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116122912998.png)

**总结：**

1. 退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。
2. 根据不同的策略（由QMode指定)，从cxq或EntryList中获取头节点，通过objectMonitor : :ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。
3. 被唤醒的线程，会回到void ATTR objectMonitor ::Enter工 (TRAPS)的第600行，继续执行monitor的竞争。

### Monitor重量级锁

synchronized执行效率比较低，因为他关联的锁monitor是重量级锁。

ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数， 执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。park和unpark都是内核函数。

操作内核函数，就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语 言中是一个重量级(Heavyweight)的操作。

**用户态和内核态**

Linux体系结构：

![image-20220116124436031](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116124436031.png)

用户态：我们普通的应用程序在内核空间运行，就是用户态。

内核态：当用户的程序需要调用内核的资源时，此时就需要通过系统调用进入内核操作，即内核态。

用户态和内核态的切换是一个复杂的过程，需要消耗大量资源，因此synchronized是一个重量级锁，比较慢。

**概念解析：**

从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。

内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。 

用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存 储资源、I/O资源等。 

系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。

所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执 行某些操作时，例如 I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内 核态）。 

系统调用的过程可以简单理解为：

1. 用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提 供的服务。 
2. 用户态程序执行系统调用。 
3.  CPU切换到内核态，并跳到位于内存指定位置的指令。 
4. 系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。 
5. 系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。

 **由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器 值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在 synchronized未优化之前，效率低的原因。**

## 6. JDK6对synchronized优化

**四个优化：**

1. 锁升级
2. 锁消除
3. 锁粗化
4. 自适应自旋锁

[synchronized 中的 4 个优化，你知道几个？ - 掘金 (juejin.cn)](https://juejin.cn/post/6994443415911923719)

**问题：**

1. 学习CAS的作用
2. 学习CAS的原理

### CAS概述和作用

CAS的全称是： Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对**内存中的共享数据**进行操作的一种特殊指令。 

CAS的作用：CAS可以将比较和交换转换为原子操作，这个原子操作直接由CPU保证。

CAS可以保证共享变量赋值时的原子操作。

CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中。

**无cas操作**

```java
public class 无cas操作 {
    //1.定义一个共享变量num
    private static int num = 0;

    public static void main(String[] args) throws InterruptedException {
        //2.对num进行1000次的++操作
        Runnable increment = () -> {
            for (int i = 0; i < 1000; i++) {
                num++;
            }
        };
        List<Thread> list = new ArrayList<>();
        //3.使用5个线程来运行
        for (int i = 0; i < 5; i++) {
            Thread t = new Thread(increment);
            t.start();
            list.add(t);
        }
        for (Thread t:list
        ) {
            t.join();
        }
        //最终结果<5000
        System.out.println(num);
    }
}
```

结果<5000

**使用CAS进行原子操作**

```java
public class 有cas操作 {
    //1.定义一个共享变量num
    private static AtomicInteger atomicInteger = new AtomicInteger();

    public static void main(String[] args) throws InterruptedException {

        //2.对num进行1000次的++操作
        Runnable increment = () -> {
            for (int i = 0; i < 1000; i++) {
                atomicInteger.incrementAndGet();
            }
        };
        List<Thread> list = new ArrayList<>();
        //3.使用5个线程来运行
        for (int i = 0; i < 5; i++) {
            Thread t = new Thread(increment);
            t.start();
            list.add(t);
        }
        for (Thread t:list
             ) {
            t.join();
        }
        //最终结果=5000
        System.out.println("number= "+atomicInteger.get());
    }
}

```

结果=5000；

atomicInteger.incrementAndGet();元素的数值自增，会保证原子性。

### CAS原理

![image-20220116164032277](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116164032277.png)

AtomicInteger的源码我们可以看到，里面包含Unsafe类，其中提供了原子操作。Unsafe里面提供了CAS的操作。

#### Unsafe类

Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使 用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Unsafe对 象不能直接调用，只能通过反射获得。  Unsafe只有一个.class文件

![image-20220116170416967](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116170416967.png)

volatile 的主要作用有两点：1. 保证变量的内存可见性 2. 禁止指令重排序

#### Unsafe实现CAS

atomicInteger.incrementAndGet();的执行流程：

1. value赋值初始值0

   ![image-20220116172343034](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220116172343034.png)

   1. var1:atomicInteger
   2. var2:偏移量
   3. var5:旧的预估值（通过var1的内存地址和var2的偏移量来获取var5），即value的值
   4. var4:自增的值

2. 假如此时有两个线程t1,t2分别执行atomicInteger.incrementAndGet();
   1. t1线程进来，执行到var5=this.getIntVolatile(var1,var2)。此时var5=0
   2. 此时t2线程进来，执行到var5=this.getIntVolatile(var1,var2)。此时var5=0
   3. t1先执行this.compareAndSwapInt(var1,var2,var5,var5+var4)
      1. 此时进行旧的预估值（0）与新值（此时的value）的对比
      2. 新值：通过var1，var2来推断出内存中value的值，此时value的值为0，即新值为0
      3. t1获取的旧的预估值var5=0，此时t1的新值和旧的预估值**相同**。执行var5+var4的操作，给value+1，此时value的值为1。**并返回true，结束循环。**
   4. t2后执行this.compareAndSwapInt(var1,var2,var5,var5+var4)
      1. 此时进行旧的预估值（0）与新值（此时的value）的对比
      2. 新值：通过var1，var2来推断出内存中value的值，此时value的值为1，即新值为1
      3. t1获取的旧的预估值var5=0，此时t1的新值和旧的预估值**不相同**。**不执行赋值操作，并返回false；循环继续**
      4. 进入循环，重新获取预估值
         1. 此时再获取旧的预估值var5=1；
         2. 此时的新值value=1
         3. 预估值等于新值，value+1，此时value=2。返回true，结束循环。

#### 乐观锁和悲观锁

悲观锁从悲观的角度出发： 

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这 样别人想拿这个数据就会阻塞。因此**synchronized我们也将其称之为悲观锁**。JDK中的**ReentrantLock 也是一种悲观锁。性能较差！** 

乐观锁从乐观的角度出发: 

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所 以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更 新，如果有人修改则重试。 **CAS这种机制我们也可以将其称之为乐观锁**。**综合性能较好！**

CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，**适用于竞争不激烈、多核 CPU** 的场景下。 

1. 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。 
2. 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。

#### 总结

CAS的作用? Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理 器保证。 CAS的原理？CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，**如果内存地址V和旧的预期值 A相等就修改内存地址值为B**

### synchronized锁升级

在1.6在之前synchronized只有一个monitor这个重量级锁，1.6之后进行了优化，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性 自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为 了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。 

1.6之后，synchronized的锁过程—无锁--》偏向锁--》轻量级锁–》重量级锁

### Java对象布局

synchronized锁的状态切换有   无锁--》偏向锁--》轻量级锁–》，每一种锁的切换都有一种状态，这些状态存储在java对象的布局中。

在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。

![image-20220117093418345](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117093418345.png)

#### 1. 对象头

当一个线程尝试访问synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是 存在锁对象的对象头中的。



**HotSpot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类 型。**instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp 。

![image-20220117114316990](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117114316990.png)

从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot 源码中的 oop.hpp 文件中。

![image-20220117114456475](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117114456475.png)

普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark 和 _metadata



_mark 表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了**对象和锁有关的信息**

_metadata 表示类元信息，**类元信息存储的是对象指向它的类元数据(Klass)的首地址，**其中Klass表示 普通指针、 _compressed_klass 表示压缩类指针。



对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指 针，及对象指向它的类元数据的指针。

##### Mark Word

Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、 线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word对应的类 型是 markOop 。源码位于 markOop.hpp 中。

**32位计算机下：**

![image-20220117115820586](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117115820586.png)

**64位计算机下：**

![image-20220117115534858](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117115534858.png)

##### Klcass pointer

用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。

该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。

如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内 存。为了节约内存可以使用选项 -XX:+UseCompressedOops 开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：

1.  每个Class的属性指针（即静态变量） 
2. 每个对象的属性指针（即对象变量）
3. 普通对象数组的每个元素指针

当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对 象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。

**对象头大小**

对象头 = Mark Word + 类型指针（未开启指针压缩的情况下）

在32位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits

在64位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits；

#### 2. 实例数据

就是类中定义的成员变量。

#### 3. 对齐填充

对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅**起着占位符的作用**。

由于HotSpot VM的 自动内存管理系统要求**对象起始地址必须是8字节的整数倍**，换句话说，就是**对象的大小必须是8字节的 整数倍。**而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充 来补全。

#### 查看Java对象布局

导入依赖

```xml
  <dependency>
            <groupId>org.openjdk.jol</groupId>
            <artifactId>jol-core</artifactId>
            <version>0.9</version>
        </dependency>
```

查看LockObj的对象布局

```java
public class Demo01 {
    public static void main(String[] args) {
        LockObj obj = new LockObj();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());

    }
}

class LockObj {
    private int x;
}
```

打印信息

![image-20220117121211377](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117121211377.png)

原因：jvm默认开启了指针压缩： -XX:+UseCompressedOops

关闭指针压缩：-XX:-UseCompressedOops

![image-20220117121813892](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117121813892.png)

打印信息

![image-20220117121750922](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117121750922.png)

其中，Mark Word占用了8个字节

![image-20220117122119085](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117122119085.png)

Klclass占用了8个字节

![image-20220117122148652](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117122148652.png)

成员变量x占用了4个字节（注意，我们每添加一个成员变量，对应着都会多当前变量类型的数据大小）

![image-20220117122209507](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117122209507.png)

此时一共占用了20个字节，此时并不是虚拟机要求的对象的存储大小（即8的整数倍，因此又多填充了4个字节的数据）

![image-20220117122320804](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117122320804.png)

我们查看我们的对象头的value，并没有发现hashcode数据，因为我们没有调用hashcode的方法。

![image-20220117122618635](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117122618635.png)

调用hashcode方法并再次打印

```java
public class Demo01 {
    public static void main(String[] args) {
        LockObj obj = new LockObj();
        System.out.println("hashcode"+obj.hashCode());
        System.out.println("16进制的hashcode:"+Integer.toHexString(obj.hashCode()));
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}

class LockObj {
    private int x;
}
```

对象头中存储的是16进制的hashcode

![image-20220117141508347](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117141508347.png)

结果是反着来的。

### 偏向锁

#### 介绍

偏向锁是JDK 6中的重要引进，因为HotSpot作者经过研究实践发现，**在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。**

偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是**这个锁会偏向于第一个获得它的线程**，会在**对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID即可。**



不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的 CAS原子操作的性能消耗，不然就得不偿失了。

![image-20220117142217944](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117142217944.png)



#### 测试偏向锁

```java
public class Demo01 {
    public static void main(String[] args) {
        Thread mt = new MyThread();
        mt.start();

    }

}
class  MyThread extends Thread{
    static  Object obj = new Object();
    @Override
    public void run() {
        synchronized (obj){
            System.out.println(ClassLayout.parseInstance(obj).toPrintable());
        }
    }
}
```

打印结果：

![image-20220117142857991](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117142857991.png)

原因：

偏向锁在Java 6之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用 

-XX:BiasedLockingStartupDelay=0 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争 状态，可以通过 XX:-UseBiasedLocking=false 参数关闭偏向锁。

![image-20220117143459762](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117143459762.png)

#### 偏向锁原理

![image-20220117144424720](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117144424720.png)

持有偏向锁的线程以后每次进入这个锁相关的代码块，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。前提是在一条线程的情况下。

#### **偏向锁的撤销**

一旦有两个线程竞争锁的时候，就会撤销。

**流程：**

1. 偏向锁的撤销动作必须等待全局安全点 
   1. 全局安全点：这个点所有的线程都被停下来了
2. 暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态 
3. 撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态

#### **偏向锁的好处**

偏向锁是在**只有一个线程执行同步块时**进一步提高性能，**适用于一个线程反复获得同一锁**的情况。

偏向锁可以提高带有同步但无竞争的程序性能。 它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多 数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。 

在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。但在应用程序启动几秒钟之后才 激活，可以使用 -XX:BiasedLockingStartupDelay=0 参数关闭延迟，**如果确定应用程序中所有锁通常 情况下处于竞争状态，可以通过 XX:-UseBiasedLocking=false 参数关闭偏向锁。**

#### 总结

**偏向锁原理：**

当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。

同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时（都会与MarkWord中记录的ThreadId进行对比，在相等的情况下），虚拟机都可以不再进行任何同步操作，直接执行代码块内容，偏向锁的效率高。

![image-20220117145554267](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117145554267.png)

**偏向锁好处：**

偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。**偏向锁可以提高带有同步但无竞争的程序性能。**

### 轻量级锁

当有多条线程竞争偏向锁时，此时偏向锁会向轻量级锁转变。轻量级锁并不是时刻都有高性能，只是在特定的场景下相对于重量级锁，性能较高。因此，轻量级锁是不能代替重量级锁的。

引入轻量级锁的目的：在多线程**交替执行**同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要 替代重量级锁。

交替执行：线程1运行完运行线程2，而非线程1和线程2同时运行。（在同一时刻，交替进行，没有竞争）

#### 轻量级锁原理

当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁

1. 判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则JVM首先将在当前线程的栈帧 中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方 把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word复制到栈 帧中的Lock Record中，将Lock Reocrd中的owner指向当前对象。 
2.  JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00，执行同步操作。 
3.  如果失败(前两步骤失败)则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。

![image-20220117155534298](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117155534298.png)

#### 轻量级锁的释放

轻量级锁的释放也是通过CAS操作来进行的，将Lock Record中的数据还原提取这些数据的地方。

1. 取出在获取轻量级锁保存在Displaced Mark Word中的数据。 
2.  用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功。 
3.  如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。

对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如 果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁 比重量级锁更慢。

#### 轻量级锁的好处

在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。：

#### 总结

轻量级锁的原理是什么？

将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。

轻量级锁好处是什么？

在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。

### 自旋锁

#### 介绍

当有多条线程同时竞争共享资源时，此时轻量级锁会向重量级锁转变。但是，重量级锁的开销是非常的大的，因此，在转换为重量级锁之前，会走一个自旋锁，挣扎一下，争取不走重量级锁。

（栗子：你在火车上上厕所，花了大概五分钟到厕所门口，但是发现里面有人，此时你会立即回去吗？不会的，你会等待一下，假如你的等待限度是两分钟，如果两分钟之内，你可以上厕所了，那么你就可以直接进去。如果超过了你的等待限度五分钟，那么你有可能回到你的位置上，过几分钟再过来）。

等待的这个过程就是一个自旋锁的过程，你会在测试门口时刻关注里面是否有人出来。

回去的这个过程就是重量级锁的过程，你需要花费很长的时间。

#### 自旋锁原理

```java
 synchronized (Demo01.class) { ... System.out.println("aaa"); } 
```

重量级锁的实现是monitor，当一条线程t1在执行时，另一条线程t2也执行，此时t2会进入阻塞状态，等待t1执行完毕后，此时才会唤醒t2，t2才会去竞争CPU资源去运行。

线程的阻塞和唤醒需要CPU从用户态转换到核心态，频繁的阻塞和唤醒会增大CPU的压力。

重要的是，大多数情况下，**我们synchronized代码块中的内容是执行比较快的，我们共享数据的锁定只是很短的一段时间（比如上厕所），为了这段时间阻塞和唤醒线程并不值得。**如果物理机器有一个以上的处理器，能让两个 或以上的线程同时并行执行，我们**就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行 时间，看看持有锁的线程是否很快就会释放锁。**为了让线程等待，**我们只需让线程执行一个忙循环(自旋) , 这项技术就是所谓的自旋锁。**



**自旋锁开启**

自旋锁在JDK 1.4.2中就已经引入 ，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在 JDK 6中 就已经改为默认开启了。**自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而 不会做任何有用的工作，反而会带来性 能上的浪费。**因此，自旋等待的时间必须要有一定的限度，如果 在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。**自旋次数的默认值 是10次，用户可以使用参数-XX : PreBlockSpin来更改。**

问题: 自旋的次数不是特别好把控，因此引入适应性自旋



#### 适应性自旋

在JDK 6中引入了自适应的自旋锁。自适应意味着**自旋的时间不再固定了，而是由前一次在同一个锁上 的自旋时间及锁的拥有者的状态来决定。**

如果在同一个锁对象上，**自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持 续相对更长的时间**，比如100次循环。另外，如果对于某个锁，**自旋很少成功获得过，那在以后要获取 这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。**

有了自适应自旋，随着程序运行和性能监控 信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。

**查看Enter[I]源码**

当线程未争抢的资源的时候，会进行等待。等待的过程中，会先尝试获取锁，如果获取不到，会进行自旋。

![image-20220117163631722](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117163631722.png)

**固定次数的自旋**

![image-20220117163904539](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117163904539.png)

**适应性自旋**

![image-20220117164146576](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117164146576.png)

### 锁消除

锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到**不可能存在共享 数据竞争**的锁进行消除。

锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中， 堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们 是线程私有的，同步加锁自然就无须进行。(比如下方案例)

变量是否逃逸，对于虚拟机来说需要使用数据流分析来确 定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。

下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上 都没有同步。

![image-20220117212102377](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117212102377.png)

### 锁粗化

我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作 用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线 程也能尽快拿到锁。

如果一系列的连续操作都对同一个对 象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操 作也会导致不必要的性能损耗。

什么是锁粗化？JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放 到这串操作的外面，这样只需要加一次锁即可。

![image-20220117213652741](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117213652741.png)

### 写代码时，如何优化synchronized？

#### 1. 减少synchronized的范围

同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。

![image-20220117213920966](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117213920966.png)

#### 降低synchronized锁的粒度

将一个锁拆分为多个锁提高并发度

如Hashtable和ConcurrentHashMap的实现：

**Hashtable**：增删改查的方法上都有synchronized，这样我只要进行任何一个操作，其他操作都不能进行。

![image-20220117214251449](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117214251449.png)

![image-20220117214315333](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117214315333.png)

![image-20220117214328157](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117214328157.png)

**问题：**当我们往一侧添加元素时，原则上也可以在另一侧添加元素，这样并不会造成数据的错误。但是Hashtable在push方法上加了锁，当一个线程在push的时候，另一个线程必须等待，get也一样。

效率十分低下。

![image-20220117214417487](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117214417487.png)

**ConcurrentHashMap：**锁的力度相对较小，效率较hashtable有明显的提高。增删改查的方法上并没有直接加锁，而是在具体的某一需要共享的操作时，才进行加锁。

![image-20220117215030346](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117215030346.png)

![image-20220117215106751](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117215106751.png)



**put源码**

![image-20220117215231965](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117215231965.png)

![image-20220117215501594](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117215501594.png)

**LinkedBlockingQueue**

入队和出队使用不同的锁，提升效率。

![image-20220117215712714](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220117215712714.png)

#### 读写分离

读的时候不加锁，写入和删除的时候加锁

如：ConcurrentHashMap，CopyOnWriteArrayList，CopyOnWriteArraySet等。

# ReentrantLock

相对于 synchronized 它具备如下特点

1. 可中断
2. 可以设置超时时间
3. 可以设置为公平锁
   1. 排队：先到先得
4. 支持多个条件变量，即对与不满足条件的线程可以放到不同的集合中等待

与 synchronized 一样，都支持可重入

**特点：**

1. 可重入
2. 可打断
3. 锁超时
4. 公平锁
4. 支持多个条件变量

## **ReetractReadWriteLock**

https://jishuin.proginn.com/p/763bfbd2f538

问题：

- `ReentrantReadWriteLock`读写锁是什么，有什么用？

- - `ReentrantReadWriteLock`具有哪些特性？

- `ReentrantReadWriteLock`是怎么实现读写锁的获取？

- `ReentrantReadWriteLock`读写锁的释放



`ReentrantReadWriteLock`读写锁维护着一对锁，一个读锁和一个写锁。

通过分离读锁和写锁，使得对共享资源的访问分为读访问和写访问，多个线程可以同时对共享资源进行读访问，读写锁可以极大地提高并发量。但是同一时间只能有一个线程对共享资源进行写访问，其他所有读线程和写线程都会被阻塞。

#### ReentrantReadWriteLock具有哪些特性？





读写锁的主要特性：

1. 公平性：支持公平性和非公平性。
2. 重入性：支持重入。读写锁最多支持65535个递归写入锁和65535个递归读取锁。
3. 锁降级：遵循获取写锁、获取读锁在释放写锁的次序，写锁能够降级成为读锁
4. 读写锁除了读读不互斥，读写、写读、写写都是互斥的
   1. 多线程都只读的时候，不互斥
   2. 多个线程中，只要有一个线程是写操作，那么对其他线程都是互斥的

## volatile

volatile 的主要作用有两点：1. 保证变量的内存可见性 2. 禁止指令重排序

通过读写屏障来保证内存可变性

## 线程池

线程池的执行流程：

运行流程： 

1. 线程池创建，准备好 core 数量的核心线程，准备接受任务 

2. 新的任务进来，用 core 准备好的空闲线程执行。 
   1. core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队列获取任务执行 
   2. 阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量 
   3. max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自 动销毁。最终保持到 core 大小 
   4. 如果线程数开到了 max 的数量，还有新任务进来，就会使用 reject 指定的拒绝策 略进行处理 

3、所有的线程创建都是由指定的 factory 创建的。

[面试突击30：线程池是如何执行的？拒绝策略有哪些？ - 掘金 (juejin.cn)](https://juejin.cn/post/7075132214257827877#heading-0)

![image-20220914165758876](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220914165758876.png)

面试题目：

**一个线程池**core 7 max 20 ，queue：50，**100并发进来怎么分配的；** 

先有 7 个能直接得到执行，接下来 50 个进入队列排队，在多开 13 个继续执行。现在 70 个 

被安排上了。剩下 30 个默认拒绝策略。
