# 基础

## 面向对象分析/设计/程序设计

### 面向对象分析（OOA）

着重分析问题域和系统责任，与测试无关。

1. 认定对象（确定实体）
2. 组织实体（对象抽象成类，建立类结构）
3. 对象间的相互作用
4. 基于对象的操作

### 面向对象设计

将面向对象分析创建的分析 模型转化为设计模型，目的定义系统构造蓝图。

在面向对象分析模型的基础上，包含对OOA对应的5个活动。

1. 识别类及对象
2. 定义属性
3. 定义服务
4. 识别关系
5. 识别包

![image-20211028151211036](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151211036.png)

1. 实体类主要负责数据和业务逻辑；

2. 边界类负责和用户进行交互，即用户界面；

3. 控制类则负责实体类和界面类的交互。             

## 动静态绑定

编译：静态

运行：动态

![image-20211015155525571](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015155525571.png)

 　　在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。

 　　动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以，父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送

## 面向对象方法

1. 面向对象开发方法有Booch方法、Coad方法和OMT方法。Jackson方法是一种面向数据结构的开发方法。        

## 语言特点

1. XML （可扩展标记语言）是标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 
2. Python是一种面向对象、解释型计算机程序设计语言。

3. Prolog是逻辑型程序设计语言。

4. C++为面向对象的编译型语言，而非解释型语言。        

5. php适合做动态网页处理     

   ![image-20211028115655551](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028115655551.png)

## 对象特性

![image-20211028120108818](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028120108818.png)

在面向对象技术中，对象是基本的运行时的实体，它既包括数据（属性），也包括作用于数据的操作（行为）。

一个对象把属性和行为封装为一个整体，与其他对象之间有清晰的边界，有良好定义的行为和可扩展性。对象位置和数量，由使用其的对象或系统确定。             

# UML各图示例

## 用例图

1. 题干有关于项目的相关描述，扣掉图中的某些用例，让考生猜。
2. 根据题目的意思，分析两个用例意见的关系，包含，扩展，泛化

![image-20211017152005184](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152005184.png)

## 类图与对象图

![image-20211017152401604](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152401604.png)

**多重度**

![image-20211017152423572](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152423572.png)

2..*  至少对应两个

**关系**

![image-20211018091732945](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211018091732945.png)

![image-20211028153215115](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028153215115.png)

注意：对象图的对象名会有：标识，并且对象图的关联关系一般不会出现多重度。

根据图示B依赖于A，也就是说，A发生变化会影响B，但是反过来，当B的一个实例被删除，不会影响A的实例。             

## 顺序图

表现处理事务时的时间顺序。

![image-20211017152709095](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017152709095.png)

## 活动图

和程序流程图相近，能表示整个执行流程和状态。

考试时，通常会抠掉某一部分，让你填完整。

**活动图形式一：**

![image-20211028122828859](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028122828859.png)

**活动图形式二：**

![image-20211017153141299](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017153141299.png)

![image-20211028151524564](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151524564.png)

该活动图能同时运行的最大线程数为2，从粗线分支位置开始，分为2个并行线程。

## 状态图

表现状态的变迁，属于动态图。以状态为节点

考试：给你状态，涉及多种状态之间的变迁，让你填充状态或状态的条件。

![image-20211017155409107](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017155409107.png)

  ![image-20211028151054131](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151054131.png)

事件触发一个没有特定监护条件的迁移，对象不一定离开当前状态。

## 通信图

顺序图的另一种表达方式，通信图不强调时间顺序。

![image-20211017155702173](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211017155702173.png)

# 对象之间的关系

1. 泛化：一个类与它的一个或多个细化类之间的关系，表达一般与特殊的关系
2. 实现：
3. 依赖
4. 关联：是类与类之间的一种结构关系
5. 聚合
6. 组合：组合是一种聚合关系，其中整体负责其部分的创建和销毁，如果整体不存在了，部分也将不存在。
7. 聚集：聚集是一种关系，其中一个较大的整体类包含一个或多个较小的部分类；相反地，一个较小的部分类是一个较大的整体类的一部分。 

## 领域模型

定义领域模型是面向对象分析的关键步骤之一。领域模型是从按对象分类的角度来创建对象领域的描述，包括**定义概念、属性和重要的关联，**其结果用一组显示领域概念和对象的图形一一类图来组织，图中还包括多重性、关联关系、泛化/特化关系以及聚合关系等。             

## 动态与静态图

![image-20211027094144992](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027094144992.png)

## 部署图

![image-20211015150134575](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015150134575.png)

![image-20211027104058298](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027104058298.png)

部署图描述了一个运行时的硬件结点，以及在这些结点上运行的软件组件的静态视图。 

部署图显示了系统的硬件，安装在硬件上的软件，以及用于连接异构的机器之间的中间件。因此它是在实施阶段被使用。

消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。

## 类图

## 各类图特点汇总

组件图（component diagram）展现了一组组件之间的组织和依赖，专注于系统的静态实现视图，与类图相关，通常把组件映射为一个或多个类、接口或协作。

部署图（deployment diagram）展现了运行处理节点以及其中构件的配置。部署图给出了体系结构的静态实施视图。它与构件图相关，通常一个节点包含一个或多个构件。

类图（classdiagram）展现了一 组对象、接口、协作和它们之间的关系，在开发软件系统时，类图用于对系统的静态设计视图建模。             

# 设计模式

![image-20211015105024037](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015105024037.png)

![image-20211015105047868](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015105047868.png)



![image-20211015145447625](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015145447625.png)

适配器模式将一个接口转换成为客户想要的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。

桥接模式·将抽象部分与实现部分分离，使得它们两部分可以独立地变化。

组合模式组合多个对象形成树型结构以表示整体—部分的结构层次。

装饰器模式动态地给一个对象增加其他职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。

状态模式为类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。状态A做什么事情，状态B做什么事情。

![image-20211015145740138](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211015145740138.png)



命令模式的特点为：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。本题描述为命令模式。

 职责链模式（Chain of Responsibility）：通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。

 观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

 策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化。

责任链（Chain of Responsibility）模式将多个对象的请求连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止，避免请求的发送者和接收者之间的耦合关系。

![image-20211027103655903](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027103655903.png)

观察者（Observer）模式定义对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 在上述观察者模式的类图中，Subject （目标）知道其观察者，可以有任意多个观察者观察同一个目标，提供注册和删除观察者对象的接口。Observer （观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。ConcreteSubject （具体目标）将有关状态存入各ConcreteObserver对象，当它的状态发生改变时，向它的各个观察者发出通知。ConcreteObserver （具体观察者）维护一个指向ConcreteSubject对象的引用，存储有关状态，实现Observer的更新接口以使自身状态与目标的状态保持一致。             

# 软件项目活动图

![image-20211028115750566](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028115750566.png)

用时最长的路径即关键路径。

2---5---7---8为关键路径，2587这些都是关键路径上的点。

# 软件开发

## 封装

封装是一种信息隐藏技术，其目的是使对象（组件）的使用者和生产者分离，也就是使其他开发人员无需了解所要使用的软件组件内部的工作机制，只需知道如何使用组件，即组件提供的功能及其接口。             

![image-20211028151338854](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028151338854.png)

## 多态

![image-20211027082548446](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211027082548446.png)

在面向对象技术中，不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。

 多态分为两种：通用的多态和特定的多态。两者的区别是前者对工作的类型不加限制，允许对不同类型的值执行相同的代码；后者只对有限数量的类型有效，而且对不同类型的值可能要执行不同的代码。

多态有参数多态、包含多态、过载多态和强制多态四类。

通用多态：参数多态和包含多态。    特定多态：过载多态和强制多态

1. 参数多态:采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。(类似模板类吧!)
2. 包含多态:同样的操作可用于一个类型及其子类型。（注意是子类型，不是子类。）包含多态一般需要进行运行时的类型检查。
3. 过载多态：同一个名（操作符﹑函数名）在不同的上下文中有不同的类型。
   1. 俗的讲法，就是c++中的函数重载。在此处中“overload”译为“过载”，其实就是所谓的“重载”，也许“overload”就应翻译为“过载，重载”吧，那“override”就只能是“覆盖”了。
4. 强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。
   1. 举个例子，比如，int+double，编译系统一般会把int转换为double，然后执行double+double运算，这个int-》double的转换，就实现了强制多态，即可是隐式的，也可显式转换。

![image-20211028152320843](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028152320843.png)

多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次。**一个对象发送通用消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定**，以实现在这些低层次上生成的对传给用消息以不同的响应。             

## 多重继承

![image-20211028153018120](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20211028153018120.png)

多重继承是编程语言中的概念，多重继承指的是一个类可以继承另外一个类，而另外一个类又可以继承别的类，比如A类继承B类，而A类又可以继承C类，这就是多重继承。多重继承可能造成混淆的情况，出现二义性的成员。             



