# 1.1 数组

数组链表代表着计算机最基本的两种存储形式：**顺序存储和链式存储**，所以他俩可以算是最基本的数据结构。

数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快 慢指针。 

[#链表双指针系列 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2120596033251475465)

[#数组双指针 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2120601117519675393)

此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。

## 前缀和

作图链接：https://www.processon.com/view/link/61e260db7d9c0806a8a8beec

### 引入前缀和

**使用场景：**原始数组不会被修改的情况下，频繁查询某个区间的累加和。

**例题：**

![image-20220115102016075](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115102016075.png)

如：求数组{1,2,5,6,-2,5,4} 中索引为1到索引为3的和。

**使用for循环累加**

```java
//方式一：for循环遍历，时间复杂度为O（N）
class NumArray01 {

    private int[] nums;

    public NumArray01(int[] nums) {
        this.nums = nums;
    }

    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}

   public static void main(String[] args) {
        int[] nums = {1,2,5,6,-2,5,4};
        NumArray01 NumArray01 = new NumArray01(nums);
        int i = numArray.sumRange(1, 3);
        System.out.println(i);
    }
```

问题：时间复杂度为O（n） 

思考：如果我能获取索引为3之前所有元素的和（包含3），又获取索引为1之前元素的所有和（不包含1），二者相减，不就获取到了索引为1到索引为3之间元素的和。

**改进，使用前缀和**

前缀和：nums 的第 0 项到当前项的和。

![image-20220111113457280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111113457280.png)

此时，如果我们要计算索引1-3所有元素之和。

可以使用preSum(4)-preSum(1）即可获得所求结果。

```java
//方式二：前缀和，时间复杂度为O（1）
class NumArray02 {

    //方式二：
    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }
}

    public static void main(String[] args) {
        int[] nums = {-2, 0, 3, -5, 2, -1};
        NumArray02 numArray02 = new NumArray02(nums);
        int i = numArray02.sumRange(1, 3);
        System.out.println(i);
    }
```

### 相应规则

1. 前缀和：nums 的第 0 项到 当前项 的和。
2. 定义 prefixSum 数组，prefixSum[x]：第 0 项到 第 x 项 的和。
   prefixSum[x] = nums[0] + nums[1] +…+nums[x]
   prefixSum[x]=nums[0]+nums[1]+…+nums[x]
3. nums 的某项 = 两个相邻前缀和的差：
   nums[x] = prefixSum[x] - prefixSum[x - 1]
   nums[x]=prefixSum[x]−prefixSum[x−1]
4. nums 的 第 i 到 j 项 的和，有：
   nums[i] +…+nums[j]=prefixSum[j] - prefixSum[i - 1]
   nums[i]+…+nums[j]=prefixSum[j]−prefixSum[i−1]
5. 当 i 为 0，此时 i-1 为 -1，我们故意让 prefixSum[-1] 为 0，使得通式在i=0时也成立：
   nums[0] +…+nums[j]=prefixSum[j]
   nums[0]+…+nums[j]=prefixSum[j]

**前置数组初始化**

![image-20220111113457280](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111113457280.png)

前缀和数组多了一个空间，存储0，目的就是为了适配nums[i]+…+nums[j]=prefixSum[j]−prefixSum[i−1]这个公式。

preSum默认从索引1处开始赋值，preSum[0]默认为0；

**指定索引处的值累加**

如获取原始数组索引1到3的值。

```java
preSum[4] - this.preSum[1];
```

### 模板

```java
class NumArray02 {

    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }

}

```

preSum[i] 就代表着 nums[0..i-1] 所有元素的累加和，如果我们想求区间 nums[i..j] 的累加和，只要 计算 preSum[j+1] - preSum[i] 即可，⽽不需要遍历整个区间求和。

### 练习

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

![image-20220115105630680](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115105630680.png)

方式一：使用for循环遍历，通过累加获取结果

```java
//方式一：for循环遍历，时间复杂度为O（N）
class NumArray01 {

    private int[] nums;

    public NumArray01(int[] nums) {
        this.nums = nums;
    }

    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}
```

方式二：使用数组的前缀和

```java
//方式二：前缀和，时间复杂度为O（1）
class NumArray02 {

    //方式二：
    private int[] preSum;

    public NumArray02(int[] nums) {
        //长度在原来的基础上+1，目的是维护通用的公式。
        this.preSum = new int[nums.length + 1];
        //为前置数组赋值。
        for (int i = 1; i < preSum.length; i++) {
            this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
        }
    }
    //求和指定区间的值。
    public int sumRange(int left, int right) {
        return this.preSum[right + 1] - this.preSum[left];
    }

}
```

#### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

参考题解：[从暴力法开始优化 「二维前缀和」做了什么事 | leetcode.304 - 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qian-zhui-he-jian-dan-tui-dao-tu-sqekv/)

![image-20220115105555785](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115105555785.png)

##### 方式一：一维前缀和

使用累加思想，将每一排数据进行累加，最后在指定区间内进行累加并相减。

![image-20220111114955276](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111114955276.png)

问题：最后累加时，查询 n 行的子阵列，每次就查询花费 O(n)，比 O(n^2) 好

```java
class NumMatrix01 {
    private int[][] preMatrix;

    public NumMatrix01(int[][] matrix) {
        preMatrix = new int[matrix.length + 1][matrix[0].length + 1];
        for (int i = 1; i < preMatrix.length; i++) {
            for (int j = 1; j < preMatrix[0].length; j++) {
                preMatrix[i][j] = preMatrix[i][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        int result = 0;
        for (int i = row1; i <= row2; i++) {
            result += preMatrix[i + 1][col2 + 1] - preMatrix[i + 1][col1];
        }
        return result;
    }
}
```

##### 方式二：二维前缀和

**赋值操作**

二维前缀和指从0，0开始，到指定索引处，所形成的矩形空间的数值之和。

如：求1，1的前缀和。
（蓝色框前缀和3+0）+（红色框前缀和3+5）+当前位置元素6-（红蓝框相交3）=3+8+6-3=14

![image-20220111120446343](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111120446343.png)

解析：

问：0,0这一块的面积是多少？

问：0,0到0,1这一块的面积是多少？

问：0,0到1,0这一块的面积是多少？

问：1,1这一块的面积是多少？

**取某一范围内的元素值和**

如：取1，1到3，3之间的元素和。

![image-20220111152810871](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111152810871.png)

```java
class NumMatrix02 {
    private int[][] preMatrix;

    public NumMatrix02(int[][] nums) {
        preMatrix = new int[nums.length + 1][nums[0].length + 1];
        for (int i = 1; i < preMatrix.length; i++) {
            for (int j = 1; j < preMatrix[0].length; j++) {
                preMatrix[i][j] = preMatrix[i][j - 1]
                        + preMatrix[i - 1][j]
                        - preMatrix[i - 1][j - 1]
                        + nums[i - 1][j - 1];
            }
        }
    }
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return preMatrix[row2 + 1][col2 + 1]
                - preMatrix[row2 + 1][col1]
                - preMatrix[row1][col2 + 1]
                + preMatrix[row1][col1];
    }
}
```

#### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

##### 方式一：前缀和+双层for

时间复杂度为O（n^2）

![image-20220111153801420](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220111153801420.png)

同理，假如k=13。 在前缀数组中。14-1=13.说明包含了一段连续的元素相加=13。对比到原始数组中就是子数组2+5+6。

```java
class Solution01 {
    public static int subarraySum(int[] nums, int k) {
		//获取前缀和数组
        int[] preSum = new int[nums.length + 1];
        for (int i = 1; i < preSum.length; i++)
            preSum[i] = preSum[i - 1] + nums[i - 1];
        //符合要求的元素数量
        int count = 0;
        //如果后续-前序=k，说明连续。符合要求
        for (int i = 1; i < preSum.length; i++) {
            for (int j = 0; j < i; j++) {
                if (preSum[i] - preSum[j] == k) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

##### 方式二：前缀和+map

时间复杂度为O（n）

题解：

[前缀和的运用，一步步优化 | 560. 和为K的子数组 - 和为 K 的子数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/)

视频讲解：

[LeetCode#560 和为K的子数组 | 前缀和 哈希表优化_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16K411W78r/?spm_id_from=333.788.recommend_more_video.1)

假如我们现在有两个前缀和4和6，并且这两个前缀分别出现了1次和0次。下一个前缀和是8，我们要求的k是4，8-4=4.即如果在前缀和8之前存在前缀和为4的前缀，那么我们就找到了符合要求的元素。前缀和为4的元素是存在的，并且有1个，现在又出现了一个符合要求的前缀和，因此符合要求的数量又添加了1。

在此，我们并不关心前缀和的位置，我们只关心前缀和的数量。

```java
class Solution02 {
    public static int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int preFixSum = 0;//记录前缀和
        int count = 0;//记录符合要求的数量
        for (int num : nums) {
            preFixSum += num;
            //判断之前是否有符合的前缀和，有的话count+=
            if (map.containsKey(preFixSum - k))
                count += map.get(preFixSum - k);
            //存入当前的前缀和入map，当前前缀和如果map中有则+1，没有则默认为1
            map.put(preFixSum, map.getOrDefault(preFixSum, 0) + 1);
        }
        return count;
    }
}
```

## 差分数组

### 引入查分数组

**使用场景：**差分数组的主要适⽤场景是频繁对原始数组的 某个区间的元素进⾏增减。

**举例：**

⽐如说，我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给...

常规的思路:区间 nums[i..j] 加上 val⼀个 for 循环给它们都加上.这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改⾮常频繁，所以效率会很低下。

```java
 		 //需求：将nums的索引1-3的元素值都+1
        int[] nums = {8, 2, 6, 3, 1};
        //方法一：O（N）
        for (int i = 1; i <= 3; i++) {
            nums[i] += 1;
        }
```

这⾥就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造⼀个 diff 差 分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差：

**生成差分数组**

![image-20220112083326756](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220112083326756.png)

diff[1]=nums[1]-nums[0]

```java
       //需求：将nums的索引1-3的元素值都+1
        int[] nums = {8, 2, 6, 3, 1};
        //方法二：使用差分数组
        //1.将原数组转换为差分数组   即diff的某一项diff[i]，对应着nums的这一项nums[i]减去nums这一项他前一项的值nums[i-1]
        int[] diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
```

**差分数组还原**

**推导：**

推导diff与nums的关系

1. 推导1

   1. diff[0]=nums[0]
   2. 推导出：nums[0]=diff[0]

2. 推导2

   1. diff[1]=nums[1]-nums[0]

   2. 推导出：num[1]=diff[1]+nums[0]

3. 推导3

   1. diff[2]=nums[2]-nums[1]

   2. 推导出：nums[2]+diff[2]+nums[1];

4. 结论：nums[i]=diff[i]+nums[i-1];

通过差分数组推导出原数组。

![image-20220112084138048](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220112084138048.png)

res[1]=res[0]+diff[1]

```java
        int[] res = new int[diff.length];
        res[0] = diff[0];
        for (int i = 1; i < res.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
```

此时，如果我们给diff[1]+3。即-6变为-3，那么res[1]对应着也+了3，因为差分数组还原时，后一项的每一个res都依赖前一项的res的值，因此res[2],res[3]都对应着+3等等。

**差分数据累加**

如果，我们要求原数组索引1—3之间的元素都+3，其它索引位置元素不变。那么索引为4的元素以及4之后的元素因为受到了之前+3的影响，因此需要在diff索引为4的位置再-3，才能满足对应的要求。

![image-20220115114348763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115114348763.png)

![image-20220115114028348](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115114028348.png)diff[1]+3,diff[4]-3;

```java
    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j+1] -= val;
    }
```

注意：当j+1==diff.length时，如果j为数组的最后一个元素，不需要再减的操作。

### 模板

```java
//差分数组模板
class Difference {
    //差分数组
    private int[] diff;

    //初始化一个数组，区间操作在此数组上进行
    public void proDiff(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        //构建差分数组
        for (int i = 1; i < diff.length; i++)
            diff[i] = nums[i] - nums[i - 1];
    }

    //连续区间内，值的修改
    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j + 1] -= val;
    }

    //结果还原
    public int[] result() {
        int[] res = new int[diff.length];
        for (int i = 1; i < res.length; i++)
            res[i] = res[i - 1] + diff[i];
        return res;
    }

    //业务处理
    public int[] getModifiedArray(int length, int i, int j, int val) {
        int[] nums = new int[length];
        //形成差分数组
        proDiff(nums);
        //进行累加
        increment(i, j, val);
        //返回结果
        return result();
    }
}
```

### 练习

#### [1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)

![image-20220115114743692](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115114743692.png)

套用模板即可

```java
class Solution01 {
    //差分数组
    private int[] diff;

    //初始化一个数组，区间操作在此数组上进行
    public void proDifference(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        //构建差分数组
        for (int i = 1; i < diff.length; i++)
            diff[i] = nums[i] - nums[i - 1];
    }

    public void increment(int i, int j, int val) {
        diff[i] += val;
        //如果j+1==diff.length,说明j是数组的最后一个元素，则不需要再减去val了
        if (j + 1 < diff.length) diff[j+1] -= val;
    }

    //结果返回
    public int[] result() {
        int[] res = new int[diff.length];
        res[0] = diff[0];
        for (int i = 1; i < res.length; i++)
            res[i] = res[i - 1] + diff[i];
        return res;
    }

    //业务处理
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] nums = new int[n];
        proDifference(nums);
        for (int l = 0; l < bookings.length; l++) {
            int i = bookings[l][0];
            int j = bookings[l][1];
            int val = bookings[l][2];
            increment(i - 1, j-1, val);
        }
        return result();
    }

}
```

#### [待做：1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)

## 滑动窗口

作图链接：https://www.processon.com/view/link/61e2608607912973ef267d5c

### 引入滑动窗口

**使用场景：**在主串中寻找子串

**举例：**

![image-20220115115603218](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115115603218.png)

分析：

我们的目的是找到主串中**最短**的子串，子串中包含目标串，不需要关注目标串中元素的**排列顺序**。因此，我们只需要找到主串中的某一个子串含有目标串的每个元素并且相等元素的数量一致切这个子串最短即可。

解析：

子串肯定有一个开始索引和结束索引。因此我们可以使用双指针分别表示子串的开始和结束索引。（即窗口的左右边界）

我们要保证子串中含有目标串，并且每个元素的数量一致，因此需要记录目标串元素的数量。（使用map或int记录元素数量）

可能有多个子串中包含目标串，因此我们需要一个长度变量来比较自创长度（即窗口的宽度）

**查找元素ABC**

1. 初始条件

   ![image-20220115132950497](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115132950497.png)

2. 找到第一个符合目标串的元素

   ![image-20220115133021255](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133021255.png)

3. 找到符合要求的目标串的子串

   ![image-20220115133238653](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133238653.png)

4. 缩短窗口的宽度，力争获取到最小符合要求的子串。

   ![image-20220115133331144](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133331144.png)

5. 此时，子串已经不符合要求，窗口向右移动，寻找下一个满足要求的子串。即寻找下一个A。

   ![image-20220115133544864](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133544864.png)

6. 窗口继续缩小，直到不符合要求。缩小的时候，是通过left的移动进行缩小。此时窗口长度还是6。不用改变。

   ![](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115134048308.png)

7. 依次类推，直到最后一轮

   ![image-20220115133832818](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115133832818.png)

```java
class Solution01 {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        //1.记录需要字串的数量
        Map<Character, Integer> tMap = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            tMap.put(t.charAt(i), tMap.getOrDefault(t.charAt(i), 0) + 1);
        }
        //2.窗口左边界，窗口右边界，窗口的起始，窗口长度
        int left = 0, right = 0, winStart = 0, windowLength = Integer.MAX_VALUE;
        //3.临界条件，右侧指针到尾
        while (right < s.length()) {
            char c = s.charAt(right);
            if (tMap.containsKey(c)) {
                //如果map中包含此索引，则说明当前位置含字串的元素，所需的字串元素数量-1.
                tMap.put(c, tMap.getOrDefault(c, 0) - 1);
            }
            //当当前串中包含字串时。判断能否缩短当前字串，如果移动左指针实现。
            while (checkNum(tMap) == true) {
                if (right - left < windowLength) {
                    winStart = left;
                    windowLength = right - left+1;
                }
                char leftNum = s.charAt(left);
                if (tMap.containsKey(leftNum)) {
                    //如果删除了字串的一个元素，但是这个元素时要求的字串中包含的元素，则需求的字串元素数量+1
                    tMap.put(leftNum, tMap.getOrDefault(leftNum, 0) + 1);
                }
                left++;
            }
            right++;
        }
        //防止出现主串和字串长度一样，但是又不符合条件。  如测试案例  "aa"  "bb"
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(winStart, winStart + windowLength);
    }

    public boolean checkNum(Map<Character, Integer> tMap) {
        boolean flag = true;
        for (Character key : tMap.keySet()) {
            if (tMap.get(key) > 0) flag = false;
        }
        return flag;
    }
}
```

注意：substring（beginIndex,endIndex）方法的使用

传入的beginIndex和endIndex，截取的并不是这两个索引之间的元素，而是在beginIndex为其实索引，生成新的字符串长度为（endIndex - beginIndex）。

```java
    public String substring(int beginIndex, int endIndex) {
        if (beginIndex < 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        if (endIndex > value.length) {
            throw new StringIndexOutOfBoundsException(endIndex);
        }
        int subLen = endIndex - beginIndex;
        if (subLen < 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return ((beginIndex == 0) && (endIndex == value.length)) ? this
                : new String(value, beginIndex, subLen);
    }
```

### 练习

#### 测试案例

1. 目标子串大于主串  false    如： 主串:  “bb”,   目标字串"bbbb"
2. 目标字串与主串一样     如： 主串:  “bb”,   目标字串"bb"
3. 主串全由目标字串组成   如 ： 主串：“bbbbb”,   目标字串"b"

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

题解：[【数据结构和算法】滑动窗口，视频演示 - 最小覆盖子串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimum-window-substring/solution/shu-ju-jie-gou-he-suan-fa-hua-dong-chuan-p6ip/)

```java
class Solution01 {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        //1.记录需要字串的数量
        Map<Character, Integer> tMap = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            tMap.put(t.charAt(i), tMap.getOrDefault(t.charAt(i), 0) + 1);
        }
        //2.窗口左边界，窗口右边界，窗口的起始，窗口长度
        int left = 0, right = 0, winStart = 0, windowLength = Integer.MAX_VALUE;
        //3.临界条件，右侧指针到尾
        while (right < s.length()) {
            char c = s.charAt(right);
            if (tMap.containsKey(c)) {
                //如果map中包含此索引，则说明当前位置含字串的元素，所需的字串元素数量-1.
                tMap.put(c, tMap.getOrDefault(c, 0) - 1);
            }
            //当当前串中包含字串时。判断能否缩短当前字串，如果移动左指针实现。
            while (checkNum(tMap) == true) {
                if (right - left < windowLength) {
                    winStart = left;
                    windowLength = right - left+1;
                }
                char leftNum = s.charAt(left);
                if (tMap.containsKey(leftNum)) {
                    //如果删除了字串的一个元素，但是这个元素时要求的字串中包含的元素，则需求的字串元素数量+1
                    tMap.put(leftNum, tMap.getOrDefault(leftNum, 0) + 1);
                }
                left++;
            }
            right++;
        }
        //防止出现主串和字串长度一样，但是又不符合条件。  如测试案例  "aa"  "bb"
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(winStart, winStart + windowLength);
    }

    public boolean checkNum(Map<Character, Integer> tMap) {
        boolean flag = true;
        for (Character key : tMap.keySet()) {
            if (tMap.get(key) > 0) flag = false;
        }
        return flag;
    }
}
```

#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

[LeetCode.567.字符串的排列_哔哩哔哩_bilibili](https://www.bilibili.com/video/av71240379/)

[注释超详细的滑动窗口讲解，附本题躲坑指南 - 字符串的排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutation-in-string/solution/zhu-shi-chao-xiang-xi-de-hua-dong-chuang-rc7d/)

[Java 滑动窗口 - 字符串的排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutation-in-string/solution/java-hua-dong-chuang-kou-by-yi-fang-0826-ge5j/)

解法：

- [x] map解法

```java
class Solution02 {
    public boolean checkInclusion(String s1, String s2) {
        int l1Len = s1.length();
        int l2Len = s2.length();
        //目标子串长度大于主串长度
        if (l1Len > l2Len) return false;
        //记录目标子串所需各个元素的数量
        Map<Character, Integer> s1Map = new HashMap<>();
        for (int i = 0; i < l1Len; i++)
            s1Map.put(s1.charAt(i), s1Map.getOrDefault(s1.charAt(i), 0) + 1);
        Map<Character, Integer> s2Map = new HashMap<>();
        int left = 0, right = 0;
        while (right < l2Len) {
            //窗口大小满足字串的长度
            while ((right - left + 1) == l1Len) {
                //当两个map相同时，达到目的
                if (s1Map.equals(s2Map)) return true;
                //当right+1==length时，到了最后s2的最后一个字符，之后的right++操作会造成越界
                if (right + 1 < l2Len) {
                    right++;
                    //窗口向右活动一个空间
                    //添加新元素的数量到窗口
                    s2Map.put(s2.charAt(right), s2Map.getOrDefault(s2.charAt(right), 0) + 1);
                    //减去旧窗口中元素的数量
                    s2Map.put(s2.charAt(left), s2Map.getOrDefault(s2.charAt(left), 0) - 1);
                    //移除窗口中不再使用的元素
                    if (s2Map.get(s2.charAt(left)) == 0) s2Map.remove(s2.charAt(left));
                    //右指针偏移
                    left++;
                } else {
                    //如果到了最后一个字符，还没有满足要求的窗口，则不成立
                    return false;
                }
            }
            //往窗口中添加元素
            s2Map.put(s2.charAt(right), s2Map.getOrDefault(s2.charAt(right), 0) + 1);
            right++;
        }
        return false;
    }
}
```

参考解法：

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int len1 = s1.length();
        int len2 = s2.length();
        
        if(len1 > len2)
            return false;
        
        HashMap<Character, Integer> mapS1  = new HashMap<>();
        HashMap<Character, Integer>  mapS2 = new HashMap<>();
        
        for(char ch : s1.toCharArray())
            mapS1.put(ch, mapS1.getOrDefault(ch, 0) + 1);
        
        int index = 0;
        for(int i = 0; i < len1; i++, index++){
            char ch = s2.charAt(i);
            mapS2.put(ch, mapS2.getOrDefault(ch, 0) + 1) ;
        }
        
        while(index < len2){
            if(mapS2.equals(mapS1))
                return true;
            
            char before = s2.charAt(index - len1);
            char after  = s2.charAt(index);
            
            mapS2.put(before, mapS2.get(before) - 1);
            if(mapS2.get(before) == 0)
                mapS2.remove(before);
            mapS2.put(after, mapS2.getOrDefault(after, 0) + 1);

            index++;
        }
        
        return mapS2.equals(mapS1);
    }
}
```

- [ ] 数组解法：第二轮

## 二分查找

作图链接：https://www.processon.com/view/link/61e260ba1e085306c96d14bf

### 引入二分查找

举例：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

![image-20220115140626066](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220115140626066.png)

##### 我的解法

```java
public class 二分查找_704 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums01 = {-1, 0, 3, 5, 9, 12, 18, 21, 35, 48, 52, 60};
        System.out.println(solution.search(nums01, 12));
    }
}
class Solution {
    public int search(int[] nums, int target) {
        int first = 0, last = nums.length - 1, mod = nums.length / 2;
        while (first < last) {
            //缩短区间
            if (nums[mod] == target) {
                return mod;
            } else if (nums[mod] > target) {
                last = mod - 1;
                mod = (mod - first) / 2;
            } else if (nums[mod] < target) {
                first = mod + 1;
                mod = mod + (last - mod) / 2;
            }
        }
        //用于最后last=fist这个元素的值与target的比较。
        if (nums[last] == target) return last;
        return -1;
    }
}

```

![image-20220114151602823](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114151602823.png)

first：当前筛选区间的第一个元素位置

last:当前筛选区间的最后一个元素位置

mod：将筛选区间折半后，分割两区间元素的位置。（区间长度/2）

以first和last作为二分后，筛选元素的区间。以mod为每次二分的分界点。

注意：first+1和last-1表示可筛选的元素区间

问题：

1. 分界点我的选择是以所剩元素的长度进行的二分，造成的问题及时mod维护特别繁琐,并且还时不时会出现越界问题，加大了问题的复杂度。
2. 对最后一个元素的处理，即当first==last的时候，再进行while循环时，有时会产生死循环。此时mod不发生改变，而last或first却发生改变。
3. 而first+1=last时，此时如果直接返回-1，那么就会少判断最后一个元素。因此最后的返回时，还需要再判断。

**查找元素9**

1. 初始：first=0，last=length-1，mod=length/2

   ![image-20220114153045199](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114153045199.png)

2. 第二轮：9<nums[mod]，目标区间在左侧。first=0,mod =(mod - first) / 2,last=mod-1

   ![image-20220114152035363](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114152035363.png)

3. 第三轮：9<nums[mod]，目标区间在右侧。first=mod+1,mod= mod + (last - mod) / 2,last不变。

   ![image-20220114152211269](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114152211269.png)

4. 如果要查找元素10

   ![image-20220114152629359](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114152629359.png)

   1. **此时，first=last=mod，并且没有找到对应元素**

5. 如果要查找元素12

   1. 和10的情况一样，但是此时最后一个数值，first和last相等的这个元素还没有判断。因此最后需要再做一个判断。

##### 优秀解法

```java
class Solution02 {
    public int search(int[] nums, int target) {
        int first = 0, last = nums.length - 1, mid = 0;
        while (first<= last) {
            mid = first + (last - first) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                last = mid - 1;
            } else if (nums[mid] < target) {
                first = mid + 1;
            }
        }
        return -1;
    }
}
```

该解法与上述解法最大的却别是在，以区间的最后一个元素的索引（之前是区间的长度）作为mid。

![image-20220114155655432](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114155655432.png)

first：当前筛选区间的第一个元素位置

last:当前筛选区间的最后一个元素位置

mid（注意，与之前不同）：first + (last-first)/2  将筛选区间折半后，分割两区间元素的位置。（最后一个元素的索引/2）

注意：first+1和last-1表示可筛选的元素区间。此处如果不进行+1和-1的操作，如果查找的元素原数组中不包含的话，会成为死循环。

**查找元素9**

1. 初始

   1. ![image-20220114155802999](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114155802999.png)

2. 第一轮循环

   ![image-20220114155817833](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114155817833.png)

3. 第二轮循环

   ![image-20220114160128161](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114160128161.png)

4. 第三轮循环

   ![image-20220114160150225](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114160150225.png)

5. 第四轮循环

   ![image-20220114160158214](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114160158214.png)

##### 扩展

上述二分查找获取元素的条件是元素无重复，和是已经排列好的数组。如果我要找到1,2,2,2,2,3中第一次出现2的位置和最后一次出现2的位置如何寻找呢？

###### 1. 获取目标元素第一次出现的位置

```java
//返回目标元素第一次出现的位置
class Solution03 {
    public int searchRange(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid - 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        //防止出边界。如在1,2,2,2,2,3中查找5  不同考虑right的取值范围
        return left >= nums.length || nums[left] != target ? -1 : left;
    }
}
```

**原始数组**

1. 获取目标数组中2第一次出现的位置

   ![image-20220114180639763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180639763.png)

2. 第一次循环

   ![image-20220114180740347](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180740347.png)

3. 第二次循环

   ![image-20220114181349196](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181349196.png)

4. 第三轮循环  left = right

   此时以获取正确结果为nums[left]

   ![image-20220114181533346](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181533346.png)

**返回值解析**

```java
return left >= nums.length || nums[left] != target ? -1 : left;
```

如果我查找一个原始数组中没有的元素，比如我要查找5

1. 在目标数组中查找元素5

   ![image-20220114181807672](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181807672.png)

2. 第一轮循环

   ![image-20220114181930691](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114181930691.png)

3. 第二轮循环

   ![image-20220114182009377](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182009377.png)

4. 第三轮循环

   没有找到对应的元素，并且left超出边界，所以返回-1

   ![image-20220114182055486](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182055486.png)

###### 2. 获取目标元素最后一次出现的位置

```java
//返回目标元素最后一次出现的位置
class Solution04 {
    public int searchRange(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        //防止出边界。如在1,2,2,2,2,3中查找0  不用考虑left的取值范围。
        return right < 0 || nums[right] != target ? -1 : right;
    }
}
```

**原始数组**

1. 获取目标数组中2最后一次出现的位置

   ![image-20220114180639763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180639763.png)

2. 第一次循环

   ![image-20220114182719465](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182719465.png)

3. 第二次循环

   此时left和right相等

   ![image-20220114182927197](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114182927197.png)

4. 第三轮循环

   此时返回right对应的值即可。

   ![image-20220114183020545](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183020545.png)

**临界值的取值**

1. 获取目标值为0的元素最后一次出现的位置

   ![image-20220114180639763](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114180639763.png)

2. 第一轮循环

   ![image-20220114183312768](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183312768.png)

3. 第二轮循环

   ![image-20220114183342044](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183342044.png)

4. 第三轮循环

   此时right已经出界，并且没有找到目标值，返回-1

   ![image-20220114183429603](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220114183429603.png)

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

结合上一题目的扩展

```java
class Solution05 {
    public int[] searchRange(int[] nums, int target) {
        int arr[] = new int[2];
        int first = getIndex(nums, target, true);
        int last = getIndex(nums, target, false);
        arr[0] = first;
        arr[1] = last;
        return arr;
    }

    public int getIndex(int[] nums, int target, boolean isLeft) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                if (isLeft) {
                    right = mid - 1;
                } else left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        if (isLeft) {
            return left >= nums.length || nums[left] != target ? -1 : left;
        } else return right < 0 || nums[right] != target ? -1 : right;
    }
}
```

### 练习

#### [1011. 在 D 天内送达包裹的能力 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

该题符合单调性，最低载重越大，所用时间越少。最低载重越小，所用时间越长。

将最低载重的大小区间进行二分，找到最符合的最低载重。

**方式一：**

有可能有多个值符合提供的天数，记录所有符合要求的天数，weight的最小值。

```java
//方法一
class Solution08 {
    public int shipWithinDays(int[] weights, int days) {
        if (weights.length == 1) return weights[0];
        //最小重量
        int min = 1;
        //最大重量:所有货物一次运完
        int max = Arrays.stream(weights).sum();
        List<Integer> list = new ArrayList<>();
        while (min <= max) {
            int weight = min + (max - min) / 2;
            int countDays = getDaysByWeight(weights, weight);
            if (countDays > days) {
                //说明每天最低运载能力太小
                min = weight + 1;
            } else if (countDays < days) {
                max = weight - 1;
            } else if (countDays == days) {
                list.add(weight);
                max = weight - 1;
            }
        }
        return list.size() == 0 ? min : list.stream().min(Integer::compareTo).get();
    }

    public int getDaysByWeight(int[] weights, int weight) {
        int days = 0;
        int sumWeight = 0;
        for (int i = 0; i < weights.length; i++) {
            //如果某个包裹大于最小载重，直接返回
            if (weights[i] > weight) {
                days = Integer.MAX_VALUE;
                return days;
            }
            sumWeight += weights[i];
            if (sumWeight == weight) {
                days += 1;
                sumWeight = 0;
            } else if (sumWeight > weight) {
                days += 1;
                sumWeight = weights[i];
            } else if (sumWeight < weight) continue;
        }
        return sumWeight == 0 ? days : days + 1;
    }
}
```

**方式二：**

当countDays<=days视为一种情况，即当符合天数的时候，继续缩小最低载重范围。

```java

//方法二：
class Solution09 {
    public int shipWithinDays(int[] weights, int days) {
        if (weights.length == 1) return weights[0];
        //最小重量
        int min = 1;
        //最大重量:所有货物一次运完
        int max = Arrays.stream(weights).sum();
        while (min <= max) {
            int weight = min + (max - min) / 2;
            int countDays = getDaysByWeight(weights, weight);
            if (countDays > days) {
                //说明每天最低运载能力太小
                min = weight + 1;
            } else  {
                max = weight - 1;
            }
        }
        return min;
    }

    public int getDaysByWeight(int[] weights, int weight) {
        int days = 0;
        int sumWeight = 0;
        for (int i = 0; i < weights.length; i++) {
            //如果某个包裹大于最小载重，直接返回
            if (weights[i] > weight) {
                days = Integer.MAX_VALUE;
                return days;
            }
            sumWeight += weights[i];
            if (sumWeight == weight) {
                days += 1;
                sumWeight = 0;
            } else if (sumWeight > weight) {
                days += 1;
                sumWeight = weights[i];
            } else if (sumWeight < weight) continue;
        }
        return sumWeight == 0 ? days : days + 1;
    }
}
```



#### [875. 爱吃香蕉的珂珂 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/koko-eating-bananas/)

分析思路和1011一样。

**方式一：**

```java
class Solution06 {
    public int minEatingSpeed(int[] piles, int h) {
        //最慢速度
        int min = 1;
        //最快速度
        int max = Arrays.stream(piles).max().getAsInt();
        if (piles.length == h) return max;
        //取中间速度
        while (min <= max) {
            int speed = min + (max - min) / 2;
            if (eatBananaUseSpeed(speed, piles) > h) {
                min = speed + 1;
            } else {
                max = speed - 1;
            }
        }
        //返回最小min，因为题目要求返回最小速度。
        return min;
    }

    public int eatBananaUseSpeed(int speed, int[] piles) {
        //当前速度所用时间
        int time = 0;
        for (int i = 0; i < piles.length; i++) {
            time += piles[i] / speed + (piles[i] % speed == 0 ? 0 : 1);
        }
        return time;
    }
}
```

**方式二**

```java
class Solution07 {
    public int minEatingSpeed(int[] piles, int h) {
        //最慢速度
        int min = 1;
        //最快速度
        int max = Arrays.stream(piles).max().getAsInt();
        //速度
        int speed = 0;
        if (piles.length == h) return max;
        List<Integer> list = new ArrayList<>();
        //取中间速度
        while (min <= max) {
            speed = min + (max - min) / 2;
            if (eatBananaUseSpeed(speed, piles) == h) {
                list.add(speed);
                max = speed - 1;
            } else if (eatBananaUseSpeed(speed, piles) > h) {
                min = speed + 1;
            } else if (eatBananaUseSpeed(speed, piles) < h) {
                max = speed - 1;
            }
        }
        if (list.size() != 0) {
            int minSpeed = list.get(0);
            for (int i = 1; i < list.size(); i++) {
                if (list.get(i) < minSpeed) minSpeed = list.get(i);
            }
            return minSpeed;
        }
        return min;
    }

    public int eatBananaUseSpeed(int speed, int[] piles) {
        //当前速度所用时间
        int time = 0;
        for (int i = 0; i < piles.length; i++) {
            //向上取整
            time += piles[i] / speed + (piles[i] % speed == 0 ? 0 : 1);
        }
        return time;
    }
}

```



## 田忌赛马

分析：

用自己最好的马，比对方最坏的马。

### [870. 优势洗牌](https://leetcode-cn.com/problems/advantage-shuffle/)

思路：

1. 将两个集合排序，进行元素比较。
   1. 如果nums1<nums2  则用nums1最小的和nums2最大的相比
   2. 如果nums1>=nums2 则直接比较即可
2. 注意：
   1. 因为nums2的顺序不能发生改变，因此在nums2排序前，需要先记录nums2中各个元素的索引。
   2. 考虑到有可能nums2中的元素有重复出现的，因此需要用集合存储索引
      1. 用集合ArrayList存储时，通过索引获取元素，再删除元素，索引不好获取，删除的复杂度也比较高，因此不推荐
      2. 使用队列，每次获取到符合要求的元素的时候，出一个他的索引。
   3. tag是偏移量，假如nums1的第一个数小于nums2的第一个数，那么应该用nums1的第一个数去比nums2的最后一个数。
      1. 之后比较的时候，需要用nums1的第二个数，比较nums2的第一个数。tag就是记录这个偏移量的。

```java
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        //使用map存储nums2中数据的顺序（废除原因：nums2中可能存在重复元素）
        Map<Integer, Deque<Integer>> nums2Map = new HashMap<>();
        for (int i = 0; i < nums2.length; i++) {
            Deque<Integer> indexList = nums2Map.getOrDefault(nums2[i], new LinkedList<>());
            indexList.add(i);
            nums2Map.put(nums2[i], indexList);
        }
        //排序
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        //用于nums1的返回
        int[] arr = new int[nums1.length];
        //记录num2的最大数
        int length = nums2.length - 1;
        //记录偏移量（用最小的数干最大的数的数量）
        int tag = 0;
        for (int i = 0; i < nums1.length; i++) {
            if (nums1[i] <= nums2[i - tag]) {
                //获取最快的那匹马的位置   输或者平局都用最菜的马
                Integer integer = nums2Map.get(nums2[length]).pop();
                //换成我方最菜的马。
                arr[integer] = nums1[i];
                length--;
                tag++;
            } else if (nums1[i] > nums2[i - tag]) {
                //获取最快的那匹马的位置
                Integer integer = nums2Map.get(nums2[i - tag]).pop();
                //换成我方最菜的马。
                arr[integer] = nums1[i];
            }
        }
        return arr;
    }
}
```

**方式二：**

思路：

1. 用nums2的最大和我nums1的最大比。
   1. 如果nums1的最大值大于nums2的最大值，符合对比条件。
   2. 如果nums2的最大值小于nums1的最大值，则使用nums中较小的元素。

```java
class  Solution01{
    int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        // 给 nums2 降序排序   优先队列记录当前元素的索引和值。
        PriorityQueue<int[]> maxpq = new PriorityQueue<>(
                (int[] pair1, int[] pair2) -> {
                    return pair2[1] - pair1[1];
                }
        );
        for (int i = 0; i < n; i++) {
            maxpq.offer(new int[]{i, nums2[i]});
        }
        // 给 nums1 升序排序
        Arrays.sort(nums1);
        // nums1[left] 是最⼩值，nums1[right] 是最⼤值
        int left = 0, right = n - 1;
        int[] res = new int[n];
        while (!maxpq.isEmpty()) {
            int[] pair = maxpq.poll();
            // maxval 是 nums2 中的最⼤值，i 是对应索引
            int i = pair[0], maxval = pair[1];
            if (maxval < nums1[right]) {
                // 如果 nums1[right] 能胜过 maxval，那就⾃⼰上
                res[i] = nums1[right];
                right--;
            } else {
                // 否则⽤最⼩值混⼀下，养精蓄锐
                res[i] = nums1[left];
                left++;
            }
        }
        return res;
    }

}
```

## 原地修改数组

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)（快慢指针）

快慢指针理解方式:

![image-20220210153257693](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220210153257693.png)

**方式一：**

使用快慢指针。

思路：

1. 慢指针在起始位置，快指针向前走，如果遇到与慢指针相等的元素，则继续向前。如果遇到与慢指针不相等的元素，则慢指针+1，且将这个不相等的元素赋值给慢指针。
2. [快慢指针 #26 删除排序数组中的重复项 - 删除有序数组中的重复项 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/kuai-man-zhi-zhen-26-shan-chu-pai-xu-shu-xf3t/)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int fast = 0;
        while (fast < nums.length) {
            if (nums[slow] == nums[fast]) {
                fast++;
            } else if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
                //或者
                //nums[++slow] = nums[fast];
            }
        }
        return slow+1;
    }
}
```

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)（快慢指针）

方式一：快慢指针

分析：

1. 初始状况

   ![image-20220211090924511](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220211090924511.png)

2. 快慢指针相等，移动快指针

   ![image-20220211091116913](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220211091116913.png)

3. 快慢指针不相等

   1. 慢指针的next指向快指针
   2. 慢指针切换到慢指针的next
   3. ![image-20220211091141067](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220211091141067.png)

4. 快慢指针不相等

   ![image-20220211091217978](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220211091217978.png)

5. 最后的临界
   1. 保证的是，慢指针指向的元素，是链表不重复的最后一个元素
   2. 因此，即使slow之后的元素都是和slow重复的。
   3. 最后，last指向的节点即最后一个符合要求的节点，直接让slow.next=null，返回原链表即可。
   4. ![image-20220211091431358](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220211091431358.png)



```java
class Solution {
 public ListNode deleteDuplicates(ListNode head) {
       if (head==null) return null;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null) {
            if (slow.val == fast.val) {
                fast = fast.next;

            } else {
                slow.next = fast;
                slow = slow.next;
            }
        }
        slow.next = null;
        return head;
    }
}
```

方式二：循环

循环一：

```javascript
class Solution03 {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode cur = head;
        while (cur != null) {
            //如果当前元素的下一个节点不是null，且两个节点的值相等，进行节点替换。
            if (cur.next != null) {
                if (cur.val == cur.next.val) {
                    ListNode next = cur.next;
                    cur.next = next.next;
                    continue;
                }
                cur = cur.next;
            } else break;  //此时没有子节点，则为null。
        }
        return head;
    }
}

```

循环二：

```java
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;
        ListNode cur = head;
        while (cur.next != null) {
            if (cur.val == cur.next.val) {
                //子节点切换后，直接进入下一轮循环。
                cur.next = cur.next.next;
            } else cur = cur.next;
        }
        return head;
    }
```

#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)（快慢指针）

参考：[代码随想录 (programmercarl.com)](https://www.programmercarl.com/0027.移除元素.html#思路)

快慢指针

思路：

1. 快慢指针同时移动，如果遇到数组元素与目标元素相等，则只移动快指针。
2. 当数组的两个元素不相等，且快慢指针不在同一位置的时候，使用慢指针指向元素替代快指针指向元素。
   1. 替换完成后，快慢指针再同时移动。

```java
class Solution05 {
    public int removeElement(int[] nums, int val) {
        int slow = 0, fast = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                if (slow != fast)
                    nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)（快慢指针）

```java
class Solution07 {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        int fast = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                fast++;
            } else {
                int slowV = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = slowV;
                slow++;
                fast++;
            }
        }
    }
}
```

优化：

```java
//优化：fast每一轮都是递增，可以用i代替fast
class Solution08 {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                int slowV = nums[slow];
                nums[slow] = nums[i];
                nums[i] = slowV;
                slow++;
            }
        }
    }
}
```

# 1.2 链表

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode p1 = list1;
        ListNode p2 = list2;
        //创建虚拟头结点，用于返回结果。
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        while (p1 != null || p2 != null) {
            //如果两个链表都不为null，则进行比较添加
            if (p1 != null && p2 != null) {
                if (p1.val > p2.val) {
                    cur.next = new ListNode(p2.val);
                    p2 = p2.next;
                } else {
                    cur.next = new ListNode(p1.val);
                    p1 = p1.next;
                }
                cur = cur.next;
                //如果出现有一方为null，则直接拼接在结果链表后方
            } else if (p1 == null) {
                cur.next = p2;
                break;
            } else if (p2 == null) {
                cur.next = p1;
                break;
            }
        }
        return dummy.next;
    }
}
```

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

**方法一：使用循环依次比较**

```java
class Solution01 {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        while (true) {
            //遍历获取最小的那个元素的值和索引
            int min = Integer.MAX_VALUE;
            int minIndex = -1;
            for (int i = 0; i < lists.length; i++) {
                ListNode node = lists[i];
                if (node != null) {
                    if (node.val <= min) {
                        min = node.val;
                        minIndex = i;
                    }
                }
            }
            //如果minIndex是-1，说明没有节点
            if (minIndex == -1)
                break;
            //最小的那个节点的元素指针切换。
            lists[minIndex] = lists[minIndex].next;
            //将符合要求的元素的值作为新的节点
            cur.next = new ListNode(min);
            cur = cur.next;
        }
        return dummy.next;
    }
}
```

**方式二：使用优先队列**

```java
class Solution02 {
    public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> pq = new PriorityQueue<>((v1, v2) -> v1.val - v2.val);
        //链表放入队列，以链表中的第一个值进行大小排序
        for (ListNode node : lists) {
            if (node != null) pq.offer(node);
        }
        ListNode dummy = new ListNode(-1);
        ListNode tail = dummy;
        while (!pq.isEmpty()) {
            //出队获取第一个元素
            ListNode minNode = pq.poll();
            tail.next = minNode;
            //将之后的链表重新放入队列
            if (minNode.next != null) pq.offer(minNode.next);
        }
        return dummy.next;
    }
}
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)（快慢指针）

**方式一：记录已走的元素**

```java
//方式一：使用集合记录已遍历的元素，每获取一个链表元素判断集合中有无此元素  时间复杂度O（n2）
class Solution03 {
    public boolean hasCycle(ListNode head) {
        //记录已排查的指针
        List<ListNode> listNodes = new ArrayList<>();
        ListNode cur = head;
        while (cur != null) {
            //判断当前节点的下一个节点，是否指向之前的节点。
            for (ListNode node : listNodes
            ) {
                if (cur.next == node)
                    return true;
            }
            listNodes.add(cur);
            cur = cur.next;
        }
        return false;
    }
}
```

**方式一：快慢指针**

```java
//方式二：快慢指针。慢指针一次走一步，快指针一次走两步。如果快指针到null，说明没环状。如果有环，满指针=快指针。
class Solution04 {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        //fast!=null 用于fast.next!=null的辅助判断。
        //因为fast=fast.next.next，因此必须判断fast.next!=null
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) return true;
        }
        return false;
    }
}

```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)（快慢指针）

题解：当快慢指针相遇后，慢指针指向头结点，快指针还在相遇的指针。  当二者再次相遇后，即是环状的起始节点。

[「代码随想录」你的疑惑，这里都讲清楚了！142. 环形链表 II - 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-jian-hua-gong-shi-jia-2/)

```java
public class Solution {
       public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        //fast!=null 用于fast.next!=null的辅助判断。
        //因为fast=fast.next.next，因此必须判断fast.next!=null
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast){
                slow = head;
                while (slow!=fast){
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```

#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)（快慢指针）

慢指针：一次走一步

快指针：一次走两步

走完之后

1. 如果快指针的为null，说明是偶数个元素，此时慢指针已加，返回慢指针即可。
2. 如果快指针的下一个元素为null，说明是奇数个元素，返回慢指针即可。

![image-20220213213445486](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220213213445486.png)

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast!=null&&fast.next != null) {//如果fast.next==null，说明就一个节点。直接返回即可。
            slow = slow.next;
            fast = fast.next.next;
            if (fast == null||fast.next==null) return slow;
        }
        return head;
    }
}
```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)（快慢指针）

**方式一:hash表**

```java
class Solution08 {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set headASet = new HashSet();
        while (headA != null) {
            headASet.add(headA);
            headA = headA.next;
        }
        while (headB != null) {
            if (headASet.contains(headB)) return headB;
            headB = headB.next;
        }
        return null;
    }
}
```

**方式二：快慢指针**

[160. 相交链表 - 相交链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/160-xiang-jiao-lian-biao-by-chen-wei-f-57i5/)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode slow = headA;
        ListNode fast = headB;
        while (slow != fast) {
            slow = slow == null ? headB : slow.next;
            fast = fast == null ? headA : fast.next;
        }
        return slow;
    }
}
```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)（快慢指针）

题解：

![image-20220214084933233](https://mynotepicbed.oss-cn-beijing.aliyuncs.com/img/image-20220214084933233.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;
        int num = 0;//num：快指针走过的元素数量
        while (fast.next != null) {
            //快指针移动
            fast = fast.next;
            //快指针走过的元素数量增加
            num++;
            //num：快指针走过的元素数量。n:倒数的位置。1：要获取被删除元素的前一个元素
            if (num - n - 1 >= 0) {
                //慢指针移动
                slow = slow.next;
            }
        }
        //删除节点（因为slow走的是fast走过的，fast至少比slow多走一个元素位置。因此slow.next不会=null）
        slow.next = slow.next.next;
        return dummy.next;
    }
```

#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)(待做)

# 1.3 队列和栈

### 栈和队列互相实现

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

**方法一：**

```java
//stack实现01
class MyQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;
    private int size;

    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack();
    }

    public void push(int x) {
        stack1.push(x);
        size++;
    }

    //出队
    public int pop() {
        //如果栈2为null，则将栈1中的所有元素压入栈2
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty())
                stack2.push(stack1.pop());
        }
        //栈2出栈，即出队
        Integer pop = stack2.pop();
        size--;
        return pop;
    }

    public int peek() {
        //队列内没有元素，返回0
        if (size == 0) return 0;
        //取栈2内的元素
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty())
                stack2.push(stack1.pop());
        }
        return stack2.peek();
    }

    public boolean empty() {
        return size == 0;
    }
}
```

**方法二：**

```java
//LinkedList实现
class MyQueue02 {
    private Deque<Integer> stack1;
    private Deque<Integer> stack2;
    private int size;

    public MyQueue02() {
        stack1 = new LinkedList();
        stack2 = new LinkedList();
    }

    public void push(int x) {
        stack1.push(x);
        size++;
    }

    //出队
    public int pop() {
        //如果栈2为null，则将栈1中的所有元素压入栈2
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty())
                stack2.push(stack1.pop());
        }
        //栈2出栈，即出队
        Integer pop = stack2.pop();
        size--;
        return pop;
    }

    public int peek() {
        //队列内没有元素，返回0
        if (size == 0) return 0;
        //取栈2内的元素
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty())
                stack2.push(stack1.pop());
        }
        return stack2.peek();
    }

    public boolean empty() {
        return size == 0;
    }
}
```

#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

**方式一：**

```java
//方式一：保持一个队列有元素，一个队列为null。添加元素添加到有元素的队列，删除元素的时候进行队列元素转移，最后一个元素不发生转移。
class MyStack01 {
    private Queue<Integer> deque1;
    private Queue<Integer> deque2;
    private int size;

    public MyStack01() {
        deque1 = new ArrayDeque();
        deque2 = new ArrayDeque();
    }

    //队列中添加元素，往有元素的队列中添加元素
    public void push(int x) {
        boolean push = deque1.isEmpty() ? deque2.offer(x) : deque1.offer(x);
        size++;
    }

    //出队列  trans：将有元素的队列中的元素转移到无元素的队列中。最后一个元素不进行转入。
    public int pop() {
        int top;
        if (deque1.isEmpty()) {
            top = trans(deque1, deque2);
            size--;
            return top;
        } else {
            top = trans(deque2, deque1);
            size--;
            return top;
        }
    }

    //调用trans：因为最后一个元素没有转入，因此需要重新添加入队。
    public int top() {
        int top;
        if (deque1.isEmpty()) {
            top = trans(deque1, deque2);
            deque1.offer(top);
        } else {
            top = trans(deque2, deque1);
            deque2.offer(top);
        }
        return top;
    }


    //trans：将有元素的队列中的元素转移到无元素的队列中。最后一个元素不进行转入。
    public int trans(Queue<Integer> emptyQueue, Queue<Integer> queue) {
        while (!queue.isEmpty()) {
            Integer poll = queue.poll();
            if (queue.peek() == null)
                return poll;
            emptyQueue.offer(poll);
        }
        return 0;
    }

    public boolean empty() {
        return size == 0;
    }
}
```

**方式二：**

```java
//方式二：一个消费队列，一个缓冲序列。每次往消费队列中添加元素的时候，将元素放入到缓冲队列。（添加元素的时候，如果缓冲队列有元素，将缓冲队列的元素放入消费队列。） 保证消费队列永远为null
class MyStack02 {
    //消费队列
    private Queue<Integer> deque1;
    //缓冲队列
    private Queue<Integer> deque2;
    private int size;

    public MyStack02() {
        deque1 = new ArrayDeque();
        deque2 = new ArrayDeque();
    }

    //消费队列放入元素，将缓冲列的元素放入消费队列。
    public void push(int x) {
        deque1.offer(x);
        size++;
        while (!deque2.isEmpty()) {
            deque1.offer(deque2.poll());
        }
        //交换  保证消费队列一致为null
        Queue<Integer> temp = deque1;
        deque1 = deque2;
        deque2 = temp;
    }

    public int pop() {
        size--;
        return deque2.isEmpty() ? 0 : deque2.poll();
    }

    public int top() {
        return deque2.isEmpty() ? 0 : deque2.peek();
    }


    public boolean empty() {
        return size == 0;
    }
}

```

### 括号

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)（栈）

**方式一：**[有效的括号（辅助栈法，极简+图解） - 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/valid-parentheses/solution/valid-parentheses-fu-zhu-zhan-fa-by-jin407891080/)

```java
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<Character, Character>() {{
            put('(', ')');
            put('[', ']');
            put('{', '}');
        }};
        Deque<Character> stack = new LinkedList<>();
        for (int i = 0; i < s.length(); i++) {
            char cur = s.charAt(i);
            if (map.containsKey(cur)) {
                stack.add(cur);
            } else {
                if (stack.isEmpty()) return false;
                Character last = stack.removeLast();
                if (map.get(last) != cur) return false;
            }
        }
        return stack.isEmpty();
    }
}
```

**方式二：**

```java
class Solution {
 public  boolean isValid(String s) {
      if (s.length() == 0 || s.length() % 2 != 0) return false;
        Stack<Character> stack = new Stack<>();
        for (char v : s.toCharArray()) {
            if (v == '(') {
                stack.push(')');
            } else if (v == '[') {
                stack.push(']');
            } else if (v == '{') {
                stack.push('}');
            } else if (stack.isEmpty() || stack.pop() != v) return false;
        }
        return stack.isEmpty();
    }
}
```

**方式 三：复杂**

```java
class Solution {
 public  boolean isValid(String s) {
        //奇数长度淘汰
        if (s.length() == 0 || s.length() % 2 != 0) return false;
        char[] chars = s.toCharArray();
        //右括号为首元素直接淘汰
        if (judgeIsRight(chars[0])) return false;
        Stack stack = new Stack();
        for (int i = 0; i < s.length(); i++) {
            char v = chars[i];
            //进入右括号时，走匹配。注意：当stack.size为0时，使用peek会出现报错。
            if (stack.isEmpty() || !judgeIsRight(v)) {
                stack.push(v);
            } else {
                char peek = (char) stack.peek();
                switch (peek) {
                    case '(':
                        if (!isMatch(stack, v, ')')) return false;
                        break;
                    case '[':
                        if (!isMatch(stack, v, ']')) return false;
                        break;
                    case '{':
                        if (!isMatch(stack, v, '}')) return false;
                        break;
                }
            }
        }
        //匹配完毕，当栈内元素清空，则说明完全匹配，否则不成立。
        return stack.isEmpty();
    }

    //判断是否为右括号
    public static boolean judgeIsRight(char v) {
        if (v == ')' || v == ']' || v == '}') return true;
        return false;
    }

    //判断)或]或}括号是否匹配。匹配返回true，否则false
    public static boolean isMatch(Stack stack, char v, char k) {
        if (v != k) return false;
        stack.pop();
        return true;
    }
}
```

#### [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)(栈)

**方式一：使用栈**

```java
class Solution03 {
    public int minAddToMakeValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            if (!stack.isEmpty()) {
                //如果栈顶元素是( 并且添加的是)，则出栈，否则进入栈
                if (stack.peek() == '(' && stack.peek() != s.charAt(i)) stack.pop();
                else stack.push(s.charAt(i));
            } else stack.push(s.charAt(i)); //为null的时候，直接入栈
        }
        return stack.size();
    }
}
```



**方式二：记录左右括号的需求量**

以右括号的需求量为基准：

1. 如果添加(   ，右括号需求量+1
2. 如果添加） ， 右括号需求量-1
3. 如果右括号的需求量变为负数时，说明需要左括号。则左括号+1，此时右括号的需求量变为0

```java
class Solution {
       public int minAddToMakeValid(String s) {
        //左括号的需求量
        int left = 0;
        //右括号的需求量
        int right = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                right++;
            } else {
                right--;
                if (right == -1) {
                    left++;
                    right=0;
                }
            }
        }
        return right + left;
    }
}
```

#### [1541. 平衡括号字符串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/)

```java
class Solution {
      public int minInsertions(String s) {
        //实际插入的元素的数量
        int res = 0;
        //需求的右侧括号的数量
        int need = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                need += 2;
                //当遇到左括号时，若对右括号的需求量为奇数，需要插⼊ 1 个右括号。因为⼀个左括号需要两个右括号嘛，右括号的需求必须是偶数
                if (need % 2 == 1) {
                    // 插⼊⼀个右括号
                    res++;
                    // 对右括号的需求减⼀
                    need--;
                }
            } else {
                need--;
                //如果right=-1,说明多了一个右括号，如果多了一个右括号，则需要再多一个左括号和右括号。
                if (need == -1) {
                    //需要插入一个左括号
                    res++;
                    //右括号的需求量变为1
                    need = 1;
                }
            }
        }
        return res + need;
    }
}
```

### 单调栈

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)（栈）

**方式一：双指针**，思路有点像双层for循环。

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int slow = 0;
        int fast = 1;
        int[] res = new int[temperatures.length];
        while (slow < temperatures.length) {
            if (fast >= temperatures.length) {
                res[slow] = 0;
                slow++;
                fast = slow + 1;
            } else {
                if (temperatures[slow] <= temperatures[fast]) {
                    fast++;
                } else {
                    res[slow] = fast-slow;
                    slow++;
                    fast = slow + 1;
                }
            }
        }
        return res;
    }
}
```

**方式二：栈思想**

参考文章：[LeetCode 图解 | 739.每日温度 - 每日温度 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/)

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
         Stack<Integer> stack = new Stack();
        int[] res = new int[temperatures.length];
        for (int i =0; i<temperatures.length; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                Integer top = stack.pop();
                res[top] = i - top;
            }
            stack.push(i);
        }
        return res;
    }
}
```

#### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

**方式一：**[动画演示 单调栈 496.下一个更大元素I - 下一个更大元素 I - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/next-greater-element-i/solution/dong-hua-yan-shi-dan-diao-zhan-496xia-yi-ql65/)

```java
class Solution {
  public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];
      	//map记录nums2中的每个元素对应比他大的第一个元素
        Map<Integer, Integer> map = new HashMap<>();
        //通过栈，获取nums中每一个元素比他大的那个元素
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < nums2.length; i++) {
            while (!stack.isEmpty() && stack.peek() < nums2[i]) {
                map.put(stack.pop(), nums2[i]);
            }
            stack.push(nums2[i]);
        }
        //处理nums1
        for (int i = 0; i < nums1.length; i++) {
            if (map.containsKey(nums1[i])) res[i] = map.get(nums1[i]);
            else res[i]=-1;
        }
        return res;
    }
}
```

#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

**方式一：**[代码随想录 (programmercarl.com)](https://programmercarl.com/0503.下一个更大元素II.html#其他语言版本)

循环数组：一个数组后面又拼接一个。

注意取%

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int size = nums.length;
        int[] res = new int[size];
        Arrays.fill(res,-1);//默认全部初始化为-1
        for (int i = 0; i < size *2; i++) {
           while (!stack.isEmpty()&&nums[i%size]>nums[stack.peek()]){
               res[stack.pop()] = nums[i%size];
           }
           stack.push(i%size);
        }
        return res;
    }
}
```

### 单调队列

#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

参考题解：[动画演示 单调队列 239.滑动窗口最大值 - 滑动窗口最大值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sliding-window-maximum/solution/dong-hua-yan-shi-dan-diao-dui-lie-239hua-hc5u/)

```java
class Solution01 {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 窗口个数
        int[] res = new int[nums.length - k + 1];
        LinkedList<Integer> queue = new LinkedList<>();

        // 遍历数组中元素，right表示滑动窗口右边界
        for (int right = 0; right < nums.length; right++) {
            // 如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。
            // 直到，队列为空或当前考察元素小于新的队尾元素
            while (!queue.isEmpty() && nums[right] >= nums[queue.peekLast()]) {
                queue.removeLast();
            }

            // 存储元素下标
            queue.addLast(right);

            // 计算窗口左侧边界
            int left = right - k + 1;
            // 当队首元素的下标小于滑动窗口左侧边界left时
            // 表示队首元素已经不再滑动窗口内，因此将其从队首移除
            if (queue.peekFirst() < left) {
                queue.removeFirst();
            }

            // 由于数组下标从0开始，因此当窗口右边界right+1大于等于窗口大小k时
            // 意味着窗口形成。此时，队首元素就是该窗口内的最大值
            if (right + 1 >= k) {
                res[left] = nums[queue.peekFirst()];
            }
        }
        return res;
    }
}
```

### 字符串去重

#### [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

假如要去重字符串  bcabc   最终返回结果应该是  abc

情况一：

1. 使用栈记录无重复元素

2. 使用boolean类型的数组判断元素是否重复，不重复则将元素放入栈(时间复杂度为O（1）)

3. 最后将元素从栈中取出并反转，获取目标数组。

4. ```java
   class Solution {
       public String removeDuplicateLetters(String s) {
           //字符
           char[] chars = s.toCharArray();
           //栈，用于记录无重复元素
           Stack<Character> stack = new java.util.Stack<>();
           //用于记录栈中是否包含某个元素    查询速度为O（1），如果使用stack提供的contains，查询速度是O（n）
           boolean[] isContains = new boolean[256];
           for (int i = 0; i < chars.length; i++) {
               //true，说明该元素已经添加过
               if (isContains[chars[i]]) {
                   continue;
               }
               stack.push(chars[i]);
               isContains[chars[i]] = true;
           }
           StringBuilder stringBuilder = new StringBuilder();
           while (!stack.isEmpty()) stringBuilder.append(stack.pop());
           //将栈内的字符串翻转。
           return stringBuilder.reverse().toString();
       }
   }
   ```

5. 问题：

   1. bcabc来说，放入栈中的是bca，因此最后返回bca，字典序不是最小。最小的字典值是abc

6. 解决：

   1. 每次往栈添加的时候，判断当前元素是否小于栈中的元素，如果小于栈中元素，则栈中比当前元素小的元素出栈，保证栈内元素的大小从栈低到栈顶是从小到大。

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        //字符
        char[] chars = s.toCharArray();
        //栈，用于记录无重复元素
        Stack<Character> stack = new java.util.Stack<>();
        //用于记录栈中是否包含某个元素    查询速度为O（1），如果使用stack提供的contains，查询速度是O（n）
        boolean[] isContains = new boolean[256];
        for (int i = 0; i < chars.length; i++) {
            //true，说明该元素已经添加过
            if (isContains[chars[i]]) {
                continue;
            }
            //优化1：判断当前元素是否小于栈顶元素，如果小于，则栈顶元素出栈。
            while (!stack.isEmpty() && chars[i] < stack.peek()) {
                isContains[stack.peek()] = false;
                stack.pop();
            }
            stack.push(chars[i]);
            isContains[chars[i]] = true;
        }
        StringBuilder stringBuilder = new StringBuilder();
        while (!stack.isEmpty()) stringBuilder.append(stack.pop());
        //将栈内的字符串翻转。
        return stringBuilder.reverse().toString();
    }
}
```

7. 问题：
   1. 此时还遇到一个问题，之前举例是bcabc，适应上述这种情况，如果是bcab的话，最后的返回结果是ab，则不符合要求。
8. 解决：
   1. 我们不仅要保证添加到栈内的元素是从小到大排列，还要保证从栈中移除的元素，之后还会出现，拿bcab来说，如果把c移除了，之后c就不会再出现了，因此我们还需要记录栈内元素的数量。

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        //字符
        char[] chars = s.toCharArray();
        //栈，用于记录无重复元素
        Stack<Character> stack = new java.util.Stack<>();
        //用于基础s中每个字符的数量
        int[] nums = new int[256];
        for (int i = 0; i < chars.length; i++)
            nums[chars[i]]++;
        //用于记录栈中是否包含某个元素    查询速度为O（1），如果使用stack提供的contains，查询速度是O（n）
        boolean[] isContains = new boolean[256];
        for (int i = 0; i < chars.length; i++) {
            //true，说明该元素已经添加过
            if (isContains[chars[i]]) {
                nums[chars[i]]--;
                continue;
            }
            //优化1：判断当前元素是否小于栈顶元素，如果小于，则栈顶元素出栈。
            while (!stack.isEmpty() && chars[i] < stack.peek() && nums[stack.peek()] > 0) {
                isContains[stack.peek()] = false;
                stack.pop();
            }
            stack.push(chars[i]);
            nums[chars[i]]--;
            isContains[chars[i]] = true;
        }
        StringBuilder stringBuilder = new StringBuilder();
        while (!stack.isEmpty()) stringBuilder.append(stack.pop());
        //将栈内的字符串翻转。
        return stringBuilder.reverse().toString();
    }
}
```

# 1.4 数据结构设计

### LRU

#### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

移出最久未使用。

思路：

1. 使用map记录指向元素，使用双向链表存储缓存元素。
   1. 使用map原因：get复杂度为O1
   2. 使用双向链表原因：put操作的时候，如果超出最大容量限制，需要移除最少使用或最早使用的元素。并要求复杂度为O1
      1. 添加元素时，每次添加到链表的末尾，表示最新添加或最少使用元素
      2. 删除元素时，直接删除头结点指定的元素
      3. 获取元素时，将该元素的位置移动到链表的末尾

```java
class LRUCache {
    Map<Integer, Node> map;
    DoubleLinkedList doubleLinkedList;
    int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<>();
        this.doubleLinkedList = new DoubleLinkedList();
    }

    public int get(int key) {
        Node node = map.get(key);
        if (node == null) return -1;
        changeRank(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            //切换节点的优先级
            changeRank(node);
        } else {
            if (capacity > 0) {
                //添加新的元素
                addNode(key, value);
            } else {
                //移除最久不使用元素
                remove();
                //添加新的元素
                addNode(key, value);
            }
        }
    }

    //切换节点位置：最近添加和最近使用的放入链表尾部指向
    private void changeRank(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        addNodeToTail(node);
    }

    //移除节点：移除头结点指向的节点
    public void remove() {
        Node headEle = doubleLinkedList.head;
        map.remove(headEle.next.key);
        headEle.next = headEle.next.next;
        headEle.next.prev = headEle;
        capacity++;
    }

    //添加节点：添加节点到末尾
    public void addNode(int key, int value) {
        Node node = new Node(key, value);
        addNodeToTail(node);
        map.put(key, node);
        capacity--;
    }

    //将元素添加至链表末尾
    public void addNodeToTail(Node node) {
        //尾元素
        Node tailNode = doubleLinkedList.tail;
        //尾元素前一个元素
        Node beforeNode = tailNode.prev;
        tailNode.prev = node;
        node.next = tailNode;
        node.prev = beforeNode;
        beforeNode.next = node;
    }
}

//创建双向链表
class DoubleLinkedList {
    Node head;
    Node tail;

    public DoubleLinkedList() {
        head = new Node(-1, -1);
        tail = new Node(-1, -1);
        head.next = tail;
        tail.prev = head;
    }

}

//创建节点
class Node {
    int key;
    int value;
    Node prev;
    Node next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```

### LFU

#### [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)

题解：

[超详细图解+动图演示 460. LFU缓存 - LFU 缓存 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/lfu-cache/solution/chao-xiang-xi-tu-jie-dong-tu-yan-shi-460-lfuhuan-c/)

[超详细图解+动图演示 460. LFU缓存 - LFU 缓存 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/)

```java
class LFUCache {
    //存储节点，key为键
    Map<Integer, Node> dataMap;
    //存储链表，key为数量
    Map<Integer, DoubleLinkedList> countMap;
    //缓存大小  如果capacity为-1，说明传入的capacity为0
    int capacity;
    //最小出现元素频率的索引
    int minCount;

    public LFUCache(int capacity) {
        this.capacity = capacity == 0 ? -1 : capacity;
        this.dataMap = new HashMap<>();
        this.countMap = new HashMap<>();
    }

    public int get(int key) {
        Node node = dataMap.get(key);
        int resVal = -1;
        if (node != null && capacity != -1) {
            //1.删除元素在原频次链表中的位置
            delEleAtOriginList(node);
            //2.使用频率增加
            node.count++;
            //3.移动该删除元素到新的频次链表中，新添加的元素要添加到链表的末尾
            addEleAtNewList(node);
                        resVal = node.value;
        }
        return resVal;
    }

    public void put(int key, int value) {
        if (capacity == -1) return;
        if (dataMap.containsKey(key)) {
            //1.节点内容更新
            Node node = dataMap.get(key);
            node.value = value;
            //2.删除元素在原频次链表中的位置
            delEleAtOriginList(node);
            //3.添加已存在元素，不需要进行minCount判断，使用频率增加
            node.count++;
            //4.移动该删除元素到新的频次链表中，新添加的元素要添加到链表的末尾
            addEleAtNewList(node);
        } else {
            //容量足
            if (capacity > 0) {
                Node node = new Node(key, value);
                //新添加元素放入dataMap
                dataMap.put(key, node);
                //更新最小使用频率
                minCount = 1;
                //新添加的元素放置末尾
                addEleAtNewList(node);
                //缓存大小-1
                capacity--;
            } else if (capacity == 0) {//容量不足
                //移除元素
                del();
                Node node = new Node(key, value);
                //元素添加到map
                dataMap.put(key, node);
                //更新最小使用频率
                minCount = 1;
                //新添加的元素放置末尾
                addEleAtNewList(node);
                //总容量减少
                capacity--;
            }
        }


    }

    //删除元素
    private void del() {
        //获取使用频率最小的双向链表
        DoubleLinkedList list = countMap.get(minCount);
        //移除链表中的第一个元素
        Node head = list.head;
        Node delEle = list.head.next;
        head.next = delEle.next;
        delEle.next.pre = head;
        dataMap.remove(delEle.key);
        list.capacity--;
        if (list.capacity == 0) {
            countMap.remove(minCount);
        }
        //总容量变大
        capacity++;
    }

    //删除元素在原频次链表的位置
    private void delEleAtOriginList(Node node) {
        DoubleLinkedList originList = countMap.get(node.count);
        node.pre.next = node.next;
        node.next.pre = node.pre;
        originList.capacity--;
        if (originList.capacity == 0) {
            countMap.remove(node.count);
            if (minCount == node.count) minCount++;
        }
    }

    //删除元素在原频次链表的位置
    private void addEleAtNewList(Node node) {
        DoubleLinkedList nowList = countMap.getOrDefault(node.count, new DoubleLinkedList());
        Node tailEle = nowList.tail;
        Node tailPreEle = tailEle.pre;
        tailPreEle.next = node;
        node.pre = tailPreEle;
        node.next = tailEle;
        tailEle.pre = node;
        nowList.capacity++;
        countMap.put(node.count, nowList);
    }
}

class Node {
    int key;
    int value;
    int count;
    Node pre;
    Node next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
        this.count = 1;
    }
}

class DoubleLinkedList {

    Node head;
    Node tail;
    int capacity;

    public DoubleLinkedList() {
        this.head = new Node(-1, -1);
        this.tail = new Node(-1, -1);
        head.next = tail;
        tail.pre = head;
        this.capacity = 0;
    }
}

```

